<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>QuantEcon · QuantEcon.jl</title><meta name="title" content="QuantEcon · QuantEcon.jl"/><meta property="og:title" content="QuantEcon · QuantEcon.jl"/><meta property="twitter:title" content="QuantEcon · QuantEcon.jl"/><meta name="description" content="Documentation for QuantEcon.jl."/><meta property="og:description" content="Documentation for QuantEcon.jl."/><meta property="twitter:description" content="Documentation for QuantEcon.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../index.html">QuantEcon.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../index.html">Home</a></li><li><span class="tocitem">API</span><ul><li class="is-active"><a class="tocitem" href="QuantEcon.html">QuantEcon</a><ul class="internal"><li><a class="tocitem" href="#Index"><span>Index</span></a></li><li><a class="tocitem" href="#Exported"><span>Exported</span></a></li><li><a class="tocitem" href="#Internal"><span>Internal</span></a></li></ul></li></ul></li><li><a class="tocitem" href="../man/contributing.html">Contributing</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">API</a></li><li class="is-active"><a href="QuantEcon.html">QuantEcon</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="QuantEcon.html">QuantEcon</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/QuantEcon/QuantEcon.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/QuantEcon/QuantEcon.jl/blob/master/docs/src/api/QuantEcon.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="QuantEcon"><a class="docs-heading-anchor" href="#QuantEcon">QuantEcon</a><a id="QuantEcon-1"></a><a class="docs-heading-anchor-permalink" href="#QuantEcon" title="Permalink"></a></h1><p>API documentation</p><ul><li><a href="QuantEcon.html#QuantEcon">QuantEcon</a></li><li class="no-marker"><ul><li><a href="QuantEcon.html#Index">Index</a></li><li><a href="QuantEcon.html#Exported">Exported</a></li><li><a href="QuantEcon.html#Internal">Internal</a></li></ul></li></ul><h2 id="Index"><a class="docs-heading-anchor" href="#Index">Index</a><a id="Index-1"></a><a class="docs-heading-anchor-permalink" href="#Index" title="Permalink"></a></h2><ul><li><a href="QuantEcon.html#QuantEcon.ARMA"><code>QuantEcon.ARMA</code></a></li><li><a href="QuantEcon.html#QuantEcon.CFEUtility"><code>QuantEcon.CFEUtility</code></a></li><li><a href="QuantEcon.html#QuantEcon.CRRAUtility"><code>QuantEcon.CRRAUtility</code></a></li><li><a href="QuantEcon.html#QuantEcon.DPSolveResult"><code>QuantEcon.DPSolveResult</code></a></li><li><a href="QuantEcon.html#QuantEcon.DiscreteDP"><code>QuantEcon.DiscreteDP</code></a></li><li><a href="QuantEcon.html#QuantEcon.DiscreteDP-Union{Tuple{Tind}, Tuple{Tbeta}, Tuple{NR}, Tuple{NQ}, Tuple{T}, Tuple{AbstractArray{T, NR}, AbstractArray{T, NQ}, Tbeta, Vector{Tind}, Vector{Tind}}} where {T, NQ, NR, Tbeta, Tind}"><code>QuantEcon.DiscreteDP</code></a></li><li><a href="QuantEcon.html#QuantEcon.DiscreteDP-Union{Tuple{Tbeta}, Tuple{NR}, Tuple{NQ}, Tuple{T}, Tuple{Array{T, NR}, AbstractArray{T, NQ}, Tbeta}} where {T, NQ, NR, Tbeta}"><code>QuantEcon.DiscreteDP</code></a></li><li><a href="QuantEcon.html#QuantEcon.DiscreteRV"><code>QuantEcon.DiscreteRV</code></a></li><li><a href="QuantEcon.html#QuantEcon.EllipticalUtility"><code>QuantEcon.EllipticalUtility</code></a></li><li><a href="QuantEcon.html#QuantEcon.Kalman"><code>QuantEcon.Kalman</code></a></li><li><a href="QuantEcon.html#QuantEcon.LAE"><code>QuantEcon.LAE</code></a></li><li><a href="QuantEcon.html#QuantEcon.LCPResult"><code>QuantEcon.LCPResult</code></a></li><li><a href="QuantEcon.html#QuantEcon.LQ"><code>QuantEcon.LQ</code></a></li><li><a href="QuantEcon.html#QuantEcon.LQ"><code>QuantEcon.LQ</code></a></li><li><a href="QuantEcon.html#QuantEcon.LSS"><code>QuantEcon.LSS</code></a></li><li><a href="QuantEcon.html#QuantEcon.LinInterp"><code>QuantEcon.LinInterp</code></a></li><li><a href="QuantEcon.html#QuantEcon.LogUtility"><code>QuantEcon.LogUtility</code></a></li><li><a href="QuantEcon.html#QuantEcon.MPFI"><code>QuantEcon.MPFI</code></a></li><li><a href="QuantEcon.html#QuantEcon.MVNSampler-Union{Tuple{TS}, Tuple{TM}, Tuple{Vector{TM}, Matrix{TS}}} where {TM&lt;:Real, TS&lt;:Real}"><code>QuantEcon.MVNSampler</code></a></li><li><a href="QuantEcon.html#QuantEcon.MVNSampler"><code>QuantEcon.MVNSampler</code></a></li><li><a href="QuantEcon.html#QuantEcon.MarkovChain-Tuple{DiscreteDP, QuantEcon.DPSolveResult}"><code>QuantEcon.MarkovChain</code></a></li><li><a href="QuantEcon.html#QuantEcon.MarkovChain"><code>QuantEcon.MarkovChain</code></a></li><li><a href="QuantEcon.html#QuantEcon.PFI"><code>QuantEcon.PFI</code></a></li><li><a href="QuantEcon.html#QuantEcon.PivOptions"><code>QuantEcon.PivOptions</code></a></li><li><a href="QuantEcon.html#QuantEcon.RBLQ"><code>QuantEcon.RBLQ</code></a></li><li><a href="QuantEcon.html#QuantEcon.SimplexGrid"><code>QuantEcon.SimplexGrid</code></a></li><li><a href="QuantEcon.html#QuantEcon.VAREstimationMethod"><code>QuantEcon.VAREstimationMethod</code></a></li><li><a href="QuantEcon.html#QuantEcon.VFI"><code>QuantEcon.VFI</code></a></li><li><a href="QuantEcon.html#Base.:*-Union{Tuple{T}, Tuple{AbstractArray{T, 3}, AbstractVector}} where T"><code>Base.:*</code></a></li><li><a href="QuantEcon.html#Base.rand-Tuple{DiscreteRV, Int64}"><code>Base.rand</code></a></li><li><a href="QuantEcon.html#Base.rand-Tuple{DiscreteRV}"><code>Base.rand</code></a></li><li><a href="QuantEcon.html#DSP.Periodograms.periodogram"><code>DSP.Periodograms.periodogram</code></a></li><li><a href="QuantEcon.html#Graphs.period-Tuple{MarkovChain}"><code>Graphs.period</code></a></li><li><a href="QuantEcon.html#QuantEcon.F_to_K-Tuple{RBLQ, Matrix}"><code>QuantEcon.F_to_K</code></a></li><li><a href="QuantEcon.html#QuantEcon.K_to_F-Tuple{RBLQ, Matrix}"><code>QuantEcon.K_to_F</code></a></li><li><a href="QuantEcon.html#QuantEcon.RQ_sigma-Union{Tuple{T}, Tuple{DiscreteDP{T, 3, 2, Tbeta, Tind, TQ} where {T, Tbeta, Tind, TQ}, AbstractVector{T}}} where T&lt;:Integer"><code>QuantEcon.RQ_sigma</code></a></li><li><a href="QuantEcon.html#QuantEcon.RQ_sigma-Tuple{DiscreteDP, QuantEcon.DPSolveResult}"><code>QuantEcon.RQ_sigma</code></a></li><li><a href="QuantEcon.html#QuantEcon._compute_sequence-Union{Tuple{T}, Tuple{LQ, T, Any}} where T"><code>QuantEcon._compute_sequence</code></a></li><li><a href="QuantEcon.html#QuantEcon._compute_sequence-Union{Tuple{T}, Tuple{LQ, Vector{T}, Any}} where T"><code>QuantEcon._compute_sequence</code></a></li><li><a href="QuantEcon.html#QuantEcon._generate_a_indptr!-Tuple{Int64, AbstractVector, AbstractVector}"><code>QuantEcon._generate_a_indptr!</code></a></li><li><a href="QuantEcon.html#QuantEcon._get_solution!-Union{Tuple{T}, Tuple{Vector{T}, Matrix{T}, Vector{&lt;:Integer}}} where T"><code>QuantEcon._get_solution!</code></a></li><li><a href="QuantEcon.html#QuantEcon._has_sorted_sa_indices-Tuple{AbstractVector, AbstractVector}"><code>QuantEcon._has_sorted_sa_indices</code></a></li><li><a href="QuantEcon.html#QuantEcon._initialize_tableau!-Union{Tuple{T}, Tuple{Matrix{T}, Vector{&lt;:Integer}, AbstractMatrix, AbstractVector, AbstractVector}} where T"><code>QuantEcon._initialize_tableau!</code></a></li><li><a href="QuantEcon.html#QuantEcon._lex_min_ratio_test!-Tuple{AbstractMatrix, Integer, Integer, AbstractVector{&lt;:Integer}}"><code>QuantEcon._lex_min_ratio_test!</code></a></li><li><a href="QuantEcon.html#QuantEcon._min_ratio_test_no_tie_breaking!-Union{Tuple{T}, Tuple{AbstractMatrix{T}, Integer, Integer, AbstractVector{&lt;:Integer}, Integer, Real, Real}} where T"><code>QuantEcon._min_ratio_test_no_tie_breaking!</code></a></li><li><a href="QuantEcon.html#QuantEcon._pivoting!-Union{Tuple{T}, Tuple{AbstractMatrix{T}, Integer, Integer, Vector{T}}} where T&lt;:AbstractFloat"><code>QuantEcon._pivoting!</code></a></li><li><a href="QuantEcon.html#QuantEcon._random_stochastic_matrix-Tuple{Random.AbstractRNG, Integer, Integer}"><code>QuantEcon._random_stochastic_matrix</code></a></li><li><a href="QuantEcon.html#QuantEcon._solve!-Tuple{DiscreteDP, QuantEcon.DPSolveResult{VFI}, Integer, Real, Integer}"><code>QuantEcon._solve!</code></a></li><li><a href="QuantEcon.html#QuantEcon._solve!-Tuple{DiscreteDP, QuantEcon.DPSolveResult{PFI}, Integer, Real, Integer}"><code>QuantEcon._solve!</code></a></li><li><a href="QuantEcon.html#QuantEcon._solve!-Tuple{DiscreteDP, QuantEcon.DPSolveResult{MPFI}, Integer, Real, Integer}"><code>QuantEcon._solve!</code></a></li><li><a href="QuantEcon.html#QuantEcon.allcomb3-Tuple{AbstractMatrix}"><code>QuantEcon.allcomb3</code></a></li><li><a href="QuantEcon.html#QuantEcon.ar_periodogram"><code>QuantEcon.ar_periodogram</code></a></li><li><a href="QuantEcon.html#QuantEcon.autocovariance-Tuple{ARMA}"><code>QuantEcon.autocovariance</code></a></li><li><a href="QuantEcon.html#QuantEcon.b_operator-Tuple{RBLQ, Matrix}"><code>QuantEcon.b_operator</code></a></li><li><a href="QuantEcon.html#QuantEcon.backward_induction-Union{Tuple{T}, Tuple{DiscreteDP{T, NQ, NR, Tbeta, Tind, TQ} where {NQ, NR, Tbeta&lt;:Real, Tind, TQ&lt;:AbstractArray{T, NQ}}, Integer}, Tuple{DiscreteDP{T, NQ, NR, Tbeta, Tind, TQ} where {NQ, NR, Tbeta&lt;:Real, Tind, TQ&lt;:AbstractArray{T, NQ}}, Integer, AbstractVector{&lt;:Real}}} where T"><code>QuantEcon.backward_induction</code></a></li><li><a href="QuantEcon.html#QuantEcon.bellman_operator-Tuple{DiscreteDP, AbstractVector}"><code>QuantEcon.bellman_operator</code></a></li><li><a href="QuantEcon.html#QuantEcon.bellman_operator!-Tuple{DiscreteDP, AbstractVector, AbstractVector, AbstractVector}"><code>QuantEcon.bellman_operator!</code></a></li><li><a href="QuantEcon.html#QuantEcon.bellman_operator!-Union{Tuple{T}, Tuple{DiscreteDP, AbstractVector{T}, AbstractVector}} where T&lt;:AbstractFloat"><code>QuantEcon.bellman_operator!</code></a></li><li><a href="QuantEcon.html#QuantEcon.bellman_operator!-Tuple{DiscreteDP, QuantEcon.DPSolveResult}"><code>QuantEcon.bellman_operator!</code></a></li><li><a href="QuantEcon.html#QuantEcon.bisect-Union{Tuple{T}, Tuple{Function, T, T}} where T&lt;:AbstractFloat"><code>QuantEcon.bisect</code></a></li><li><a href="QuantEcon.html#QuantEcon.brent-Union{Tuple{T}, Tuple{Function, T, T}} where T&lt;:AbstractFloat"><code>QuantEcon.brent</code></a></li><li><a href="QuantEcon.html#QuantEcon.brenth-Union{Tuple{T}, Tuple{Function, T, T}} where T&lt;:AbstractFloat"><code>QuantEcon.brenth</code></a></li><li><a href="QuantEcon.html#QuantEcon.ckron"><code>QuantEcon.ckron</code></a></li><li><a href="QuantEcon.html#QuantEcon.communication_classes-Tuple{MarkovChain}"><code>QuantEcon.communication_classes</code></a></li><li><a href="QuantEcon.html#QuantEcon.compute_deterministic_entropy-Tuple{RBLQ, Any, Any, Any}"><code>QuantEcon.compute_deterministic_entropy</code></a></li><li><a href="QuantEcon.html#QuantEcon.compute_fixed_point-Union{Tuple{TV}, Tuple{Function, TV}} where TV"><code>QuantEcon.compute_fixed_point</code></a></li><li><a href="QuantEcon.html#QuantEcon.compute_greedy-Union{Tuple{TV}, Tuple{DiscreteDP, AbstractVector{TV}}} where TV&lt;:Real"><code>QuantEcon.compute_greedy</code></a></li><li><a href="QuantEcon.html#QuantEcon.compute_greedy!-Tuple{DiscreteDP, QuantEcon.DPSolveResult}"><code>QuantEcon.compute_greedy!</code></a></li><li><a href="QuantEcon.html#QuantEcon.compute_loglikelihood-Tuple{Kalman, AbstractMatrix}"><code>QuantEcon.compute_loglikelihood</code></a></li><li><a href="QuantEcon.html#QuantEcon.compute_sequence"><code>QuantEcon.compute_sequence</code></a></li><li><a href="QuantEcon.html#QuantEcon.construct_1D_grid-Tuple{Union{Real, AbstractMatrix}, Integer, Integer, Real, Even}"><code>QuantEcon.construct_1D_grid</code></a></li><li><a href="QuantEcon.html#QuantEcon.construct_1D_grid-Tuple{AbstractMatrix, Integer, Integer, Real, Quantile}"><code>QuantEcon.construct_1D_grid</code></a></li><li><a href="QuantEcon.html#QuantEcon.construct_1D_grid-Tuple{Union{Array{T}, T} where T, Integer, Integer, Real, Quadrature}"><code>QuantEcon.construct_1D_grid</code></a></li><li><a href="QuantEcon.html#QuantEcon.construct_prior_guess-Tuple{AbstractVector, Integer, AbstractMatrix, Nothing, Even}"><code>QuantEcon.construct_prior_guess</code></a></li><li><a href="QuantEcon.html#QuantEcon.construct_prior_guess-Tuple{AbstractVector, Integer, AbstractMatrix, AbstractMatrix, Quantile}"><code>QuantEcon.construct_prior_guess</code></a></li><li><a href="QuantEcon.html#QuantEcon.construct_prior_guess-Tuple{AbstractVector, Integer, AbstractMatrix, AbstractVector, Quadrature}"><code>QuantEcon.construct_prior_guess</code></a></li><li><a href="QuantEcon.html#QuantEcon.d_operator-Tuple{RBLQ, Matrix}"><code>QuantEcon.d_operator</code></a></li><li><a href="QuantEcon.html#QuantEcon.discrete_approximation"><code>QuantEcon.discrete_approximation</code></a></li><li><a href="QuantEcon.html#QuantEcon.discrete_var"><code>QuantEcon.discrete_var</code></a></li><li><a href="QuantEcon.html#QuantEcon.divide_bracket-Union{Tuple{T}, Tuple{Function, T, T}, Tuple{Function, T, T, Int64}} where T&lt;:Number"><code>QuantEcon.divide_bracket</code></a></li><li><a href="QuantEcon.html#QuantEcon.do_quad-Tuple{Function, Array, Vector, Vararg{Any}}"><code>QuantEcon.do_quad</code></a></li><li><a href="QuantEcon.html#QuantEcon.entropy_grad!-Tuple{AbstractVector, AbstractVector, AbstractMatrix, AbstractVector, AbstractVector}"><code>QuantEcon.entropy_grad!</code></a></li><li><a href="QuantEcon.html#QuantEcon.entropy_hess!-Tuple{AbstractMatrix, AbstractVector, AbstractMatrix, AbstractVector, AbstractVector}"><code>QuantEcon.entropy_hess!</code></a></li><li><a href="QuantEcon.html#QuantEcon.entropy_obj-Tuple{AbstractVector, AbstractMatrix, AbstractVector, AbstractVector}"><code>QuantEcon.entropy_obj</code></a></li><li><a href="QuantEcon.html#QuantEcon.estimate_mc_discrete-Union{Tuple{T}, Tuple{Vector{T}, Vector{T}}} where T"><code>QuantEcon.estimate_mc_discrete</code></a></li><li><a href="QuantEcon.html#QuantEcon.evaluate_F-Tuple{RBLQ, Matrix}"><code>QuantEcon.evaluate_F</code></a></li><li><a href="QuantEcon.html#QuantEcon.evaluate_policy-Union{Tuple{T}, Tuple{DiscreteDP, AbstractVector{T}}} where T&lt;:Integer"><code>QuantEcon.evaluate_policy</code></a></li><li><a href="QuantEcon.html#QuantEcon.evaluate_policy-Tuple{DiscreteDP, QuantEcon.DPSolveResult}"><code>QuantEcon.evaluate_policy</code></a></li><li><a href="QuantEcon.html#QuantEcon.expand_bracket-Union{Tuple{T}, Tuple{Function, T, T}} where T&lt;:Number"><code>QuantEcon.expand_bracket</code></a></li><li><a href="QuantEcon.html#QuantEcon.filtered_to_forecast!-Tuple{Kalman}"><code>QuantEcon.filtered_to_forecast!</code></a></li><li><a href="QuantEcon.html#QuantEcon.fix"><code>QuantEcon.fix</code></a></li><li><a href="QuantEcon.html#QuantEcon.getZ-Tuple{Matrix, Float64, Matrix}"><code>QuantEcon.getZ</code></a></li><li><a href="QuantEcon.html#QuantEcon.getZ-Tuple{Float64, Float64, Union{Matrix, Vector}}"><code>QuantEcon.getZ</code></a></li><li><a href="QuantEcon.html#QuantEcon.getZ-Tuple{Float64, Float64, Float64}"><code>QuantEcon.getZ</code></a></li><li><a href="QuantEcon.html#QuantEcon.go_backward-Tuple{Kalman, Vector, Matrix, Matrix, Vector, Matrix}"><code>QuantEcon.go_backward</code></a></li><li><a href="QuantEcon.html#QuantEcon.golden_method-Tuple{Function, AbstractVector, AbstractVector}"><code>QuantEcon.golden_method</code></a></li><li><a href="QuantEcon.html#QuantEcon.golden_method-Tuple{Function, Real, Real}"><code>QuantEcon.golden_method</code></a></li><li><a href="QuantEcon.html#QuantEcon.gridmake"><code>QuantEcon.gridmake</code></a></li><li><a href="QuantEcon.html#QuantEcon.gridmake!-Tuple{Any, Vararg{Union{AbstractMatrix, AbstractVector}}}"><code>QuantEcon.gridmake!</code></a></li><li><a href="QuantEcon.html#QuantEcon.gth_solve-Union{Tuple{Matrix{T}}, Tuple{T}} where T&lt;:Real"><code>QuantEcon.gth_solve</code></a></li><li><a href="QuantEcon.html#QuantEcon.gth_solve!-Union{Tuple{Matrix{T}}, Tuple{T}} where T&lt;:Real"><code>QuantEcon.gth_solve!</code></a></li><li><a href="QuantEcon.html#QuantEcon.hamilton_filter-Tuple{AbstractVector, Integer, Integer}"><code>QuantEcon.hamilton_filter</code></a></li><li><a href="QuantEcon.html#QuantEcon.hamilton_filter-Tuple{AbstractVector, Integer}"><code>QuantEcon.hamilton_filter</code></a></li><li><a href="QuantEcon.html#QuantEcon.hp_filter-Union{Tuple{T}, Tuple{AbstractVector{T}, Real}} where T&lt;:Real"><code>QuantEcon.hp_filter</code></a></li><li><a href="QuantEcon.html#QuantEcon.impulse_response-Tuple{ARMA}"><code>QuantEcon.impulse_response</code></a></li><li><a href="QuantEcon.html#QuantEcon.interp-Tuple{AbstractVector, AbstractVector}"><code>QuantEcon.interp</code></a></li><li><a href="QuantEcon.html#QuantEcon.is_aperiodic-Tuple{MarkovChain}"><code>QuantEcon.is_aperiodic</code></a></li><li><a href="QuantEcon.html#QuantEcon.is_irreducible-Tuple{MarkovChain}"><code>QuantEcon.is_irreducible</code></a></li><li><a href="QuantEcon.html#QuantEcon.is_stable-Tuple{LSS}"><code>QuantEcon.is_stable</code></a></li><li><a href="QuantEcon.html#QuantEcon.is_stable-Tuple{AbstractMatrix}"><code>QuantEcon.is_stable</code></a></li><li><a href="QuantEcon.html#QuantEcon.k_array_rank-Tuple{Type{&lt;:Integer}, Vector{&lt;:Integer}}"><code>QuantEcon.k_array_rank</code></a></li><li><a href="QuantEcon.html#QuantEcon.lae_est-Union{Tuple{T}, Tuple{LAE, AbstractArray{T}}} where T"><code>QuantEcon.lae_est</code></a></li><li><a href="QuantEcon.html#QuantEcon.lcp_lemke-Union{Tuple{TD}, Tuple{TQ}, Tuple{TM}, Tuple{AbstractMatrix{TM}, AbstractVector{TQ}}} where {TM&lt;:Real, TQ&lt;:Real, TD&lt;:Real}"><code>QuantEcon.lcp_lemke</code></a></li><li><a href="QuantEcon.html#QuantEcon.lcp_lemke!-Union{Tuple{T}, Tuple{Vector{T}, Matrix{T}, Vector{&lt;:Integer}, AbstractMatrix, AbstractVector}} where T&lt;:AbstractFloat"><code>QuantEcon.lcp_lemke!</code></a></li><li><a href="QuantEcon.html#QuantEcon.log_likelihood-Tuple{Kalman, AbstractVector}"><code>QuantEcon.log_likelihood</code></a></li><li><a href="QuantEcon.html#QuantEcon.m_quadratic_sum-Tuple{Matrix, Matrix}"><code>QuantEcon.m_quadratic_sum</code></a></li><li><a href="QuantEcon.html#QuantEcon.min_var_trace-Tuple{AbstractMatrix}"><code>QuantEcon.min_var_trace</code></a></li><li><a href="QuantEcon.html#QuantEcon.moment_sequence-Tuple{LSS}"><code>QuantEcon.moment_sequence</code></a></li><li><a href="QuantEcon.html#QuantEcon.n_states-Tuple{MarkovChain}"><code>QuantEcon.n_states</code></a></li><li><a href="QuantEcon.html#QuantEcon.next_k_array!-Tuple{Vector{&lt;:Integer}}"><code>QuantEcon.next_k_array!</code></a></li><li><a href="QuantEcon.html#QuantEcon.nnash-NTuple{13, Any}"><code>QuantEcon.nnash</code></a></li><li><a href="QuantEcon.html#QuantEcon.num_compositions-Tuple{Any, Any}"><code>QuantEcon.num_compositions</code></a></li><li><a href="QuantEcon.html#QuantEcon.polynomial_moment-Tuple{AbstractVector, Real, Real, Integer}"><code>QuantEcon.polynomial_moment</code></a></li><li><a href="QuantEcon.html#QuantEcon.prior_to_filtered!-Tuple{Kalman, Any}"><code>QuantEcon.prior_to_filtered!</code></a></li><li><a href="QuantEcon.html#QuantEcon.qnwbeta-Tuple{Int64, Real, Real}"><code>QuantEcon.qnwbeta</code></a></li><li><a href="QuantEcon.html#QuantEcon.qnwcheb-Tuple{Int64, Real, Real}"><code>QuantEcon.qnwcheb</code></a></li><li><a href="QuantEcon.html#QuantEcon.qnwdist-Union{Tuple{T}, Tuple{Distributions.Distribution{Distributions.Univariate, Distributions.Continuous}, Int64}, Tuple{Distributions.Distribution{Distributions.Univariate, Distributions.Continuous}, Int64, Real}, Tuple{Distributions.Distribution{Distributions.Univariate, Distributions.Continuous}, Int64, Real, Real}, Tuple{Distributions.Distribution{Distributions.Univariate, Distributions.Continuous}, Int64, Real, Real, Union{Type{T}, T}}} where T"><code>QuantEcon.qnwdist</code></a></li><li><a href="QuantEcon.html#QuantEcon.qnwequi"><code>QuantEcon.qnwequi</code></a></li><li><a href="QuantEcon.html#QuantEcon.qnwgamma"><code>QuantEcon.qnwgamma</code></a></li><li><a href="QuantEcon.html#QuantEcon.qnwlege-Tuple{Int64, Real, Real}"><code>QuantEcon.qnwlege</code></a></li><li><a href="QuantEcon.html#QuantEcon.qnwlogn-Tuple{Any, Any, Any}"><code>QuantEcon.qnwlogn</code></a></li><li><a href="QuantEcon.html#QuantEcon.qnwmonomial1-Tuple{AbstractMatrix}"><code>QuantEcon.qnwmonomial1</code></a></li><li><a href="QuantEcon.html#QuantEcon.qnwmonomial2-Tuple{AbstractMatrix}"><code>QuantEcon.qnwmonomial2</code></a></li><li><a href="QuantEcon.html#QuantEcon.qnwnorm-Tuple{Int64}"><code>QuantEcon.qnwnorm</code></a></li><li><a href="QuantEcon.html#QuantEcon.qnwsimp-Tuple{Int64, Real, Real}"><code>QuantEcon.qnwsimp</code></a></li><li><a href="QuantEcon.html#QuantEcon.qnwtrap-Tuple{Int64, Real, Real}"><code>QuantEcon.qnwtrap</code></a></li><li><a href="QuantEcon.html#QuantEcon.qnwunif-Tuple{Any, Any, Any}"><code>QuantEcon.qnwunif</code></a></li><li><a href="QuantEcon.html#QuantEcon.quadrect"><code>QuantEcon.quadrect</code></a></li><li><a href="QuantEcon.html#QuantEcon.random_discrete_dp"><code>QuantEcon.random_discrete_dp</code></a></li><li><a href="QuantEcon.html#QuantEcon.random_markov_chain"><code>QuantEcon.random_markov_chain</code></a></li><li><a href="QuantEcon.html#QuantEcon.random_probvec-Tuple{Random.AbstractRNG, Integer, Integer}"><code>QuantEcon.random_probvec</code></a></li><li><a href="QuantEcon.html#QuantEcon.random_stochastic_matrix"><code>QuantEcon.random_stochastic_matrix</code></a></li><li><a href="QuantEcon.html#QuantEcon.recurrent_classes-Tuple{MarkovChain}"><code>QuantEcon.recurrent_classes</code></a></li><li><a href="QuantEcon.html#QuantEcon.remove_constants-Tuple{LSS}"><code>QuantEcon.remove_constants</code></a></li><li><a href="QuantEcon.html#QuantEcon.replicate"><code>QuantEcon.replicate</code></a></li><li><a href="QuantEcon.html#QuantEcon.ridder-Union{Tuple{T}, Tuple{Function, T, T}} where T&lt;:AbstractFloat"><code>QuantEcon.ridder</code></a></li><li><a href="QuantEcon.html#QuantEcon.robust_rule-Tuple{RBLQ}"><code>QuantEcon.robust_rule</code></a></li><li><a href="QuantEcon.html#QuantEcon.robust_rule_simple"><code>QuantEcon.robust_rule_simple</code></a></li><li><a href="QuantEcon.html#QuantEcon.rouwenhorst"><code>QuantEcon.rouwenhorst</code></a></li><li><a href="QuantEcon.html#QuantEcon.s_wise_max-Tuple{AbstractMatrix}"><code>QuantEcon.s_wise_max</code></a></li><li><a href="QuantEcon.html#QuantEcon.s_wise_max!-Tuple{AbstractMatrix, AbstractVector}"><code>QuantEcon.s_wise_max!</code></a></li><li><a href="QuantEcon.html#QuantEcon.s_wise_max!-NTuple{5, AbstractVector}"><code>QuantEcon.s_wise_max!</code></a></li><li><a href="QuantEcon.html#QuantEcon.s_wise_max!-NTuple{4, AbstractVector}"><code>QuantEcon.s_wise_max!</code></a></li><li><a href="QuantEcon.html#QuantEcon.s_wise_max!-Tuple{AbstractMatrix, AbstractVector, AbstractVector}"><code>QuantEcon.s_wise_max!</code></a></li><li><a href="QuantEcon.html#QuantEcon.set_state!-Tuple{Kalman, Any, Any}"><code>QuantEcon.set_state!</code></a></li><li><a href="QuantEcon.html#QuantEcon.simplex_grid-Tuple{Any, Any}"><code>QuantEcon.simplex_grid</code></a></li><li><a href="QuantEcon.html#QuantEcon.simplex_index-Tuple{Any, Any, Any}"><code>QuantEcon.simplex_index</code></a></li><li><a href="QuantEcon.html#QuantEcon.simulate-Tuple{MarkovChain, Int64}"><code>QuantEcon.simulate</code></a></li><li><a href="QuantEcon.html#QuantEcon.simulate!-Tuple{Union{AbstractMatrix, AbstractVector}, MarkovChain}"><code>QuantEcon.simulate!</code></a></li><li><a href="QuantEcon.html#QuantEcon.simulate_indices-Tuple{MarkovChain, Int64}"><code>QuantEcon.simulate_indices</code></a></li><li><a href="QuantEcon.html#QuantEcon.simulate_indices!-Union{Tuple{T}, Tuple{AbstractVecOrMat{T}, MarkovChain}} where T&lt;:Integer"><code>QuantEcon.simulate_indices!</code></a></li><li><a href="QuantEcon.html#QuantEcon.simulation-Tuple{ARMA}"><code>QuantEcon.simulation</code></a></li><li><a href="QuantEcon.html#QuantEcon.smooth"><code>QuantEcon.smooth</code></a></li><li><a href="QuantEcon.html#QuantEcon.smooth-Tuple{Array}"><code>QuantEcon.smooth</code></a></li><li><a href="QuantEcon.html#QuantEcon.smooth-Tuple{Kalman, AbstractMatrix}"><code>QuantEcon.smooth</code></a></li><li><a href="QuantEcon.html#QuantEcon.solve-Union{Tuple{DiscreteDP{T, NQ, NR, Tbeta, Tind, TQ} where {NQ, NR, Tbeta&lt;:Real, Tind, TQ&lt;:AbstractArray{T, NQ}}}, Tuple{T}, Tuple{Algo}, Tuple{DiscreteDP{T, NQ, NR, Tbeta, Tind, TQ} where {NQ, NR, Tbeta&lt;:Real, Tind, TQ&lt;:AbstractArray{T, NQ}}, Type{Algo}}} where {Algo&lt;:QuantEcon.DDPAlgorithm, T}"><code>QuantEcon.solve</code></a></li><li><a href="QuantEcon.html#QuantEcon.solve_discrete_lyapunov"><code>QuantEcon.solve_discrete_lyapunov</code></a></li><li><a href="QuantEcon.html#QuantEcon.solve_discrete_riccati"><code>QuantEcon.solve_discrete_riccati</code></a></li><li><a href="QuantEcon.html#QuantEcon.spectral_density-Tuple{ARMA}"><code>QuantEcon.spectral_density</code></a></li><li><a href="QuantEcon.html#QuantEcon.standardize_var-Tuple{AbstractVector, AbstractMatrix, AbstractMatrix, Integer}"><code>QuantEcon.standardize_var</code></a></li><li><a href="QuantEcon.html#QuantEcon.standardize_var-Tuple{Real, Real, Real, Integer}"><code>QuantEcon.standardize_var</code></a></li><li><a href="QuantEcon.html#QuantEcon.stationary_distributions-Tuple{LSS}"><code>QuantEcon.stationary_distributions</code></a></li><li><a href="QuantEcon.html#QuantEcon.stationary_distributions"><code>QuantEcon.stationary_distributions</code></a></li><li><a href="QuantEcon.html#QuantEcon.stationary_values-Tuple{LQ}"><code>QuantEcon.stationary_values</code></a></li><li><a href="QuantEcon.html#QuantEcon.stationary_values-Tuple{Kalman}"><code>QuantEcon.stationary_values</code></a></li><li><a href="QuantEcon.html#QuantEcon.stationary_values!-Tuple{LQ}"><code>QuantEcon.stationary_values!</code></a></li><li><a href="QuantEcon.html#QuantEcon.tauchen-Union{Tuple{T3}, Tuple{T2}, Tuple{T1}, Tuple{Integer, T1, T2}, Tuple{Integer, T1, T2, Any}, Tuple{Integer, T1, T2, Any, T3}} where {T1&lt;:Real, T2&lt;:Real, T3&lt;:Real}"><code>QuantEcon.tauchen</code></a></li><li><a href="QuantEcon.html#QuantEcon.todense-Tuple{Type, SparseArrays.SparseMatrixCSC}"><code>QuantEcon.todense</code></a></li><li><a href="QuantEcon.html#QuantEcon.todense-Tuple{Type, Array}"><code>QuantEcon.todense</code></a></li><li><a href="QuantEcon.html#QuantEcon.update!-Tuple{Kalman, Any}"><code>QuantEcon.update!</code></a></li><li><a href="QuantEcon.html#QuantEcon.update_values!-Tuple{LQ}"><code>QuantEcon.update_values!</code></a></li><li><a href="QuantEcon.html#QuantEcon.var_quadratic_sum-Tuple{Union{Array{T}, T} where T, Union{Array{T}, T} where T, Union{Array{T}, T} where T, Real, Union{Array{T}, T} where T}"><code>QuantEcon.var_quadratic_sum</code></a></li><li><a href="QuantEcon.html#QuantEcon.warn_persistency-Tuple{AbstractMatrix, Quadrature}"><code>QuantEcon.warn_persistency</code></a></li><li><a href="QuantEcon.html#QuantEcon.@def_sim-Tuple{Any, Any, Any}"><code>QuantEcon.@def_sim</code></a></li></ul><h2 id="Exported"><a class="docs-heading-anchor" href="#Exported">Exported</a><a id="Exported-1"></a><a class="docs-heading-anchor-permalink" href="#Exported" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="QuantEcon.ARMA"><a class="docstring-binding" href="#QuantEcon.ARMA"><code>QuantEcon.ARMA</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">ARMA</code></pre><p>Represents a scalar ARMA(p, q) process.</p><p>If <span>$\phi$</span> and <span>$\theta$</span> are scalars, then the model is understood to be</p><p class="math-container">\[    X_t = \phi X_{t-1} + \epsilon_t + \theta \epsilon_{t-1}\]</p><p>where <span>$\epsilon_t$</span> is a white noise process with standard deviation sigma.</p><p>If <span>$\phi$</span> and <span>$\theta$</span> are arrays or sequences, then the interpretation is the ARMA(p, q) model</p><p class="math-container">\[    X_t = \phi_1 X_{t-1} + ... + \phi_p X_{t-p} +
    \epsilon_t + \theta_1 \epsilon_{t-1} + \ldots  +
    \theta_q \epsilon_{t-q}\]</p><p>where</p><ul><li><span>$\phi = (\phi_1, \phi_2, \ldots , \phi_p)$</span></li><li><span>$\theta = (\theta_1, \theta_2, \ldots , \theta_q)$</span></li><li><span>$\sigma$</span> is a scalar, the standard deviation of the white noise</li></ul><p><strong>Fields</strong></p><ul><li><code>phi::Vector</code>: AR parameters <span>$\phi_1, \ldots, \phi_p$</span>.</li><li><code>theta::Vector</code>: MA parameters <span>$\theta_1, \ldots, \theta_q$</span>.</li><li><code>p::Integer</code>: Number of AR coefficients.</li><li><code>q::Integer</code>: Number of MA coefficients.</li><li><code>sigma::Real</code>: Standard deviation of white noise.</li><li><code>ma_poly::Vector</code>: MA polynomial –- filtering representation.</li><li><code>ar_poly::Vector</code>: AR polynomial –- filtering representation.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; phi = 0.5;

julia&gt; theta = [0.0, -0.8];

julia&gt; sigma = 1.0;

julia&gt; lp = ARMA(phi, theta, sigma)
ARMA([0.5], [0.0, -0.8], 1, 2, 1.0, [1.0, 0.0, -0.8], [1.0, -0.5])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantEcon/QuantEcon.jl/blob/b686df7a6cf4c8a71a85fdeaf5add9cf27259e31/src/arma.jl#L18">source</a></section></details></article><article><details class="docstring" open="true"><summary id="QuantEcon.CFEUtility"><a class="docstring-binding" href="#QuantEcon.CFEUtility"><code>QuantEcon.CFEUtility</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">CFEUtility</code></pre><p>Type used to evaluate constant Frisch elasticity (CFE) utility. CFE utility takes the form</p><p class="math-container">\[v(l) = \xi l^{1 + 1/\phi} / (1 + 1/\phi)\]</p><p>Additionally, this code assumes that if l &lt; 1e-10 then</p><p class="math-container">\[v(l) = \xi ((10^{-10})^{1 + 1/\phi} / (1 + 1/\phi) - (10^{-10})^{1/\phi} * (10^{-10} - l))\]</p><p><strong>Fields</strong></p><ul><li><code>ϕ::Float64</code>: Frisch elasticity of labor supply.</li><li><code>ξ::Float64</code>: Scaling parameter for the utility function.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantEcon/QuantEcon.jl/blob/b686df7a6cf4c8a71a85fdeaf5add9cf27259e31/src/modeltools/utility.jl#L84">source</a></section></details></article><article><details class="docstring" open="true"><summary id="QuantEcon.CRRAUtility"><a class="docstring-binding" href="#QuantEcon.CRRAUtility"><code>QuantEcon.CRRAUtility</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">CRRAUtility</code></pre><p>Type used to evaluate CRRA utility. CRRA utility takes the form</p><p class="math-container">\[u(c) = \xi c^{1 - \gamma} / (1 - \gamma)\]</p><p>Additionally, this code assumes that if c &lt; 1e-10 then</p><p class="math-container">\[u(c) = \xi ((10^{-10})^{1 - \gamma} / (1 - \gamma) + (10^{-10})^{-\gamma} * (c - 10^{-10}))\]</p><p><strong>Fields</strong></p><ul><li><code>γ::Float64</code>: Coefficient of relative risk aversion.</li><li><code>ξ::Float64</code>: Scaling parameter for the utility function.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantEcon/QuantEcon.jl/blob/b686df7a6cf4c8a71a85fdeaf5add9cf27259e31/src/modeltools/utility.jl#L40">source</a></section></details></article><article><details class="docstring" open="true"><summary id="QuantEcon.DiscreteDP"><a class="docstring-binding" href="#QuantEcon.DiscreteDP"><code>QuantEcon.DiscreteDP</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">DiscreteDP</code></pre><p>DiscreteDP type for specifying parameters for discrete dynamic programming model.</p><p><strong>Fields</strong></p><ul><li><code>R::Array{T,NR}</code>: Reward array.</li><li><code>Q::Array{T,NQ}</code>: Transition probability array.</li><li><code>beta::Float64</code>: Discount factor.</li><li><code>a_indices::Vector{Tind}</code>: Action indices. Empty unless using SA formulation.</li><li><code>a_indptr::Vector{Tind}</code>: Action index pointers. Empty unless using SA formulation.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantEcon/QuantEcon.jl/blob/b686df7a6cf4c8a71a85fdeaf5add9cf27259e31/src/markov/ddp.jl#L31-L44">source</a></section></details></article><article><details class="docstring" open="true"><summary id="QuantEcon.DiscreteDP-Union{Tuple{Tbeta}, Tuple{NR}, Tuple{NQ}, Tuple{T}, Tuple{Array{T, NR}, AbstractArray{T, NQ}, Tbeta}} where {T, NQ, NR, Tbeta}"><a class="docstring-binding" href="#QuantEcon.DiscreteDP-Union{Tuple{Tbeta}, Tuple{NR}, Tuple{NQ}, Tuple{T}, Tuple{Array{T, NR}, AbstractArray{T, NQ}, Tbeta}} where {T, NQ, NR, Tbeta}"><code>QuantEcon.DiscreteDP</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">DiscreteDP(R, Q, beta)</code></pre><p>DiscreteDP constructor for specifying parameters for discrete dynamic programming model using dense matrix formulation.</p><p><strong>Arguments</strong></p><ul><li><code>R::Array{T,NR}</code>: Reward array.</li><li><code>Q::Array{T,NQ}</code>: Transition probability array.</li><li><code>beta::Float64</code>: Discount factor.</li></ul><p><strong>Returns</strong></p><ul><li><code>ddp::DiscreteDP</code>: Constructor for DiscreteDP object.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantEcon/QuantEcon.jl/blob/b686df7a6cf4c8a71a85fdeaf5add9cf27259e31/src/markov/ddp.jl#L156-L172">source</a></section></details></article><article><details class="docstring" open="true"><summary id="QuantEcon.DiscreteDP-Union{Tuple{Tind}, Tuple{Tbeta}, Tuple{NR}, Tuple{NQ}, Tuple{T}, Tuple{AbstractArray{T, NR}, AbstractArray{T, NQ}, Tbeta, Vector{Tind}, Vector{Tind}}} where {T, NQ, NR, Tbeta, Tind}"><a class="docstring-binding" href="#QuantEcon.DiscreteDP-Union{Tuple{Tind}, Tuple{Tbeta}, Tuple{NR}, Tuple{NQ}, Tuple{T}, Tuple{AbstractArray{T, NR}, AbstractArray{T, NQ}, Tbeta, Vector{Tind}, Vector{Tind}}} where {T, NQ, NR, Tbeta, Tind}"><code>QuantEcon.DiscreteDP</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">DiscreteDP(R, Q, beta, s_indices, a_indices)</code></pre><p>DiscreteDP constructor for specifying parameters for discrete dynamic programming model using state-action pair formulation.</p><p><strong>Arguments</strong></p><ul><li><code>R::Array{T,NR}</code>: Reward array.</li><li><code>Q::Array{T,NQ}</code>: Transition probability array.</li><li><code>beta::Float64</code>: Discount factor.</li><li><code>s_indices::Vector{Tind}</code>: State indices.</li><li><code>a_indices::Vector{Tind}</code>: Action indices.</li></ul><p><strong>Returns</strong></p><ul><li><code>ddp::DiscreteDP</code>: Constructor for DiscreteDP object.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantEcon/QuantEcon.jl/blob/b686df7a6cf4c8a71a85fdeaf5add9cf27259e31/src/markov/ddp.jl#L178-L196">source</a></section></details></article><article><details class="docstring" open="true"><summary id="QuantEcon.DiscreteRV"><a class="docstring-binding" href="#QuantEcon.DiscreteRV"><code>QuantEcon.DiscreteRV</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">DiscreteRV</code></pre><p>Generates an array of draws from a discrete random variable with vector of probabilities given by <code>q</code>.</p><p><strong>Fields</strong></p><ul><li><code>q::TV1</code>: A vector of non-negative probabilities that sum to 1, where <code>TV1&lt;:AbstractVector</code>.</li><li><code>Q::TV2</code>: The cumulative sum of <code>q</code>, where <code>TV2&lt;:AbstractVector</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantEcon/QuantEcon.jl/blob/b686df7a6cf4c8a71a85fdeaf5add9cf27259e31/src/discrete_rv.jl#L22-L33">source</a></section></details></article><article><details class="docstring" open="true"><summary id="QuantEcon.EllipticalUtility"><a class="docstring-binding" href="#QuantEcon.EllipticalUtility"><code>QuantEcon.EllipticalUtility</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">EllipticalUtility</code></pre><p>Type used to evaluate elliptical utility function. Elliptical utility takes the form</p><p class="math-container">\[v(l) = b (1 - l^\mu)^{1 / \mu}\]</p><p><strong>Fields</strong></p><ul><li><code>b::Float64</code>: Scaling parameter for the utility function.</li><li><code>μ::Float64</code>: Curvature parameter for the utility function.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantEcon/QuantEcon.jl/blob/b686df7a6cf4c8a71a85fdeaf5add9cf27259e31/src/modeltools/utility.jl#L127">source</a></section></details></article><article><details class="docstring" open="true"><summary id="QuantEcon.Kalman"><a class="docstring-binding" href="#QuantEcon.Kalman"><code>QuantEcon.Kalman</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">Kalman</code></pre><p>Represents a Kalman filter for a linear Gaussian state space model.</p><p><strong>Fields</strong></p><ul><li><code>A</code>: State transition matrix.</li><li><code>G</code>: Observation matrix.</li><li><code>Q</code>: State noise covariance matrix.</li><li><code>R</code>: Observation noise covariance matrix.</li><li><code>k</code>: Number of observed variables.</li><li><code>n</code>: Number of state variables.</li><li><code>cur_x_hat</code>: Current estimate of state mean.</li><li><code>cur_sigma</code>: Current estimate of state covariance.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantEcon/QuantEcon.jl/blob/b686df7a6cf4c8a71a85fdeaf5add9cf27259e31/src/kalman.jl#L17-L32">source</a></section></details></article><article><details class="docstring" open="true"><summary id="QuantEcon.LAE"><a class="docstring-binding" href="#QuantEcon.LAE"><code>QuantEcon.LAE</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">LAE</code></pre><p>A look ahead estimator associated with a given stochastic kernel <code>p</code> and a vector of observations <code>X</code>.</p><p><strong>Fields</strong></p><ul><li><code>p::Function</code>: The stochastic kernel. Signature is <code>p(x, y)</code> and it should be vectorized in both inputs.</li><li><code>X::Matrix</code>: A vector containing observations. Note that this can be passed as any kind of <code>AbstractArray</code> and will be coerced into an <code>n x 1</code> vector.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantEcon/QuantEcon.jl/blob/b686df7a6cf4c8a71a85fdeaf5add9cf27259e31/src/lae.jl#L22-L35">source</a></section></details></article><article><details class="docstring" open="true"><summary id="QuantEcon.LQ"><a class="docstring-binding" href="#QuantEcon.LQ"><code>QuantEcon.LQ</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">LQ(Q, R, A, B, C, N; bet=1.0, capT=nothing, rf=fill(NaN, size(R)...))</code></pre><p>Main constructor for LQ type.</p><p>Specifies default arguments for all fields not part of the payoff function or transition equation.</p><p><strong>Arguments</strong></p><ul><li><code>Q::ScalarOrArray</code>: <code>k x k</code> payoff coefficient for control variable u. Must be symmetric and nonnegative definite.</li><li><code>R::ScalarOrArray</code>: <code>n x n</code> payoff coefficient matrix for state variable x. Must be symmetric and nonnegative definite.</li><li><code>A::ScalarOrArray</code>: <code>n x n</code> coefficient on state in state transition.</li><li><code>B::ScalarOrArray</code>: <code>n x k</code> coefficient on control in state transition.</li><li><code>C::ScalarOrArray(fill(zero(eltype(R)), size(R, 1)))</code>: <code>n x j</code> coefficient on random shock in state transition.</li><li><code>N::ScalarOrArray(zero(B&#39;A))</code>: <code>k x n</code> cross product in payoff equation.</li><li><code>;bet::Real(1.0)</code>: Discount factor in <code>[0, 1]</code>.</li><li><code>;capT::Union{Int, Nothing}(nothing)</code>: Terminal period in finite horizon problem.</li><li><code>;rf::ScalarOrArray(fill(NaN, size(R)...))</code>: <code>n x n</code> terminal payoff in finite horizon problem. Must be symmetric and nonnegative definite.</li></ul><p><strong>Returns</strong></p><ul><li><code>lq::LQ</code>: Instance of LQ type with initialized fields.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantEcon/QuantEcon.jl/blob/b686df7a6cf4c8a71a85fdeaf5add9cf27259e31/src/lqcontrol.jl#L94-L124">source</a></section></details></article><article><details class="docstring" open="true"><summary id="QuantEcon.LQ"><a class="docstring-binding" href="#QuantEcon.LQ"><code>QuantEcon.LQ</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">LQ</code></pre><p>Linear quadratic optimal control of either infinite or finite horizon.</p><p>The infinite horizon problem can be written</p><p class="math-container">\[\min \mathbb{E} \sum_{t=0}^{\infty} \beta^t r(x_t, u_t)\]</p><p>with</p><p class="math-container">\[r(x_t, u_t) := x_t&#39; R x_t + u_t&#39; Q u_t + 2 u_t&#39; N x_t\]</p><p>The finite horizon form is</p><p class="math-container">\[\min \mathbb{E} \sum_{t=0}^{T-1} \beta^t r(x_t, u_t) + \beta^T x_T&#39; R_f x_T\]</p><p>Both are minimized subject to the law of motion</p><p class="math-container">\[x_{t+1} = A x_t + B u_t + C w_{t+1}\]</p><p>Here <span>$x$</span> is n x 1, <span>$u$</span> is k x 1, <span>$w$</span> is j x 1 and the matrices are conformable for these dimensions. The sequence <span>${w_t}$</span> is assumed to be white noise, with zero mean and <span>$\mathbb{E} w_t w_t&#39; = I$</span>, the j x j identity.</p><p>For this model, the time <span>$t$</span> value (i.e., cost-to-go) function <span>$V_t$</span> takes the form</p><p class="math-container">\[x&#39; P_T x + d_T\]</p><p>and the optimal policy is of the form <span>$u_T = -F_T x_T$</span>. In the infinite horizon case, <span>$V, P, d$</span> and <span>$F$</span> are all stationary.</p><p><strong>Fields</strong></p><ul><li><code>Q::ScalarOrArray</code>: <code>k x k</code> payoff coefficient for control variable u. Must be symmetric and nonnegative definite.</li><li><code>R::ScalarOrArray</code>: <code>n x n</code> payoff coefficient matrix for state variable x. Must be symmetric and nonnegative definite.</li><li><code>A::ScalarOrArray</code>: <code>n x n</code> coefficient on state in state transition.</li><li><code>B::ScalarOrArray</code>: <code>n x k</code> coefficient on control in state transition.</li><li><code>C::ScalarOrArray</code>: <code>n x j</code> coefficient on random shock in state transition.</li><li><code>N::ScalarOrArray</code>: <code>k x n</code> cross product in payoff equation.</li><li><code>bet::Real</code>: Discount factor in <code>[0, 1]</code>.</li><li><code>capT::Union{Int, Nothing}</code>: Terminal period in finite horizon problem.</li><li><code>rf::ScalarOrArray</code>: <code>n x n</code> terminal payoff in finite horizon problem. Must be symmetric and nonnegative definite.</li><li><code>P::ScalarOrArray</code>: <code>n x n</code> matrix in value function representation <span>$V(x) = x&#39;Px + d$</span>.</li><li><code>d::Real</code>: Constant in value function representation.</li><li><code>F::ScalarOrArray</code>: Policy rule that specifies optimal control in each period.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantEcon/QuantEcon.jl/blob/b686df7a6cf4c8a71a85fdeaf5add9cf27259e31/src/lqcontrol.jl#L17">source</a></section></details></article><article><details class="docstring" open="true"><summary id="QuantEcon.LSS"><a class="docstring-binding" href="#QuantEcon.LSS"><code>QuantEcon.LSS</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">LSS</code></pre><p>A type that describes the Gaussian Linear State Space Model of the form:</p><p class="math-container">\[    x_{t+1} = A x_t + C w_{t+1} \\

    y_t = G x_t + H v_t\]</p><p>where <span>${w_t}$</span> and <span>${v_t}$</span> are independent and standard normal with dimensions <code>k</code> and <code>l</code> respectively.  The initial conditions are <span>$\mu_0$</span> and <span>$\Sigma_0$</span> for <span>$x_0 \sim N(\mu_0, \Sigma_0)$</span>. When <span>$\Sigma_0=0$</span>, the draw of <span>$x_0$</span> is exactly <span>$\mu_0$</span>.</p><p><strong>Fields</strong></p><ul><li><code>A::Matrix</code>: Part of the state transition equation.  It should be <code>n x n</code>.</li><li><code>C::Matrix</code>: Part of the state transition equation.  It should be <code>n x m</code>.</li><li><code>G::Matrix</code>: Part of the observation equation.  It should be <code>k x n</code>.</li><li><code>H::Matrix</code>: Part of the observation equation.  It should be <code>k x l</code>.</li><li><code>k::Int</code>: Dimension.</li><li><code>n::Int</code>: Dimension.</li><li><code>m::Int</code>: Dimension.</li><li><code>l::Int</code>: Dimension.</li><li><code>mu_0::Vector</code>: This is the mean of initial draw and is of length <code>n</code>.</li><li><code>Sigma_0::Matrix</code>: This is the variance of the initial draw and is <code>n x n</code> and also should be positive definite and symmetric.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantEcon/QuantEcon.jl/blob/b686df7a6cf4c8a71a85fdeaf5add9cf27259e31/src/lss.jl#L24">source</a></section></details></article><article><details class="docstring" open="true"><summary id="QuantEcon.LinInterp"><a class="docstring-binding" href="#QuantEcon.LinInterp"><code>QuantEcon.LinInterp</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">LinInterp</code></pre><p>Linear interpolation in one dimension.</p><p><strong>Fields</strong></p><ul><li><code>breaks::AbstractVector</code>: A sorted array of grid points on which to interpolate.</li><li><code>vals::AbstractVector</code>: The function values associated with each of the grid points.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; breaks = cumsum(0.1 .* rand(20));

julia&gt; vals = 0.1 .* sin.(breaks);

julia&gt; li = LinInterp(breaks, vals);

julia&gt; li(0.2)  # do interpolation via `call` method on a LinInterp object
0.019866933079506122

julia&gt; li.([0.1, 0.2, 0.3])  # use broadcasting to evaluate at multiple points
3-element Vector{Float64}:
 0.009983341664682815
 0.019866933079506122
 0.02955202066613396</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantEcon/QuantEcon.jl/blob/b686df7a6cf4c8a71a85fdeaf5add9cf27259e31/src/interp.jl#L1-L29">source</a></section></details></article><article><details class="docstring" open="true"><summary id="QuantEcon.LogUtility"><a class="docstring-binding" href="#QuantEcon.LogUtility"><code>QuantEcon.LogUtility</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">LogUtility</code></pre><p>Type used to evaluate log utility. Log utility takes the form</p><p class="math-container">\[u(c) = \xi \log(c)\]</p><p>Additionally, this code assumes that if c &lt; 1e-10 then</p><p class="math-container">\[u(c) = \xi (\log(10^{-10}) + 10^10*(c - 10^{-10}))\]</p><p><strong>Fields</strong></p><ul><li><code>ξ::Float64</code>: Scaling parameter for the utility function.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantEcon/QuantEcon.jl/blob/b686df7a6cf4c8a71a85fdeaf5add9cf27259e31/src/modeltools/utility.jl#L9">source</a></section></details></article><article><details class="docstring" open="true"><summary id="QuantEcon.MPFI"><a class="docstring-binding" href="#QuantEcon.MPFI"><code>QuantEcon.MPFI</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">MPFI</code></pre><p>Modified Policy Iteration solution algorithm.</p><p><strong>References</strong></p><p>https://lectures.quantecon.org/jl/discrete_dp.html</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantEcon/QuantEcon.jl/blob/b686df7a6cf4c8a71a85fdeaf5add9cf27259e31/src/markov/ddp.jl#L244-L253">source</a></section></details></article><article><details class="docstring" open="true"><summary id="QuantEcon.MVNSampler"><a class="docstring-binding" href="#QuantEcon.MVNSampler"><code>QuantEcon.MVNSampler</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">MVNSampler</code></pre><p>A sampler for multivariate normal distributions.</p><p><strong>Fields</strong></p><ul><li><code>mu::Vector</code>: Mean vector of the multivariate normal distribution.</li><li><code>Sigma::Matrix</code>: Covariance matrix of the multivariate normal distribution.</li><li><code>Q::Matrix</code>: Cholesky factor of the covariance matrix used for sampling.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantEcon/QuantEcon.jl/blob/b686df7a6cf4c8a71a85fdeaf5add9cf27259e31/src/sampler.jl#L11-L21">source</a></section></details></article><article><details class="docstring" open="true"><summary id="QuantEcon.MVNSampler-Union{Tuple{TS}, Tuple{TM}, Tuple{Vector{TM}, Matrix{TS}}} where {TM&lt;:Real, TS&lt;:Real}"><a class="docstring-binding" href="#QuantEcon.MVNSampler-Union{Tuple{TS}, Tuple{TM}, Tuple{Vector{TM}, Matrix{TS}}} where {TM&lt;:Real, TS&lt;:Real}"><code>QuantEcon.MVNSampler</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MVNSampler(mu, Sigma)</code></pre><p>Construct a sampler for the multivariate normal distribution with mean vector <code>mu</code> and covariance matrix <code>Sigma</code>.</p><p><strong>Arguments</strong></p><ul><li><code>mu::Vector</code>: Mean vector of the multivariate normal distribution.</li><li><code>Sigma::Matrix</code>: Covariance matrix of the multivariate normal distribution. Must be symmetric and positive semidefinite.</li></ul><p><strong>Returns</strong></p><ul><li><code>MVNSampler</code>: A sampler object that can be used with <code>rand</code> to generate samples.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; using QuantEcon, LinearAlgebra, Random

julia&gt; n = 3;

julia&gt; mu = zeros(n);

julia&gt; r = -0.2;

julia&gt; Sigma = fill(r, (n, n)); Sigma[diagind(Sigma)] = ones(n);

julia&gt; d = MVNSampler(mu, Sigma);

julia&gt; rng = MersenneTwister(12345);

julia&gt; rand(rng, d)
3-element Vector{Float64}:
  0.8087089406385097
 -2.6078862871910893
 -1.2034459855748247

julia&gt; rand(rng, d, 4)
3×4 Matrix{Float64}:
 0.585714  -0.286877    0.835413   0.8792
 0.228359  -0.104968    0.543674  -0.388309
 1.16821   -0.0262369  -1.10658   -1.84924</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantEcon/QuantEcon.jl/blob/b686df7a6cf4c8a71a85fdeaf5add9cf27259e31/src/sampler.jl#L28-L71">source</a></section></details></article><article><details class="docstring" open="true"><summary id="QuantEcon.MarkovChain"><a class="docstring-binding" href="#QuantEcon.MarkovChain"><code>QuantEcon.MarkovChain</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">MarkovChain</code></pre><p>Finite-state discrete-time Markov chain.</p><p>Methods are available that provide useful information such as the stationary distributions, and communication and recurrent classes, and allow simulation of state transitions.</p><p><strong>Fields</strong></p><ul><li><code>p::AbstractMatrix</code>: The transition matrix. Must be square, all elements must be nonnegative, and all rows must sum to unity.</li><li><code>state_values::AbstractVector</code>: Vector containing the values associated with the states.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantEcon/QuantEcon.jl/blob/b686df7a6cf4c8a71a85fdeaf5add9cf27259e31/src/markov/mc_tools.jl#L19-L32">source</a></section></details></article><article><details class="docstring" open="true"><summary id="QuantEcon.MarkovChain-Tuple{DiscreteDP, QuantEcon.DPSolveResult}"><a class="docstring-binding" href="#QuantEcon.MarkovChain-Tuple{DiscreteDP, QuantEcon.DPSolveResult}"><code>QuantEcon.MarkovChain</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">MarkovChain(ddp, ddpr)</code></pre><p>Returns the controlled Markov chain for a given policy <code>sigma</code>.</p><p><strong>Arguments</strong></p><ul><li><code>ddp::DiscreteDP</code>: Object that contains the model parameters.</li><li><code>ddpr::DPSolveResult</code>: Object that contains result variables.</li></ul><p><strong>Returns</strong></p><ul><li><code>mc::MarkovChain</code>: Controlled Markov chain.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantEcon/QuantEcon.jl/blob/b686df7a6cf4c8a71a85fdeaf5add9cf27259e31/src/markov/ddp.jl#L612-L626">source</a></section></details></article><article><details class="docstring" open="true"><summary id="QuantEcon.PFI"><a class="docstring-binding" href="#QuantEcon.PFI"><code>QuantEcon.PFI</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">PFI</code></pre><p>Policy Iteration solution algorithm.</p><p><strong>References</strong></p><p>https://lectures.quantecon.org/jl/discrete_dp.html</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantEcon/QuantEcon.jl/blob/b686df7a6cf4c8a71a85fdeaf5add9cf27259e31/src/markov/ddp.jl#L232-L241">source</a></section></details></article><article><details class="docstring" open="true"><summary id="QuantEcon.RBLQ"><a class="docstring-binding" href="#QuantEcon.RBLQ"><code>QuantEcon.RBLQ</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">RBLQ</code></pre><p>Represents infinite horizon robust LQ control problems of the form</p><p class="math-container">\[    \min_{u_t} \sum_t \beta^t {x_t&#39; R x_t + u_t&#39; Q u_t }\]</p><p>subject to</p><p class="math-container">\[    x_{t+1} = A x_t + B u_t + C w_{t+1}\]</p><p>and with model misspecification parameter <span>$\theta$</span>.</p><p><strong>Fields</strong></p><ul><li><code>Q::Matrix{Float64}</code>: The cost(payoff) matrix for the controls. See above for more. <span>$Q$</span> should be <code>k x k</code> and symmetric and positive definite.</li><li><code>R::Matrix{Float64}</code>: The cost(payoff) matrix for the state. See above for more. <span>$R$</span> should be <code>n x n</code> and symmetric and non-negative definite.</li><li><code>A::Matrix{Float64}</code>: The matrix that corresponds with the state in the state space system. <span>$A$</span> should be <code>n x n</code>.</li><li><code>B::Matrix{Float64}</code>: The matrix that corresponds with the control in the state space system. <span>$B$</span> should be <code>n x k</code>.</li><li><code>C::Matrix{Float64}</code>: The matrix that corresponds with the random process in the state space system. <span>$C$</span> should be <code>n x j</code>.</li><li><code>beta::Real</code>: The discount factor in the robust control problem.</li><li><code>theta::Real</code>: The robustness factor in the robust control problem.</li><li><code>k, n, j::Int</code>: Dimensions of input matrices.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantEcon/QuantEcon.jl/blob/b686df7a6cf4c8a71a85fdeaf5add9cf27259e31/src/robustlq.jl#L15">source</a></section></details></article><article><details class="docstring" open="true"><summary id="QuantEcon.SimplexGrid"><a class="docstring-binding" href="#QuantEcon.SimplexGrid"><code>QuantEcon.SimplexGrid</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">SimplexGrid</code></pre><p>Iterator version of <code>simplex_grid</code>, i.e., iterator that iterates over the integer points in the (m-1)-dimensional simplex <span>$\{x \mid x_1 + \cdots + x_m = n, x_i \geq 0\}$</span>, or equivalently, the m-part compositions of n, in lexicographic order.</p><p><strong>Fields</strong></p><ul><li><code>m::Int</code>: Dimension of each point. Must be a positive integer.</li><li><code>n::Int</code>: Number which the coordinates of each point sum to. Must be a nonnegative integer.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; sg = SimplexGrid(3, 4);

julia&gt; for x in sg
           @show x
       end
x = [0, 0, 4]
x = [0, 1, 3]
x = [0, 2, 2]
x = [0, 3, 1]
x = [0, 4, 0]
x = [1, 0, 3]
x = [1, 1, 2]
x = [1, 2, 1]
x = [1, 3, 0]
x = [2, 0, 2]
x = [2, 1, 1]
x = [2, 2, 0]
x = [3, 0, 1]
x = [3, 1, 0]
x = [4, 0, 0]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantEcon/QuantEcon.jl/blob/b686df7a6cf4c8a71a85fdeaf5add9cf27259e31/src/util.jl#L171-L209">source</a></section></details></article><article><details class="docstring" open="true"><summary id="QuantEcon.VFI"><a class="docstring-binding" href="#QuantEcon.VFI"><code>QuantEcon.VFI</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">VFI</code></pre><p>Value Iteration solution algorithm.</p><p><strong>References</strong></p><p>https://lectures.quantecon.org/jl/discrete_dp.html</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantEcon/QuantEcon.jl/blob/b686df7a6cf4c8a71a85fdeaf5add9cf27259e31/src/markov/ddp.jl#L220-L229">source</a></section></details></article><article><details class="docstring" open="true"><summary id="DSP.Periodograms.periodogram"><a class="docstring-binding" href="#DSP.Periodograms.periodogram"><code>DSP.Periodograms.periodogram</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">periodogram(x)
periodogram(x, window, window_len=7)</code></pre><p>Computes the periodogram</p><p class="math-container">\[I(w) = \frac{1}{n} | \sum_{t=0}^{n-1} x_t e^{itw} |^2\]</p><p>at the Fourier frequencies <span>$w_j := 2 \frac{\pi j}{n}, j = 0, \ldots, n - 1$</span>, using the fast Fourier transform. Only the frequencies <span>$w_j$</span> in <span>$[0, \pi]$</span> and corresponding values <span>$I(w_j)$</span> are returned. If a window type is given then smoothing is performed.</p><p><strong>Arguments</strong></p><ul><li><code>x::Vector</code>: A vector containing the data to analyze.</li><li><code>window::AbstractString</code>: A string giving the window type (optional). Possible values are <code>flat</code>, <code>hanning</code>, <code>hamming</code>, <code>bartlett</code>, or <code>blackman</code>.</li><li><code>window_len::Int</code>: An odd integer giving the length of the window (default: 7).</li></ul><p><strong>Returns</strong></p><ul><li><code>w::Vector{Float64}</code>: Fourier frequencies at which the periodogram is evaluated.</li><li><code>I_w::Vector{Float64}</code>: The periodogram at frequencies <code>w</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantEcon/QuantEcon.jl/blob/b686df7a6cf4c8a71a85fdeaf5add9cf27259e31/src/estspec.jl#L109">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Graphs.period-Tuple{MarkovChain}"><a class="docstring-binding" href="#Graphs.period-Tuple{MarkovChain}"><code>Graphs.period</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">period(mc)</code></pre><p>Return the period of the Markov chain <code>mc</code>.</p><p><strong>Arguments</strong></p><ul><li><code>mc::MarkovChain</code>: MarkovChain instance.</li></ul><p><strong>Returns</strong></p><ul><li><code>::Int</code>: Period of <code>mc</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantEcon/QuantEcon.jl/blob/b686df7a6cf4c8a71a85fdeaf5add9cf27259e31/src/markov/mc_tools.jl#L219-L231">source</a></section></details></article><article><details class="docstring" open="true"><summary id="QuantEcon.F_to_K-Tuple{RBLQ, Matrix}"><a class="docstring-binding" href="#QuantEcon.F_to_K-Tuple{RBLQ, Matrix}"><code>QuantEcon.F_to_K</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">F_to_K(rlq, F)</code></pre><p>Compute agent 2&#39;s best cost-minimizing response <span>$K$</span>, given <span>$F$</span>.</p><p><strong>Arguments</strong></p><ul><li><code>rlq::RBLQ</code>: Instance of <code>RBLQ</code> type.</li><li><code>F::Matrix{Float64}</code>: A <code>k x n</code> array representing agent 1&#39;s policy.</li></ul><p><strong>Returns</strong></p><ul><li><code>K::Matrix{Float64}</code>: Agent&#39;s best cost minimizing response corresponding to <span>$F$</span>.</li><li><code>P::Matrix{Float64}</code>: The value function corresponding to <span>$F$</span>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantEcon/QuantEcon.jl/blob/b686df7a6cf4c8a71a85fdeaf5add9cf27259e31/src/robustlq.jl#L249">source</a></section></details></article><article><details class="docstring" open="true"><summary id="QuantEcon.K_to_F-Tuple{RBLQ, Matrix}"><a class="docstring-binding" href="#QuantEcon.K_to_F-Tuple{RBLQ, Matrix}"><code>QuantEcon.K_to_F</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">K_to_F(rlq, K)</code></pre><p>Compute agent 1&#39;s best cost-minimizing response <span>$F$</span>, given <span>$K$</span>.</p><p><strong>Arguments</strong></p><ul><li><code>rlq::RBLQ</code>: Instance of <code>RBLQ</code> type.</li><li><code>K::Matrix{Float64}</code>: A <code>j x n</code> array representing the worst case matrix.</li></ul><p><strong>Returns</strong></p><ul><li><code>F::Matrix{Float64}</code>: Agent&#39;s best cost minimizing response corresponding to <span>$K$</span>.</li><li><code>P::Matrix{Float64}</code>: The value function corresponding to <span>$K$</span>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantEcon/QuantEcon.jl/blob/b686df7a6cf4c8a71a85fdeaf5add9cf27259e31/src/robustlq.jl#L282">source</a></section></details></article><article><details class="docstring" open="true"><summary id="QuantEcon.RQ_sigma-Tuple{DiscreteDP, QuantEcon.DPSolveResult}"><a class="docstring-binding" href="#QuantEcon.RQ_sigma-Tuple{DiscreteDP, QuantEcon.DPSolveResult}"><code>QuantEcon.RQ_sigma</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">RQ_sigma(ddp, ddpr)</code></pre><p>Method of <code>RQ_sigma</code> that extracts sigma from a <code>DPSolveResult</code>.</p><p>See other docstring for details.</p><p><strong>Arguments</strong></p><ul><li><code>ddp::DiscreteDP</code>: Object that contains the model parameters.</li><li><code>ddpr::DPSolveResult</code>: Object that contains result variables.</li></ul><p><strong>Returns</strong></p><ul><li><code>R_sigma::Array{Float64}</code>: Reward vector for <code>sigma</code>, of length <code>n</code>.</li><li><code>Q_sigma::Array{Float64}</code>: Transition probability matrix for <code>sigma</code>, of shape <code>(n, n)</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantEcon/QuantEcon.jl/blob/b686df7a6cf4c8a71a85fdeaf5add9cf27259e31/src/markov/ddp.jl#L630-L648">source</a></section></details></article><article><details class="docstring" open="true"><summary id="QuantEcon.RQ_sigma-Union{Tuple{T}, Tuple{DiscreteDP{T, 3, 2, Tbeta, Tind, TQ} where {T, Tbeta, Tind, TQ}, AbstractVector{T}}} where T&lt;:Integer"><a class="docstring-binding" href="#QuantEcon.RQ_sigma-Union{Tuple{T}, Tuple{DiscreteDP{T, 3, 2, Tbeta, Tind, TQ} where {T, Tbeta, Tind, TQ}, AbstractVector{T}}} where T&lt;:Integer"><code>QuantEcon.RQ_sigma</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">RQ_sigma(ddp, sigma)</code></pre><p>Given a policy <code>sigma</code>, return the reward vector <code>R_sigma</code> and the transition probability matrix <code>Q_sigma</code>.</p><p><strong>Arguments</strong></p><ul><li><code>ddp::DiscreteDP</code>: Object that contains the model parameters.</li><li><code>sigma::AbstractVector{Int}</code>: Policy rule vector.</li></ul><p><strong>Returns</strong></p><ul><li><code>R_sigma::Array{Float64}</code>: Reward vector for <code>sigma</code>, of length <code>n</code>.</li><li><code>Q_sigma::Array{Float64}</code>: Transition probability matrix for <code>sigma</code>, of shape <code>(n, n)</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantEcon/QuantEcon.jl/blob/b686df7a6cf4c8a71a85fdeaf5add9cf27259e31/src/markov/ddp.jl#L651-L668">source</a></section></details></article><article><details class="docstring" open="true"><summary id="QuantEcon.ar_periodogram"><a class="docstring-binding" href="#QuantEcon.ar_periodogram"><code>QuantEcon.ar_periodogram</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">ar_periodogram(x, window=&quot;hanning&quot;, window_len=7)</code></pre><p>Compute periodogram from data <code>x</code>, using prewhitening, smoothing and recoloring. The data is fitted to an AR(1) model for prewhitening, and the residuals are used to compute a first-pass periodogram with smoothing. The fitted coefficients are then used for recoloring.</p><p><strong>Arguments</strong></p><ul><li><code>x::Array</code>: An array containing the data to analyze.</li><li><code>window::AbstractString</code>: A string giving the window type (default: &quot;hanning&quot;). Possible values are <code>flat</code>, <code>hanning</code>, <code>hamming</code>, <code>bartlett</code>, or <code>blackman</code>.</li><li><code>window_len::Int</code>: An odd integer giving the length of the window (default: 7).</li></ul><p><strong>Returns</strong></p><ul><li><code>w::Vector{Float64}</code>: Fourier frequencies at which the periodogram is evaluated.</li><li><code>I_w::Vector{Float64}</code>: The periodogram at frequencies <code>w</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantEcon/QuantEcon.jl/blob/b686df7a6cf4c8a71a85fdeaf5add9cf27259e31/src/estspec.jl#L138-L158">source</a></section></details></article><article><details class="docstring" open="true"><summary id="QuantEcon.autocovariance-Tuple{ARMA}"><a class="docstring-binding" href="#QuantEcon.autocovariance-Tuple{ARMA}"><code>QuantEcon.autocovariance</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">autocovariance(arma; num_autocov=16)</code></pre><p>Compute the autocovariance function from the ARMA parameters over the integers range(<code>num_autocov</code>) using the spectral density and the inverse Fourier transform.</p><p><strong>Arguments</strong></p><ul><li><code>arma::ARMA</code>: Instance of <code>ARMA</code> type.</li><li><code>;num_autocov::Integer(16)</code>: The number of autocovariances to calculate.</li></ul><p><strong>Returns</strong></p><ul><li><code>::Vector{Float64}</code>: The autocovariance function.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantEcon/QuantEcon.jl/blob/b686df7a6cf4c8a71a85fdeaf5add9cf27259e31/src/arma.jl#L137-L152">source</a></section></details></article><article><details class="docstring" open="true"><summary id="QuantEcon.b_operator-Tuple{RBLQ, Matrix}"><a class="docstring-binding" href="#QuantEcon.b_operator-Tuple{RBLQ, Matrix}"><code>QuantEcon.b_operator</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">b_operator(rlq, P)</code></pre><p>The <span>$B$</span> operator, mapping <span>$P$</span> into</p><p class="math-container">\[    B(P) := R - \beta^2 A&#39;PB(Q + \beta B&#39;PB)^{-1}B&#39;PA + \beta A&#39;PA\]</p><p>and also returning</p><p class="math-container">\[    F := (Q + \beta B&#39;PB)^{-1} \beta B&#39;PA\]</p><p><strong>Arguments</strong></p><ul><li><code>rlq::RBLQ</code>: Instance of <code>RBLQ</code> type.</li><li><code>P::Matrix{Float64}</code>: Size is <code>n x n</code>.</li></ul><p><strong>Returns</strong></p><ul><li><code>F::Matrix{Float64}</code>: The <span>$F$</span> matrix as defined above.</li><li><code>new_p::Matrix{Float64}</code>: The matrix <span>$P$</span> after applying the <span>$B$</span> operator.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantEcon/QuantEcon.jl/blob/b686df7a6cf4c8a71a85fdeaf5add9cf27259e31/src/robustlq.jl#L104">source</a></section></details></article><article><details class="docstring" open="true"><summary id="QuantEcon.backward_induction-Union{Tuple{T}, Tuple{DiscreteDP{T, NQ, NR, Tbeta, Tind, TQ} where {NQ, NR, Tbeta&lt;:Real, Tind, TQ&lt;:AbstractArray{T, NQ}}, Integer}, Tuple{DiscreteDP{T, NQ, NR, Tbeta, Tind, TQ} where {NQ, NR, Tbeta&lt;:Real, Tind, TQ&lt;:AbstractArray{T, NQ}}, Integer, AbstractVector{&lt;:Real}}} where T"><a class="docstring-binding" href="#QuantEcon.backward_induction-Union{Tuple{T}, Tuple{DiscreteDP{T, NQ, NR, Tbeta, Tind, TQ} where {NQ, NR, Tbeta&lt;:Real, Tind, TQ&lt;:AbstractArray{T, NQ}}, Integer}, Tuple{DiscreteDP{T, NQ, NR, Tbeta, Tind, TQ} where {NQ, NR, Tbeta&lt;:Real, Tind, TQ&lt;:AbstractArray{T, NQ}}, Integer, AbstractVector{&lt;:Real}}} where T"><code>QuantEcon.backward_induction</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">backward_induction(ddp, J[, v_term=zeros(num_states(ddp))])</code></pre><p>Solve by backward induction a <span>$J$</span>-period finite horizon discrete dynamic  program with stationary reward <span>$r$</span> and transition probability functions <span>$q$</span> and discount factor <span>$\beta \in [0, 1]$</span>.</p><p>The optimal value functions <span>$v^{\ast}_1, \ldots, v^{\ast}_{J+1}$</span> and  policy functions <span>$\sigma^{\ast}_1, \ldots, \sigma^{\ast}_J$</span> are obtained by <span>$v^{\ast}_{J+1} = v_{J+1}$</span>, and</p><p class="math-container">\[v^{\ast}_j(s) = \max_{a \in A(s)} r(s, a) +
\beta \sum_{s&#39; \in S} q(s&#39;|s, a) v^{\ast}_{j+1}(s&#39;)
\quad (s \in S)\]</p><p>and</p><p class="math-container">\[\sigma^{\ast}_j(s) \in \operatorname*{arg\,max}_{a \in A(s)}
            r(s, a) + \beta \sum_{s&#39; \in S} q(s&#39;|s, a) v^*_{j+1}(s&#39;)
            \quad (s \in S)\]</p><p>for <span>$j= J, \ldots, 1$</span>, where the terminal value function <span>$v_{J+1}$</span> is  exogenously given by <code>v_term</code>.</p><p><strong>Arguments</strong></p><ul><li><code>ddp::DiscreteDP{T}</code>: Object that contains the model parameters.</li><li><code>J::Integer</code>: Number of decision periods.</li><li><code>v_term::AbstractVector{&lt;:Real}=zeros(num_states(ddp))</code>: Terminal value  function of length equal to n (the number of states).</li></ul><p><strong>Returns</strong></p><ul><li><code>vs::Matrix{S}</code>: Array of shape (n, J+1) where <code>vs[:,j]</code>  contains the  optimal value function at period j = 1, ..., J+1.</li><li><code>sigmas::Matrix{Int}</code>: Array of shape (n, J) where <code>sigmas[:,j]</code> contains the optimal policy function at period j = 1, ..., J.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantEcon/QuantEcon.jl/blob/b686df7a6cf4c8a71a85fdeaf5add9cf27259e31/src/markov/ddp.jl#L553-L593">source</a></section></details></article><article><details class="docstring" open="true"><summary id="QuantEcon.bellman_operator!-Tuple{DiscreteDP, AbstractVector, AbstractVector, AbstractVector}"><a class="docstring-binding" href="#QuantEcon.bellman_operator!-Tuple{DiscreteDP, AbstractVector, AbstractVector, AbstractVector}"><code>QuantEcon.bellman_operator!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">bellman_operator!(ddp, v, Tv, sigma)</code></pre><p>The Bellman operator, which computes and returns the updated value function <span>$Tv$</span> for a value function <span>$v$</span>.</p><p><strong>Arguments</strong></p><ul><li><code>ddp::DiscreteDP</code>: Object that contains the model parameters.</li><li><code>v::AbstractVector{T&lt;:AbstractFloat}</code>: The current guess of the value function.</li><li><code>Tv::AbstractVector{T&lt;:AbstractFloat}</code>: A buffer array to hold the updated value function. Initial value not used and will be overwritten.</li><li><code>sigma::AbstractVector</code>: A buffer array to hold the policy function. Initial values not used and will be overwritten.</li></ul><p><strong>Returns</strong></p><ul><li><code>Tv::typeof(Tv)</code>: Updated value function vector.</li><li><code>sigma::typeof(sigma)</code>: Updated policy function vector.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantEcon/QuantEcon.jl/blob/b686df7a6cf4c8a71a85fdeaf5add9cf27259e31/src/markov/ddp.jl#L304">source</a></section></details></article><article><details class="docstring" open="true"><summary id="QuantEcon.bellman_operator!-Tuple{DiscreteDP, QuantEcon.DPSolveResult}"><a class="docstring-binding" href="#QuantEcon.bellman_operator!-Tuple{DiscreteDP, QuantEcon.DPSolveResult}"><code>QuantEcon.bellman_operator!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">bellman_operator!(ddp, ddpr)</code></pre><p>Apply the Bellman operator using <code>v=ddpr.v</code>, <code>Tv=ddpr.Tv</code>, and <code>sigma=ddpr.sigma</code>.</p><p><strong>Arguments</strong></p><ul><li><code>ddp::DiscreteDP</code>: Object that contains the model parameters.</li><li><code>ddpr::DPSolveResult</code>: Object that contains result variables.</li></ul><p><strong>Returns</strong></p><ul><li><code>Tv::typeof(ddpr.Tv)</code>: Updated value function vector.</li><li><code>sigma::typeof(ddpr.sigma)</code>: Updated policy function vector.</li></ul><p><strong>Notes</strong></p><p>Updates <code>ddpr.Tv</code> and <code>ddpr.sigma</code> inplace.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantEcon/QuantEcon.jl/blob/b686df7a6cf4c8a71a85fdeaf5add9cf27259e31/src/markov/ddp.jl#L334">source</a></section></details></article><article><details class="docstring" open="true"><summary id="QuantEcon.bellman_operator!-Union{Tuple{T}, Tuple{DiscreteDP, AbstractVector{T}, AbstractVector}} where T&lt;:AbstractFloat"><a class="docstring-binding" href="#QuantEcon.bellman_operator!-Union{Tuple{T}, Tuple{DiscreteDP, AbstractVector{T}, AbstractVector}} where T&lt;:AbstractFloat"><code>QuantEcon.bellman_operator!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">bellman_operator!(ddp, v, sigma)</code></pre><p>The Bellman operator, which computes and returns the updated value function <span>$Tv$</span> for a given value function <span>$v$</span>.</p><p>This function will fill the input <code>v</code> with <code>Tv</code> and the input <code>sigma</code> with the corresponding policy rule.</p><p><strong>Arguments</strong></p><ul><li><code>ddp::DiscreteDP</code>: The ddp model.</li><li><code>v::AbstractVector{T&lt;:AbstractFloat}</code>: The current guess of the value function. This array will be overwritten.</li><li><code>sigma::AbstractVector</code>: A buffer array to hold the policy function. Initial values not used and will be overwritten.</li></ul><p><strong>Returns</strong></p><ul><li><code>Tv::Vector</code>: Updated value function vector.</li><li><code>sigma::typeof(sigma)</code>: Policy rule.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantEcon/QuantEcon.jl/blob/b686df7a6cf4c8a71a85fdeaf5add9cf27259e31/src/markov/ddp.jl#L357-L379">source</a></section></details></article><article><details class="docstring" open="true"><summary id="QuantEcon.bellman_operator-Tuple{DiscreteDP, AbstractVector}"><a class="docstring-binding" href="#QuantEcon.bellman_operator-Tuple{DiscreteDP, AbstractVector}"><code>QuantEcon.bellman_operator</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">bellman_operator(ddp, v)</code></pre><p>The Bellman operator, which computes and returns the updated value function <span>$Tv$</span> for a given value function <span>$v$</span>.</p><p><strong>Arguments</strong></p><ul><li><code>ddp::DiscreteDP</code>: The ddp model.</li><li><code>v::AbstractVector</code>: The current guess of the value function.</li></ul><p><strong>Returns</strong></p><ul><li><code>Tv::Vector</code>: Updated value function vector.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantEcon/QuantEcon.jl/blob/b686df7a6cf4c8a71a85fdeaf5add9cf27259e31/src/markov/ddp.jl#L391">source</a></section></details></article><article><details class="docstring" open="true"><summary id="QuantEcon.bisect-Union{Tuple{T}, Tuple{Function, T, T}} where T&lt;:AbstractFloat"><a class="docstring-binding" href="#QuantEcon.bisect-Union{Tuple{T}, Tuple{Function, T, T}} where T&lt;:AbstractFloat"><code>QuantEcon.bisect</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">bisect(f, x1, x2; maxiter=500, xtol=1e-12, rtol=2*eps())</code></pre><p>Find the root of the <code>f</code> on the bracketing interval <code>[x1, x2]</code> via bisection.</p><p><strong>Arguments</strong></p><ul><li><code>f::Function</code>: The function you want to bracket.</li><li><code>x1::T</code>: Lower border for search interval.</li><li><code>x2::T</code>: Upper border for search interval.</li><li><code>;maxiter::Int(500)</code>: Maximum number of bisection iterations.</li><li><code>;xtol::Float64(1e-12)</code>: The routine converges when a root is known to lie within <code>xtol</code> of the value return. Should be &gt;= 0. The routine modifies this to take into account the relative precision of doubles.</li><li><code>;rtol::Float64(2*eps())</code>: The routine converges when a root is known to lie within <code>rtol</code> times the value returned of the value returned. Should be ≥ 0.</li></ul><p><strong>Returns</strong></p><ul><li><code>x::T</code>: The found root.</li></ul><p><strong>Exceptions</strong></p><ul><li>Throws an <code>ArgumentError</code> if <code>[x1, x2]</code> does not form a bracketing interval.</li><li>Throws a <code>ConvergenceError</code> if the maximum number of iterations is exceeded.</li></ul><p><strong>References</strong></p><p>Matches <code>bisect</code> function from scipy/scipy/optimize/Zeros/bisect.c.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantEcon/QuantEcon.jl/blob/b686df7a6cf4c8a71a85fdeaf5add9cf27259e31/src/zeros.jl#L175-L185">source</a></section></details></article><article><details class="docstring" open="true"><summary id="QuantEcon.brent-Union{Tuple{T}, Tuple{Function, T, T}} where T&lt;:AbstractFloat"><a class="docstring-binding" href="#QuantEcon.brent-Union{Tuple{T}, Tuple{Function, T, T}} where T&lt;:AbstractFloat"><code>QuantEcon.brent</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">brent(f, xa, xb; maxiter=500, xtol=1e-12, rtol=2*eps())</code></pre><p>Find the root of the <code>f</code> on the bracketing interval <code>[xa, xb]</code> via Brent&#39;s algorithm.</p><p><strong>Arguments</strong></p><ul><li><code>f::Function</code>: The function you want to bracket.</li><li><code>x1::T</code>: Lower border for search interval.</li><li><code>x2::T</code>: Upper border for search interval.</li><li><code>;maxiter::Int(500)</code>: Maximum number of bisection iterations.</li><li><code>;xtol::Float64(1e-12)</code>: The routine converges when a root is known to lie within <code>xtol</code> of the value return. Should be &gt;= 0. The routine modifies this to take into account the relative precision of doubles.</li><li><code>;rtol::Float64(2*eps())</code>: The routine converges when a root is known to lie within <code>rtol</code> times the value returned of the value returned. Should be ≥ 0.</li></ul><p><strong>Returns</strong></p><ul><li><code>x::T</code>: The found root.</li></ul><p><strong>Exceptions</strong></p><ul><li>Throws an <code>ArgumentError</code> if <code>[x1, x2]</code> does not form a bracketing interval.</li><li>Throws a <code>ConvergenceError</code> if the maximum number of iterations is exceeded.</li></ul><p><strong>References</strong></p><p>Matches <code>brentq</code> function from scipy/scipy/optimize/Zeros/bisectq.c.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantEcon/QuantEcon.jl/blob/b686df7a6cf4c8a71a85fdeaf5add9cf27259e31/src/zeros.jl#L330-L340">source</a></section></details></article><article><details class="docstring" open="true"><summary id="QuantEcon.brenth-Union{Tuple{T}, Tuple{Function, T, T}} where T&lt;:AbstractFloat"><a class="docstring-binding" href="#QuantEcon.brenth-Union{Tuple{T}, Tuple{Function, T, T}} where T&lt;:AbstractFloat"><code>QuantEcon.brenth</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">brenth(f, xa, xb; maxiter=500, xtol=1e-12, rtol=2*eps())</code></pre><p>Find a root of the <code>f</code> on the bracketing interval <code>[xa, xb]</code> via modified Brent&#39;s algorithm.</p><p>This routine uses a hyperbolic extrapolation formula instead of the standard inverse quadratic formula. Otherwise it is the original Brent&#39;s algorithm, as implemented in the <code>brent</code> function.</p><p><strong>Arguments</strong></p><ul><li><code>f::Function</code>: The function you want to bracket.</li><li><code>x1::T</code>: Lower border for search interval.</li><li><code>x2::T</code>: Upper border for search interval.</li><li><code>;maxiter::Int(500)</code>: Maximum number of bisection iterations.</li><li><code>;xtol::Float64(1e-12)</code>: The routine converges when a root is known to lie within <code>xtol</code> of the value return. Should be &gt;= 0. The routine modifies this to take into account the relative precision of doubles.</li><li><code>;rtol::Float64(2*eps())</code>: The routine converges when a root is known to lie within <code>rtol</code> times the value returned of the value returned. Should be ≥ 0.</li></ul><p><strong>Returns</strong></p><ul><li><code>x::T</code>: The found root.</li></ul><p><strong>Exceptions</strong></p><ul><li>Throws an <code>ArgumentError</code> if <code>[x1, x2]</code> does not form a bracketing interval.</li><li>Throws a <code>ConvergenceError</code> if the maximum number of iterations is exceeded.</li></ul><p><strong>References</strong></p><p>Matches <code>brenth</code> function from scipy/scipy/optimize/Zeros/bisecth.c.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantEcon/QuantEcon.jl/blob/b686df7a6cf4c8a71a85fdeaf5add9cf27259e31/src/zeros.jl#L346-L360">source</a></section></details></article><article><details class="docstring" open="true"><summary id="QuantEcon.ckron"><a class="docstring-binding" href="#QuantEcon.ckron"><code>QuantEcon.ckron</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">ckron(arrays::AbstractArray...)</code></pre><p>Repeatedly apply kronecker products to the arrays. Equivalent to <code>reduce(kron, arrays)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantEcon/QuantEcon.jl/blob/b686df7a6cf4c8a71a85fdeaf5add9cf27259e31/src/util.jl#L26-L31">source</a></section></details></article><article><details class="docstring" open="true"><summary id="QuantEcon.communication_classes-Tuple{MarkovChain}"><a class="docstring-binding" href="#QuantEcon.communication_classes-Tuple{MarkovChain}"><code>QuantEcon.communication_classes</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">communication_classes(mc)</code></pre><p>Find the communication classes of the Markov chain <code>mc</code>.</p><p><strong>Arguments</strong></p><ul><li><code>mc::MarkovChain</code>: MarkovChain instance.</li></ul><p><strong>Returns</strong></p><ul><li><code>::Vector{Vector{Int}}</code>: Vector of vectors that describe the communication classes of <code>mc</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantEcon/QuantEcon.jl/blob/b686df7a6cf4c8a71a85fdeaf5add9cf27259e31/src/markov/mc_tools.jl#L173-L186">source</a></section></details></article><article><details class="docstring" open="true"><summary id="QuantEcon.compute_deterministic_entropy-Tuple{RBLQ, Any, Any, Any}"><a class="docstring-binding" href="#QuantEcon.compute_deterministic_entropy-Tuple{RBLQ, Any, Any, Any}"><code>QuantEcon.compute_deterministic_entropy</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">compute_deterministic_entropy(rlq, F, K, x0)</code></pre><p>Given <span>$K$</span> and <span>$F$</span>, compute the value of deterministic entropy, which is <span>$\sum_t \beta^t x_t&#39; K&#39;K x_t$</span> with <span>$x_{t+1} = (A - BF + CK) x_t$</span>.</p><p><strong>Arguments</strong></p><ul><li><code>rlq::RBLQ</code>: Instance of <code>RBLQ</code> type.</li><li><code>F::Matrix{Float64}</code>: The policy function, a <code>k x n</code> array.</li><li><code>K::Matrix{Float64}</code>: The worst case matrix, a <code>j x n</code> array.</li><li><code>x0::Vector{Float64}</code>: The initial condition for state.</li></ul><p><strong>Returns</strong></p><ul><li><code>e::Float64</code>: The deterministic entropy.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantEcon/QuantEcon.jl/blob/b686df7a6cf4c8a71a85fdeaf5add9cf27259e31/src/robustlq.jl#L310">source</a></section></details></article><article><details class="docstring" open="true"><summary id="QuantEcon.compute_fixed_point-Union{Tuple{TV}, Tuple{Function, TV}} where TV"><a class="docstring-binding" href="#QuantEcon.compute_fixed_point-Union{Tuple{TV}, Tuple{Function, TV}} where TV"><code>QuantEcon.compute_fixed_point</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">compute_fixed_point(T, v; err_tol=1e-4, max_iter=100, verbose=2, print_skip=10)</code></pre><p>Repeatedly apply a function to search for a fixed point.</p><p>Approximates <span>$T^∞ v$</span>, where <span>$T$</span> is an operator (function) and <span>$v$</span> is an initial guess for the fixed point. Will terminate either when <code>|T^{k+1}(v) - T^k v| &lt; err_tol</code> or <code>max_iter</code> iterations has been exceeded.</p><p>Provided that <span>$T$</span> is a contraction mapping or similar, the return value will be an approximation to the fixed point of <span>$T$</span>.</p><p><strong>Arguments</strong></p><ul><li><code>T::Function</code>: A function representing the operator <span>$T$</span>.</li><li><code>v::TV</code>: The initial condition. An object of type <code>TV</code>.</li><li><code>err_tol::Real(1e-4)</code>: Stopping tolerance for iterations.</li><li><code>max_iter::Integer(100)</code>: Maximum number of iterations.</li><li><code>verbose::Integer(2)</code>: Level of feedback (0 for no output, 1 for warnings only, 2 for warning and convergence messages during iteration).</li><li><code>print_skip::Integer(10)</code>: If <code>verbose == 2</code>, how many iterations to apply between print messages.</li></ul><p><strong>Returns</strong></p><ul><li><code>::TV</code>: The fixed point of the operator <code>T</code>. Has type <code>TV</code>.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; T(x, μ) = 4.0 * μ * x * (1.0 - x);

julia&gt; x_star = compute_fixed_point(x-&gt;T(x, 0.3), 0.4);  # (4μ - 1)/(4μ)
Compute iterate 10 with error 0.0023564830444494367
Compute iterate 20 with error 0.0002222571812867391
Converged in 24 steps

julia&gt; x_star
0.16702641162980347</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantEcon/QuantEcon.jl/blob/b686df7a6cf4c8a71a85fdeaf5add9cf27259e31/src/compute_fp.jl#L16">source</a></section></details></article><article><details class="docstring" open="true"><summary id="QuantEcon.compute_greedy!-Tuple{DiscreteDP, QuantEcon.DPSolveResult}"><a class="docstring-binding" href="#QuantEcon.compute_greedy!-Tuple{DiscreteDP, QuantEcon.DPSolveResult}"><code>QuantEcon.compute_greedy!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">compute_greedy!(ddp, ddpr)</code></pre><p>Compute the <span>$v$</span>-greedy policy.</p><p><strong>Arguments</strong></p><ul><li><code>ddp::DiscreteDP</code>: Object that contains the model parameters.</li><li><code>ddpr::DPSolveResult</code>: Object that contains result variables.</li></ul><p><strong>Returns</strong></p><ul><li><code>sigma::Vector{Int}</code>: Array containing <code>v</code>-greedy policy rule.</li></ul><p><strong>Notes</strong></p><p>Modifies ddpr.sigma and ddpr.Tv in place.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantEcon/QuantEcon.jl/blob/b686df7a6cf4c8a71a85fdeaf5add9cf27259e31/src/markov/ddp.jl#L414">source</a></section></details></article><article><details class="docstring" open="true"><summary id="QuantEcon.compute_greedy-Union{Tuple{TV}, Tuple{DiscreteDP, AbstractVector{TV}}} where TV&lt;:Real"><a class="docstring-binding" href="#QuantEcon.compute_greedy-Union{Tuple{TV}, Tuple{DiscreteDP, AbstractVector{TV}}} where TV&lt;:Real"><code>QuantEcon.compute_greedy</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">compute_greedy(ddp, v)</code></pre><p>Compute the <span>$v$</span>-greedy policy.</p><p><strong>Arguments</strong></p><ul><li><code>ddp::DiscreteDP</code>: Object that contains the model parameters.</li><li><code>v::AbstractVector</code>: Value function vector of length <code>n</code>.</li></ul><p><strong>Returns</strong></p><ul><li><code>sigma::Vector{Int}</code>: v-greedy policy vector, of length <code>n</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantEcon/QuantEcon.jl/blob/b686df7a6cf4c8a71a85fdeaf5add9cf27259e31/src/markov/ddp.jl#L436">source</a></section></details></article><article><details class="docstring" open="true"><summary id="QuantEcon.compute_loglikelihood-Tuple{Kalman, AbstractMatrix}"><a class="docstring-binding" href="#QuantEcon.compute_loglikelihood-Tuple{Kalman, AbstractMatrix}"><code>QuantEcon.compute_loglikelihood</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">compute_loglikelihood(kn, y)</code></pre><p>Computes log-likelihood of entire observations.</p><p><strong>Arguments</strong></p><ul><li><code>kn::Kalman</code>: <code>Kalman</code> instance specifying the model. Initial value must be the prior for t=1 period observation, i.e. <span>$x_{1|0}$</span>.</li><li><code>y::AbstractMatrix</code>: <code>n x T</code> matrix of observed data. <code>n</code> is the number of observed variables in one period. Each column is a vector of observations at each period.</li></ul><p><strong>Returns</strong></p><ul><li><code>logL::Real</code>: Log-likelihood of all observations.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantEcon/QuantEcon.jl/blob/b686df7a6cf4c8a71a85fdeaf5add9cf27259e31/src/kalman.jl#L215-L231">source</a></section></details></article><article><details class="docstring" open="true"><summary id="QuantEcon.compute_sequence"><a class="docstring-binding" href="#QuantEcon.compute_sequence"><code>QuantEcon.compute_sequence</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">compute_sequence(lq, x0, ts_length=100)</code></pre><p>Compute and return the optimal state and control sequence, assuming innovation <span>$N(0,1)$</span>.</p><p><strong>Arguments</strong></p><ul><li><code>lq::LQ</code>: Instance of <code>LQ</code> type.</li><li><code>x0::ScalarOrArray</code>: Initial state.</li><li><code>ts_length::Integer(100)</code>: Maximum number of periods for which to return process. If <code>lq</code> instance is finite horizon type, the sequences are returned only for <code>min(ts_length, lq.capT)</code>.</li></ul><p><strong>Returns</strong></p><ul><li><code>x_path::Matrix{Float64}</code>: An <code>n x T+1</code> matrix, where the t-th column represents <span>$x_t$</span>.</li><li><code>u_path::Matrix{Float64}</code>: A <code>k x T</code> matrix, where the t-th column represents <span>$u_t$</span>.</li><li><code>w_path::Matrix{Float64}</code>: A <code>n x T+1</code> matrix, where the t-th column represents <code>lq.C*N(0,1)</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantEcon/QuantEcon.jl/blob/b686df7a6cf4c8a71a85fdeaf5add9cf27259e31/src/lqcontrol.jl#L310">source</a></section></details></article><article><details class="docstring" open="true"><summary id="QuantEcon.d_operator-Tuple{RBLQ, Matrix}"><a class="docstring-binding" href="#QuantEcon.d_operator-Tuple{RBLQ, Matrix}"><code>QuantEcon.d_operator</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">d_operator(rlq, P)</code></pre><p>The <span>$D$</span> operator, mapping <span>$P$</span> into</p><p class="math-container">\[    D(P) := P + PC(\theta I - C&#39;PC)^{-1} C&#39;P\]</p><p><strong>Arguments</strong></p><ul><li><code>rlq::RBLQ</code>: Instance of <code>RBLQ</code> type.</li><li><code>P::Matrix{Float64}</code>: Size is <code>n x n</code>.</li></ul><p><strong>Returns</strong></p><ul><li><code>dP::Matrix{Float64}</code>: The matrix <span>$P$</span> after applying the <span>$D$</span> operator.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantEcon/QuantEcon.jl/blob/b686df7a6cf4c8a71a85fdeaf5add9cf27259e31/src/robustlq.jl#L77">source</a></section></details></article><article><details class="docstring" open="true"><summary id="QuantEcon.discrete_var"><a class="docstring-binding" href="#QuantEcon.discrete_var"><code>QuantEcon.discrete_var</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">discrete_var(b, B, Psi, Nm, n_moments=2, method=Even(), n_sigmas=sqrt(Nm-1))</code></pre><p>Compute a finite-state Markov chain approximation to a VAR(1) process of the form</p><p class="math-container">\[    y_{t+1} = b + By_{t} + \Psi^{\frac{1}{2}}\epsilon_{t+1}\]</p><p>where <span>$\epsilon_{t+1}$</span> is an vector of independent standard normal innovations of length <code>M</code>.</p><p><strong>Arguments</strong></p><ul><li><code>b::Union{Real, AbstractVector}</code>: Constant vector of length <code>M</code>. <code>M=1</code> corresponds scalar case.</li><li><code>B::Union{Real, AbstractMatrix}</code>: <code>M x M</code> matrix of impact coefficients.</li><li><code>Psi::Union{Real, AbstractMatrix}</code>: <code>M x M</code> variance-covariance matrix of the innovations. <code>discrete_var</code> only accepts non-singular variance-covariance matrices, <code>Psi</code>.</li><li><code>Nm::Integer &gt; 3</code>: Desired number of discrete points in each dimension.</li></ul><p><strong>Optional</strong></p><ul><li><code>n_moments::Integer</code>: Desired number of moments to match. The default is 2.</li><li><code>method::VAREstimationMethod</code>: Specify the method used to determine the grid points. Accepted inputs are <code>Even()</code>, <code>Quantile()</code>, or <code>Quadrature()</code>. Please see the paper for more details.</li><li><code>n_sigmas::Real</code>: If the <code>Even()</code> option is specified, <code>n_sigmas</code> is used to determine the number of unconditional standard deviations used to set the endpoints of the grid. The default is <code>sqrt(Nm-1)</code>.</li></ul><p><strong>Returns</strong></p><ul><li><code>P</code>: <code>Nm^M x Nm^M</code> probability transition matrix. Each row corresponds to a discrete conditional probability distribution over the state M-tuples in <code>X</code>.</li><li><code>X</code>: <code>M x Nm^M</code> matrix of states. Each column corresponds to an M-tuple of values which correspond to the state associated with each row of <code>P</code>.</li></ul><p><strong>NOTES</strong></p><ul><li>discrete_var only constructs tensor product grids where each dimension contains the same number of points. For this reason it is recommended that this code not be used for problems of more than about 4 or 5 dimensions due to curse of dimensionality issues.</li><li>Future updates will allow for singular variance-covariance matrices and sparse grid specifications.</li></ul><p><strong>Reference</strong></p><ul><li>Farmer, L. E., &amp; Toda, A. A. (2017). &quot;Discretizing nonlinear, non‐Gaussian Markov processes with exact conditional moments,&quot; Quantitative Economics, 8(2), 651-683.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantEcon/QuantEcon.jl/blob/b686df7a6cf4c8a71a85fdeaf5add9cf27259e31/src/markov/markov_approx.jl#L243">source</a></section></details></article><article><details class="docstring" open="true"><summary id="QuantEcon.divide_bracket-Union{Tuple{T}, Tuple{Function, T, T}, Tuple{Function, T, T, Int64}} where T&lt;:Number"><a class="docstring-binding" href="#QuantEcon.divide_bracket-Union{Tuple{T}, Tuple{Function, T, T}, Tuple{Function, T, T, Int64}} where T&lt;:Number"><code>QuantEcon.divide_bracket</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">divide_bracket(f, x1, x2, n=50)</code></pre><p>Given a function <code>f</code> defined on the interval <code>[x1, x2]</code>, subdivide the interval into <code>n</code> equally spaced segments, and search for zero crossings of the function. <code>nroot</code> will be set to the number of bracketing pairs found. If it is positive, the arrays <code>xb1[1..nroot]</code> and <code>xb2[1..nroot]</code> will be filled sequentially with any bracketing pairs that are found.</p><p><strong>Arguments</strong></p><ul><li><code>f::Function</code>: The function you want to bracket.</li><li><code>x1::T</code>: Lower border for search interval.</li><li><code>x2::T</code>: Upper border for search interval.</li><li><code>n::Int(50)</code>: The number of sub-intervals to divide <code>[x1, x2]</code> into.</li></ul><p><strong>Returns</strong></p><ul><li><code>x1b::Vector{T}</code>: <code>Vector</code> of lower borders of bracketing intervals.</li><li><code>x2b::Vector{T}</code>: <code>Vector</code> of upper borders of bracketing intervals.</li></ul><p><strong>References</strong></p><p>This is <code>zbrack</code> from Numerical Recipes in C++.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantEcon/QuantEcon.jl/blob/b686df7a6cf4c8a71a85fdeaf5add9cf27259e31/src/zeros.jl#L100-L124">source</a></section></details></article><article><details class="docstring" open="true"><summary id="QuantEcon.do_quad-Tuple{Function, Array, Vector, Vararg{Any}}"><a class="docstring-binding" href="#QuantEcon.do_quad-Tuple{Function, Array, Vector, Vararg{Any}}"><code>QuantEcon.do_quad</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">do_quad(f, nodes, weights, args...; kwargs...)</code></pre><p>Approximate the integral of <code>f</code>, given quadrature <code>nodes</code> and <code>weights</code>.</p><p><strong>Arguments</strong></p><ul><li><code>f::Function</code>: A callable function that is to be approximated over the domain spanned by <code>nodes</code>.</li><li><code>nodes::Array</code>: Quadrature nodes.</li><li><code>weights::Array</code>: Quadrature weights.</li><li><code>args...(Void)</code>: Additional positional arguments to pass to <code>f</code>.</li><li><code>;kwargs...(Void)</code>: Additional keyword arguments to pass to <code>f</code>.</li></ul><p><strong>Returns</strong></p><ul><li><code>out::Float64</code>: The scalar that approximates integral of <code>f</code> on the hypercube formed by <code>[a, b]</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantEcon/QuantEcon.jl/blob/b686df7a6cf4c8a71a85fdeaf5add9cf27259e31/src/quad.jl#L758-L776">source</a></section></details></article><article><details class="docstring" open="true"><summary id="QuantEcon.estimate_mc_discrete-Union{Tuple{T}, Tuple{Vector{T}, Vector{T}}} where T"><a class="docstring-binding" href="#QuantEcon.estimate_mc_discrete-Union{Tuple{T}, Tuple{Vector{T}, Vector{T}}} where T"><code>QuantEcon.estimate_mc_discrete</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">estimate_mc_discrete(X)</code></pre><p>Accepts the simulation of a discrete state Markov chain and estimates the transition probabilities.</p><p>Let <span>$S = s_1, s_2, \ldots, s_N$</span> with <span>$s_1 &lt; s_2 &lt; \ldots &lt; s_N$</span> be the discrete states of a Markov chain. Furthermore, let <span>$P$</span> be the corresponding stochastic transition matrix.</p><p>Given a history of observations, <span>$\{X\}_{t=0}^{T}$</span> with <span>$x_t \in S \forall t$</span>, we would like to estimate the transition probabilities in <span>$P$</span> with <span>$p_{ij}$</span> as the ith row and jth column of <span>$P$</span>. For <span>$x_t = s_i$</span> and <span>$x_{t-1} = s_j$</span>, let <span>$P(x_t | x_{t-1})$</span> be defined as <span>$p_{i,j}$</span> element of the stochastic matrix. The likelihood function is then given by</p><p class="math-container">\[  L(\{X\}^t; P) = \text{Prob}(x_1) \prod_{t=2}^{T} P(x_t | x_{t-1})\]</p><p>The maximum likelihood estimate is then just given by the number of times a transition from <span>$s_i$</span> to <span>$s_j$</span> is observed divided by the number of times <span>$s_i$</span> was observed.</p><p>Note: Because of the estimation procedure used, only states that are observed in the history appear in the estimated Markov chain... It can&#39;t divine whether there are unobserved states in the original Markov chain.</p><p>For more info, refer to:</p><ul><li>http://www.stat.cmu.edu/~cshalizi/462/lectures/06/markov-mle.pdf</li><li>https://stats.stackexchange.com/questions/47685/calculating-log-likelihood-for-given-mle-markov-chains</li></ul><p><strong>Arguments</strong></p><ul><li><code>X::Vector{T}</code>: Simulated history of Markov states.</li></ul><p><strong>Returns</strong></p><ul><li><code>mc::MarkovChain{T}</code>: A Markov chain holding the state values and transition matrix.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantEcon/QuantEcon.jl/blob/b686df7a6cf4c8a71a85fdeaf5add9cf27259e31/src/markov/markov_approx.jl#L148">source</a></section></details></article><article><details class="docstring" open="true"><summary id="QuantEcon.evaluate_F-Tuple{RBLQ, Matrix}"><a class="docstring-binding" href="#QuantEcon.evaluate_F-Tuple{RBLQ, Matrix}"><code>QuantEcon.evaluate_F</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">evaluate_F(rlq, F)</code></pre><p>Given a fixed policy <span>$F$</span>, with the interpretation <span>$u = -F x$</span>, this function computes the matrix <span>$P_F$</span> and constant <span>$d_F$</span> associated with discounted cost <span>$J_F(x) = x&#39; P_F x + d_F$</span>.</p><p><strong>Arguments</strong></p><ul><li><code>rlq::RBLQ</code>: Instance of <code>RBLQ</code> type.</li><li><code>F::Matrix{Float64}</code>: The policy function, a <code>k x n</code> array.</li></ul><p><strong>Returns</strong></p><ul><li><code>K_F::Matrix{Float64}</code>: Worst case policy.</li><li><code>P_F::Matrix{Float64}</code>: Matrix for discounted cost.</li><li><code>d_F::Float64</code>: Constant for discounted cost.</li><li><code>O_F::Matrix{Float64}</code>: Matrix for discounted entropy.</li><li><code>o_F::Float64</code>: Constant for discounted entropy.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantEcon/QuantEcon.jl/blob/b686df7a6cf4c8a71a85fdeaf5add9cf27259e31/src/robustlq.jl#L336">source</a></section></details></article><article><details class="docstring" open="true"><summary id="QuantEcon.evaluate_policy-Tuple{DiscreteDP, QuantEcon.DPSolveResult}"><a class="docstring-binding" href="#QuantEcon.evaluate_policy-Tuple{DiscreteDP, QuantEcon.DPSolveResult}"><code>QuantEcon.evaluate_policy</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">evaluate_policy(ddp, ddpr)</code></pre><p>Method of <code>evaluate_policy</code> that extracts sigma from a <code>DPSolveResult</code>.</p><p>See other docstring for details.</p><p><strong>Arguments</strong></p><ul><li><code>ddp::DiscreteDP</code>: Object that contains the model parameters.</li><li><code>ddpr::DPSolveResult</code>: Object that contains result variables.</li></ul><p><strong>Returns</strong></p><ul><li><code>v_sigma::Array{Float64}</code>: Value vector of <code>sigma</code>, of length <code>n</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantEcon/QuantEcon.jl/blob/b686df7a6cf4c8a71a85fdeaf5add9cf27259e31/src/markov/ddp.jl#L462-L478">source</a></section></details></article><article><details class="docstring" open="true"><summary id="QuantEcon.evaluate_policy-Union{Tuple{T}, Tuple{DiscreteDP, AbstractVector{T}}} where T&lt;:Integer"><a class="docstring-binding" href="#QuantEcon.evaluate_policy-Union{Tuple{T}, Tuple{DiscreteDP, AbstractVector{T}}} where T&lt;:Integer"><code>QuantEcon.evaluate_policy</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">evaluate_policy(ddp, sigma)</code></pre><p>Compute the value of a policy.</p><p><strong>Arguments</strong></p><ul><li><code>ddp::DiscreteDP</code>: Object that contains the model parameters.</li><li><code>sigma::AbstractVector{T&lt;:Integer}</code>: Policy rule vector.</li></ul><p><strong>Returns</strong></p><ul><li><code>v_sigma::Array{Float64}</code>: Value vector of <code>sigma</code>, of length <code>n</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantEcon/QuantEcon.jl/blob/b686df7a6cf4c8a71a85fdeaf5add9cf27259e31/src/markov/ddp.jl#L482-L496">source</a></section></details></article><article><details class="docstring" open="true"><summary id="QuantEcon.expand_bracket-Union{Tuple{T}, Tuple{Function, T, T}} where T&lt;:Number"><a class="docstring-binding" href="#QuantEcon.expand_bracket-Union{Tuple{T}, Tuple{Function, T, T}} where T&lt;:Number"><code>QuantEcon.expand_bracket</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">expand_bracket(f, x1, x2; ntry=50, fac=1.6)</code></pre><p>Given a function <code>f</code> and an initial guessed range <code>x1</code> to <code>x2</code>, the routine expands the range geometrically until a root is bracketed by the returned values <code>x1</code> and <code>x2</code> (in which case zbrac returns true) or until the range becomes unacceptably large (in which case a <code>ConvergenceError</code> is thrown).</p><p><strong>Arguments</strong></p><ul><li><code>f::Function</code>: The function you want to bracket.</li><li><code>x1::T</code>: Initial guess for lower border of bracket.</li><li><code>x2::T</code>: Initial guess for upper border of bracket.</li><li><code>;ntry::Int(50)</code>: The maximum number of expansion iterations.</li><li><code>;fac::Float64(1.6)</code>: Expansion factor (higher ⟶ larger interval size jumps).</li></ul><p><strong>Returns</strong></p><ul><li><code>x1::T</code>: The lower end of an actual bracketing interval.</li><li><code>x2::T</code>: The upper end of an actual bracketing interval.</li></ul><p><strong>References</strong></p><p>This method is <code>zbrac</code> from Numerical Recipes in C++.</p><p><strong>Exceptions</strong></p><ul><li>Throws a <code>ConvergenceError</code> if the maximum number of iterations is exceeded.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantEcon/QuantEcon.jl/blob/b686df7a6cf4c8a71a85fdeaf5add9cf27259e31/src/zeros.jl#L43-L71">source</a></section></details></article><article><details class="docstring" open="true"><summary id="QuantEcon.filtered_to_forecast!-Tuple{Kalman}"><a class="docstring-binding" href="#QuantEcon.filtered_to_forecast!-Tuple{Kalman}"><code>QuantEcon.filtered_to_forecast!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">filtered_to_forecast!(k)</code></pre><p>Updates the moments of the time <span>$t$</span> filtering distribution to the moments of the predictive distribution, which becomes the time <span>$t+1$</span> prior.</p><p><strong>Arguments</strong></p><ul><li><code>k::Kalman</code>: An instance of the Kalman filter.</li></ul><p><strong>Returns</strong></p><ul><li><code>nothing</code>: This function modifies the Kalman filter in place.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantEcon/QuantEcon.jl/blob/b686df7a6cf4c8a71a85fdeaf5add9cf27259e31/src/kalman.jl#L118-L133">source</a></section></details></article><article><details class="docstring" open="true"><summary id="QuantEcon.golden_method-Tuple{Function, AbstractVector, AbstractVector}"><a class="docstring-binding" href="#QuantEcon.golden_method-Tuple{Function, AbstractVector, AbstractVector}"><code>QuantEcon.golden_method</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">golden_method(f, a, b; tol=eps()*10, maxit=1000)</code></pre><p>Applies Golden-section search to search for the maximum of a function  elementwise over intervals specified by vectors.</p><p><strong>Arguments</strong></p><ul><li><code>f::Function</code>: Function to maximize. Should accept a vector and return a vector of function values.</li><li><code>a::AbstractVector</code>: Vector of lower bounds for each search interval.</li><li><code>b::AbstractVector</code>: Vector of upper bounds for each search interval.</li><li><code>tol::Real=eps()*10</code>: Convergence tolerance.</li><li><code>maxit::Int=1000</code>: Maximum number of iterations.</li></ul><p><strong>Returns</strong></p><ul><li><code>x::AbstractVector</code>: Vector of points where the function is maximized in each interval.</li><li><code>fx::AbstractVector</code>: Vector of maximum function values.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantEcon/QuantEcon.jl/blob/b686df7a6cf4c8a71a85fdeaf5add9cf27259e31/src/optimization.jl#L1-L19">source</a></section></details></article><article><details class="docstring" open="true"><summary id="QuantEcon.golden_method-Tuple{Function, Real, Real}"><a class="docstring-binding" href="#QuantEcon.golden_method-Tuple{Function, Real, Real}"><code>QuantEcon.golden_method</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">golden_method(f, a, b; tol=10*eps(), maxit=1000)</code></pre><p>Applies Golden-section search to search for the maximum of a function in the interval (a, b).</p><p>See: https://en.wikipedia.org/wiki/Golden-section_search</p><p><strong>Arguments</strong></p><ul><li><code>f::Function</code>: Function to maximize. Should accept a real number and return a real number.</li><li><code>a::Real</code>: Lower bound of the search interval.</li><li><code>b::Real</code>: Upper bound of the search interval.</li><li><code>tol::Float64=10*eps()</code>: Convergence tolerance.</li><li><code>maxit::Int=1000</code>: Maximum number of iterations.</li></ul><p><strong>Returns</strong></p><ul><li><code>x::Real</code>: Point where the function is maximized.</li><li><code>fx::Float64</code>: Maximum function value.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantEcon/QuantEcon.jl/blob/b686df7a6cf4c8a71a85fdeaf5add9cf27259e31/src/optimization.jl#L65-L85">source</a></section></details></article><article><details class="docstring" open="true"><summary id="QuantEcon.gridmake"><a class="docstring-binding" href="#QuantEcon.gridmake"><code>QuantEcon.gridmake</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">gridmake(arrays::Union{AbstractVector,AbstractMatrix}...)</code></pre><p>Expand one or more vectors (or matrices) into a matrix where rows span the cartesian product of combinations of the input arrays. Each column of the input arrays will correspond to one column of the output matrix. The first array varies the fastest (see example).</p><p><strong>Examples</strong></p><pre><code class="language-jlcon hljs">julia&gt; x = [1, 2, 3]; y = [10, 20]; z = [100, 200];

julia&gt; gridmake(x, y, z)
12×3 Matrix{Int64}:
 1  10  100
 2  10  100
 3  10  100
 1  20  100
 2  20  100
 3  20  100
 1  10  200
 2  10  200
 3  10  200
 1  20  200
 2  20  200
 3  20  200</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantEcon/QuantEcon.jl/blob/b686df7a6cf4c8a71a85fdeaf5add9cf27259e31/src/util.jl#L92-L120">source</a></section></details></article><article><details class="docstring" open="true"><summary id="QuantEcon.gridmake!-Tuple{Any, Vararg{Union{AbstractMatrix, AbstractVector}}}"><a class="docstring-binding" href="#QuantEcon.gridmake!-Tuple{Any, Vararg{Union{AbstractMatrix, AbstractVector}}}"><code>QuantEcon.gridmake!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">gridmake!(out::AbstractMatrix, arrays::AbstractVector...)</code></pre><p>Like <code>gridmake</code>, but fills a pre-populated array. <code>out</code> must have size <code>prod(map(length, arrays), dims = length(arrays))</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantEcon/QuantEcon.jl/blob/b686df7a6cf4c8a71a85fdeaf5add9cf27259e31/src/util.jl#L34-L39">source</a></section></details></article><article><details class="docstring" open="true"><summary id="QuantEcon.gth_solve-Union{Tuple{Matrix{T}}, Tuple{T}} where T&lt;:Real"><a class="docstring-binding" href="#QuantEcon.gth_solve-Union{Tuple{Matrix{T}}, Tuple{T}} where T&lt;:Real"><code>QuantEcon.gth_solve</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">gth_solve(A)</code></pre><p>This routine computes the stationary distribution of an irreducible Markov transition matrix (stochastic matrix) or transition rate matrix (generator matrix) <span>$A$</span>.</p><p>More generally, given a Metzler matrix (square matrix whose off-diagonal entries are all nonnegative) <span>$A$</span>, this routine solves for a nonzero solution <span>$x$</span> to <span>$x (A - D) = 0$</span>, where <span>$D$</span> is the diagonal matrix for which the rows of <span>$A - D$</span> sum to zero (i.e., <span>$D_{ii} = \sum_j A_{ij}$</span> for all <span>$i$</span>). One (and only one, up to normalization) nonzero solution exists corresponding to each recurrent class of <span>$A$</span>, and in particular, if <span>$A$</span> is irreducible, there is a unique solution; when there are more than one solution, the routine returns the solution that contains in its support the first index <span>$i$</span> such that no path connects <span>$i$</span> to any index larger than <span>$i$</span>. The solution is normalized so that its 1-norm equals one. This routine implements the Grassmann-Taksar-Heyman (GTH) algorithm (Grassmann, Taksar, and Heyman 1985), a numerically stable variant of Gaussian elimination, where only the off-diagonal entries of <span>$A$</span> are used as the input data. For a nice exposition of the algorithm, see Stewart (2009), Chapter 10.</p><p><strong>Arguments</strong></p><ul><li><code>A::Matrix{T}</code>: Stochastic matrix or generator matrix. Must be of shape n x n.</li></ul><p><strong>Returns</strong></p><ul><li><code>x::Vector{T}</code>: Stationary distribution of <span>$A$</span>.</li></ul><p><strong>References</strong></p><ul><li>W. K. Grassmann, M. I. Taksar and D. P. Heyman, &quot;Regenerative Analysis and Steady State Distributions for Markov Chains, &quot; Operations Research (1985), 1107-1116.</li><li>W. J. Stewart, Probability, Markov Chains, Queues, and Simulation, Princeton University Press, 2009.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantEcon/QuantEcon.jl/blob/b686df7a6cf4c8a71a85fdeaf5add9cf27259e31/src/markov/mc_tools.jl#L75">source</a></section></details></article><article><details class="docstring" open="true"><summary id="QuantEcon.hamilton_filter-Tuple{AbstractVector, Integer, Integer}"><a class="docstring-binding" href="#QuantEcon.hamilton_filter-Tuple{AbstractVector, Integer, Integer}"><code>QuantEcon.hamilton_filter</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">hamilton_filter(y, h, p)</code></pre><p>Apply Hamilton filter to <code>AbstractVector</code>.</p><p>http://econweb.ucsd.edu/~jhamilto/hp.pdf</p><p><strong>Arguments</strong></p><ul><li><code>y::AbstractVector</code>: Data to be filtered.</li><li><code>h::Integer</code>: Time horizon that we are likely to predict incorrectly. Original paper recommends 2 for annual data, 8 for quarterly data, 24 for monthly data.</li><li><code>p::Integer</code>: Number of lags in regression. Must be greater than <code>h</code>. Note: For seasonal data, it&#39;s desirable for <code>p</code> and <code>h</code> to be integer multiples of the number of observations in a year. E.g., for quarterly data, <code>h = 8</code> and <code>p = 4</code> are recommended.</li></ul><p><strong>Returns</strong></p><ul><li><code>y_cycle::Vector</code>: Cyclical component.</li><li><code>y_trend::Vector</code>: Trend component.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantEcon/QuantEcon.jl/blob/b686df7a6cf4c8a71a85fdeaf5add9cf27259e31/src/filter.jl#L30">source</a></section></details></article><article><details class="docstring" open="true"><summary id="QuantEcon.hamilton_filter-Tuple{AbstractVector, Integer}"><a class="docstring-binding" href="#QuantEcon.hamilton_filter-Tuple{AbstractVector, Integer}"><code>QuantEcon.hamilton_filter</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">hamilton_filter(y, h)</code></pre><p>Apply Hamilton filter to <code>AbstractVector</code> under random walk assumption.</p><p>http://econweb.ucsd.edu/~jhamilto/hp.pdf</p><p><strong>Arguments</strong></p><ul><li><code>y::AbstractVector</code>: Data to be filtered.</li><li><code>h::Integer</code>: Time horizon that we are likely to predict incorrectly. Original paper recommends 2 for annual data, 8 for quarterly data, 24 for monthly data. Note: For seasonal data, it&#39;s desirable for <code>h</code> to be an integer multiple of the number of observations in a year. E.g., for quarterly data, <code>h = 8</code> is recommended.</li></ul><p><strong>Returns</strong></p><ul><li><code>y_cycle::Vector</code>: Cyclical component.</li><li><code>y_trend::Vector</code>: Trend component.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantEcon/QuantEcon.jl/blob/b686df7a6cf4c8a71a85fdeaf5add9cf27259e31/src/filter.jl#L71">source</a></section></details></article><article><details class="docstring" open="true"><summary id="QuantEcon.hp_filter-Union{Tuple{T}, Tuple{AbstractVector{T}, Real}} where T&lt;:Real"><a class="docstring-binding" href="#QuantEcon.hp_filter-Union{Tuple{T}, Tuple{AbstractVector{T}, Real}} where T&lt;:Real"><code>QuantEcon.hp_filter</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">hp_filter(y, λ)</code></pre><p>Apply Hodrick-Prescott filter to <code>AbstractVector</code>.</p><p><strong>Arguments</strong></p><ul><li><code>y::AbstractVector</code>: Data to be detrended.</li><li><code>λ::Real</code>: Penalty on variation in trend.</li></ul><p><strong>Returns</strong></p><ul><li><code>y_cyclical::Vector</code>: Cyclical component.</li><li><code>y_trend::Vector</code>: Trend component.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantEcon/QuantEcon.jl/blob/b686df7a6cf4c8a71a85fdeaf5add9cf27259e31/src/filter.jl#L1">source</a></section></details></article><article><details class="docstring" open="true"><summary id="QuantEcon.impulse_response-Tuple{ARMA}"><a class="docstring-binding" href="#QuantEcon.impulse_response-Tuple{ARMA}"><code>QuantEcon.impulse_response</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">impulse_response(arma; impulse_length=30)</code></pre><p>Get the impulse response corresponding to our model.</p><p><strong>Arguments</strong></p><ul><li><code>arma::ARMA</code>: Instance of <code>ARMA</code> type.</li><li><code>;impulse_length::Integer(30)</code>: Length of horizon for calculating impulse response. Must be at least as long as the <code>p</code> fields of <code>arma</code>.</li></ul><p><strong>Returns</strong></p><ul><li><code>psi::Vector{Float64}</code>: <code>psi[j]</code> is the response at lag j of the impulse response. We take <code>psi[1]</code> as unity.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantEcon/QuantEcon.jl/blob/b686df7a6cf4c8a71a85fdeaf5add9cf27259e31/src/arma.jl#L162">source</a></section></details></article><article><details class="docstring" open="true"><summary id="QuantEcon.interp-Tuple{AbstractVector, AbstractVector}"><a class="docstring-binding" href="#QuantEcon.interp-Tuple{AbstractVector, AbstractVector}"><code>QuantEcon.interp</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">interp(grid, function_vals)</code></pre><p>Linear interpolation in one dimension.</p><p><strong>Arguments</strong></p><ul><li><code>grid::AbstractVector</code>: A vector of grid points (will be sorted if not already sorted).</li><li><code>function_vals::AbstractVector</code>: The function values associated with each grid point.</li></ul><p><strong>Returns</strong></p><ul><li><code>LinInterp</code>: A LinInterp object that can be called to perform linear interpolation.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; breaks = cumsum(0.1 .* rand(20));

julia&gt; vals = 0.1 .* sin.(breaks);

julia&gt; li = interp(breaks, vals);

julia&gt; li(0.2)  # Do interpolation by treating `li` as a function you can pass scalars to
0.019866933079506122

julia&gt; li.([0.1, 0.2, 0.3])  # use broadcasting to evaluate at multiple points
3-element Vector{Float64}:
 0.009983341664682815
 0.019866933079506122
 0.02955202066613396</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantEcon/QuantEcon.jl/blob/b686df7a6cf4c8a71a85fdeaf5add9cf27259e31/src/interp.jl#L140-L172">source</a></section></details></article><article><details class="docstring" open="true"><summary id="QuantEcon.is_aperiodic-Tuple{MarkovChain}"><a class="docstring-binding" href="#QuantEcon.is_aperiodic-Tuple{MarkovChain}"><code>QuantEcon.is_aperiodic</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">is_aperiodic(mc)</code></pre><p>Indicate whether the Markov chain <code>mc</code> is aperiodic.</p><p><strong>Arguments</strong></p><ul><li><code>mc::MarkovChain</code>: MarkovChain instance.</li></ul><p><strong>Returns</strong></p><ul><li><code>::Bool</code>: True if the Markov chain is aperiodic, false otherwise.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantEcon/QuantEcon.jl/blob/b686df7a6cf4c8a71a85fdeaf5add9cf27259e31/src/markov/mc_tools.jl#L204-L216">source</a></section></details></article><article><details class="docstring" open="true"><summary id="QuantEcon.is_irreducible-Tuple{MarkovChain}"><a class="docstring-binding" href="#QuantEcon.is_irreducible-Tuple{MarkovChain}"><code>QuantEcon.is_irreducible</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">is_irreducible(mc)</code></pre><p>Indicate whether the Markov chain <code>mc</code> is irreducible.</p><p><strong>Arguments</strong></p><ul><li><code>mc::MarkovChain</code>: MarkovChain instance.</li></ul><p><strong>Returns</strong></p><ul><li><code>::Bool</code>: True if the Markov chain is irreducible, false otherwise.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantEcon/QuantEcon.jl/blob/b686df7a6cf4c8a71a85fdeaf5add9cf27259e31/src/markov/mc_tools.jl#L189-L201">source</a></section></details></article><article><details class="docstring" open="true"><summary id="QuantEcon.is_stable-Tuple{AbstractMatrix}"><a class="docstring-binding" href="#QuantEcon.is_stable-Tuple{AbstractMatrix}"><code>QuantEcon.is_stable</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">is_stable(A)</code></pre><p>General function for testing for stability of matrix <span>$A$</span>. Just checks that eigenvalues are less than 1 in absolute value.</p><p><strong>Arguments</strong></p><ul><li><code>A::Matrix</code>: The matrix we want to check.</li></ul><p><strong>Returns</strong></p><ul><li><code>stable::Bool</code>: Whether or not the matrix is stable.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantEcon/QuantEcon.jl/blob/b686df7a6cf4c8a71a85fdeaf5add9cf27259e31/src/util.jl#L123-L137">source</a></section></details></article><article><details class="docstring" open="true"><summary id="QuantEcon.is_stable-Tuple{LSS}"><a class="docstring-binding" href="#QuantEcon.is_stable-Tuple{LSS}"><code>QuantEcon.is_stable</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">is_stable(lss)</code></pre><p>Test for stability of linear state space system. First removes the constant row and column.</p><p><strong>Arguments</strong></p><ul><li><code>lss::LSS</code>: The linear state space system.</li></ul><p><strong>Returns</strong></p><ul><li><code>stable::Bool</code>: Whether or not the system is stable.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantEcon/QuantEcon.jl/blob/b686df7a6cf4c8a71a85fdeaf5add9cf27259e31/src/lss.jl#L240">source</a></section></details></article><article><details class="docstring" open="true"><summary id="QuantEcon.k_array_rank-Tuple{Type{&lt;:Integer}, Vector{&lt;:Integer}}"><a class="docstring-binding" href="#QuantEcon.k_array_rank-Tuple{Type{&lt;:Integer}, Vector{&lt;:Integer}}"><code>QuantEcon.k_array_rank</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">k_array_rank([T=Int], a)</code></pre><p>Given an array <code>a</code> of k distinct positive integers, sorted in ascending order, return its ranking in the lexicographic ordering of the descending sequences of the elements, following [Combinatorial number system] (https://en.wikipedia.org/wiki/Combinatorial<em>number</em>system).</p><p><strong>Notes</strong></p><p><code>InexactError</code> exception will be thrown, or an incorrect value will be returned without warning if overflow occurs during the computation. It is the user&#39;s responsibility to ensure that the rank of the input array fits within the range of <code>T</code>; a sufficient condition for it is <code>binomial(BigInt(a[end]), BigInt(length(a))) &lt;= typemax(T)</code>.</p><p><strong>Arguments</strong></p><ul><li><code>T::Type{&lt;:Integer}</code>: The numeric type of ranking to be returned.</li><li><code>a::Vector{&lt;:Integer}</code>: Array of length k.</li></ul><p><strong>Returns</strong></p><ul><li><code>idx::T</code>: Ranking of <code>a</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantEcon/QuantEcon.jl/blob/b686df7a6cf4c8a71a85fdeaf5add9cf27259e31/src/util.jl#L397-L422">source</a></section></details></article><article><details class="docstring" open="true"><summary id="QuantEcon.lae_est-Union{Tuple{T}, Tuple{LAE, AbstractArray{T}}} where T"><a class="docstring-binding" href="#QuantEcon.lae_est-Union{Tuple{T}, Tuple{LAE, AbstractArray{T}}} where T"><code>QuantEcon.lae_est</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">lae_est(l, y)</code></pre><p>A vectorized function that returns the value of the look ahead estimate at the values in the array <code>y</code>.</p><p><strong>Arguments</strong></p><ul><li><code>l::LAE</code>: Instance of <code>LAE</code> type.</li><li><code>y::Array</code>: Array that becomes the <code>y</code> in <code>l.p(l.x, y)</code>.</li></ul><p><strong>Returns</strong></p><ul><li><code>psi_vals::Vector</code>: Density at <code>(x, y)</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantEcon/QuantEcon.jl/blob/b686df7a6cf4c8a71a85fdeaf5add9cf27259e31/src/lae.jl#L46-L61">source</a></section></details></article><article><details class="docstring" open="true"><summary id="QuantEcon.lcp_lemke!-Union{Tuple{T}, Tuple{Vector{T}, Matrix{T}, Vector{&lt;:Integer}, AbstractMatrix, AbstractVector}} where T&lt;:AbstractFloat"><a class="docstring-binding" href="#QuantEcon.lcp_lemke!-Union{Tuple{T}, Tuple{Vector{T}, Matrix{T}, Vector{&lt;:Integer}, AbstractMatrix, AbstractVector}} where T&lt;:AbstractFloat"><code>QuantEcon.lcp_lemke!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">lcp_lemke!(z, tableau, basis, M, q; d=ones(T, size(M, 1)),
           max_iter=10^6, piv_options=PivOptions())</code></pre><p>Same as <code>lcp_lemke</code>, but allow for passing preallocated arrays <code>z</code> (to store the solution), <code>tableau</code> and <code>basis</code> (for workspace).</p><p>If <code>M</code> is an <code>n x n</code> matrix, <code>z</code> must be a <code>Vector{T}</code> of length <code>n</code>, <code>tableau</code> a <code>Matrix{T}</code> of size <code>(n, 2n+2)</code>, and <code>basis</code> a <code>Vector{&lt;:Integer}</code> of length <code>n</code>, where <code>T&lt;:AbstractFloat</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantEcon/QuantEcon.jl/blob/b686df7a6cf4c8a71a85fdeaf5add9cf27259e31/src/lcp_lemke.jl#L138-L148">source</a></section></details></article><article><details class="docstring" open="true"><summary id="QuantEcon.lcp_lemke-Union{Tuple{TD}, Tuple{TQ}, Tuple{TM}, Tuple{AbstractMatrix{TM}, AbstractVector{TQ}}} where {TM&lt;:Real, TQ&lt;:Real, TD&lt;:Real}"><a class="docstring-binding" href="#QuantEcon.lcp_lemke-Union{Tuple{TD}, Tuple{TQ}, Tuple{TM}, Tuple{AbstractMatrix{TM}, AbstractVector{TQ}}} where {TM&lt;:Real, TQ&lt;:Real, TD&lt;:Real}"><code>QuantEcon.lcp_lemke</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">lcp_lemke(M, q; d=ones(eltype(M), size(M, 1)), max_iter=10^6,
          piv_options=PivOptions())</code></pre><p>Solve the linear complementarity problem</p><p class="math-container">\[\begin{aligned}
&amp;z \geq 0 \\
&amp;M z + q \geq 0 \\
&amp;z (M z + q) = 0
\end{aligned}\]</p><p>by Lemke&#39;s algorithm (with the lexicographic pivoting rule).</p><p><strong>Arguments</strong></p><ul><li><code>M::AbstractMatrix</code>: Matrix of size <code>(n, n)</code>.</li><li><code>q::AbstractVector</code>: Vector of size <code>(n,)</code>.</li><li><code>d::AbstractVector</code>: Covering vector, of size <code>(n,)</code>. Must be strictly positive. Defaults to the vector of ones.</li><li><code>max_iter::Integer(10^6)</code>: Maximum number of iterations to perform.</li><li><code>piv_options::PivOptions</code>: <code>PivOptions</code> instance to set the following tolerance values:<ul><li><code>tol_piv</code>: Pivot tolerance (default=1.0e-7).</li><li><code>tol_ratio_diff</code>: Tolerance used in the lexicographic pivoting (default=1.0e-13).</li></ul></li></ul><p><strong>Returns</strong></p><ul><li><code>LCPResult</code>: Object consisting of the fields:<ul><li><code>z::Vector</code>: Vector of size <code>(n,)</code> containing the solution.</li><li><code>success::Bool</code>: True if the algorithm succeeded in finding a solution.</li><li><code>status::Int</code>: An integer representing the exit status of the result:<ul><li>0: Solution found successfully</li><li>1: Iteration limit reached</li><li>2: Secondary ray termination</li></ul></li><li><code>num_iter::Int</code>: Number of iterations performed.</li></ul></li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; M = [1 0 0; 2 1 0; 2 2 1];

julia&gt; q = [-8, -12, -14];

julia&gt; res = lcp_lemke(M, q);

julia&gt; res.success
true

julia&gt; res.z
3-element Vector{Float64}:
 8.0
 0.0
 0.0

julia&gt; w = M * res.z + q
3-element Vector{Float64}:
 0.0
 4.0
 2.0

julia&gt; res.z&#39; * w
0.0</code></pre><p><strong>References</strong></p><ul><li>K. G. Murty, Linear Complementarity, Linear and Nonlinear Programming, 1988.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantEcon/QuantEcon.jl/blob/b686df7a6cf4c8a71a85fdeaf5add9cf27259e31/src/lcp_lemke.jl#L50">source</a></section></details></article><article><details class="docstring" open="true"><summary id="QuantEcon.m_quadratic_sum-Tuple{Matrix, Matrix}"><a class="docstring-binding" href="#QuantEcon.m_quadratic_sum-Tuple{Matrix, Matrix}"><code>QuantEcon.m_quadratic_sum</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">m_quadratic_sum(A, B; max_it=50)</code></pre><p>Computes the quadratic sum.</p><p class="math-container">\[    V = \sum_{j=0}^{\infty} A^j B A^{j&#39;}\]</p><p><span>$V$</span> is computed by solving the corresponding discrete lyapunov equation using the doubling algorithm. See the documentation of <code>solve_discrete_lyapunov</code> for more information.</p><p><strong>Arguments</strong></p><ul><li><code>A::Matrix{Float64}</code>: An <code>n x n</code> matrix as described above. We assume in order for convergence that the eigenvalues of <span>$A$</span> have moduli bounded by unity.</li><li><code>B::Matrix{Float64}</code>: An <code>n x n</code> matrix as described above. We assume in order for convergence that the eigenvalues of <span>$B$</span> have moduli bounded by unity.</li><li><code>max_it::Int(50)</code>: Maximum number of iterations.</li></ul><p><strong>Returns</strong></p><ul><li><code>gamma1::Matrix{Float64}</code>: Represents the value <span>$V$</span>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantEcon/QuantEcon.jl/blob/b686df7a6cf4c8a71a85fdeaf5add9cf27259e31/src/quadsums.jl#L63">source</a></section></details></article><article><details class="docstring" open="true"><summary id="QuantEcon.moment_sequence-Tuple{LSS}"><a class="docstring-binding" href="#QuantEcon.moment_sequence-Tuple{LSS}"><code>QuantEcon.moment_sequence</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">moment_sequence(lss)</code></pre><p>Create an iterator to calculate the population mean and variance-covariance matrix for both <span>$x_t$</span> and <span>$y_t$</span>, starting at the initial condition <code>(self.mu_0, self.Sigma_0)</code>.  Each iteration produces a 4-tuple of items <code>(mu_x, mu_y, Sigma_x, Sigma_y)</code> for the next period.</p><p><strong>Arguments</strong></p><ul><li><code>lss::LSS</code>: An instance of the Gaussian linear state space model.</li></ul><p><strong>Returns</strong></p><ul><li><code>iterator</code>: An iterator that yields 4-tuples <code>(mu_x, mu_y, Sigma_x, Sigma_y)</code> for each period.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantEcon/QuantEcon.jl/blob/b686df7a6cf4c8a71a85fdeaf5add9cf27259e31/src/lss.jl#L165">source</a></section></details></article><article><details class="docstring" open="true"><summary id="QuantEcon.n_states-Tuple{MarkovChain}"><a class="docstring-binding" href="#QuantEcon.n_states-Tuple{MarkovChain}"><code>QuantEcon.n_states</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">n_states(mc)</code></pre><p>Number of states in the Markov chain <code>mc</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantEcon/QuantEcon.jl/blob/b686df7a6cf4c8a71a85fdeaf5add9cf27259e31/src/markov/mc_tools.jl#L62-L66">source</a></section></details></article><article><details class="docstring" open="true"><summary id="QuantEcon.next_k_array!-Tuple{Vector{&lt;:Integer}}"><a class="docstring-binding" href="#QuantEcon.next_k_array!-Tuple{Vector{&lt;:Integer}}"><code>QuantEcon.next_k_array!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">next_k_array!(a)</code></pre><p>Given an array <code>a</code> of k distinct positive integers, sorted in ascending order, return the next k-array in the lexicographic ordering of the descending sequences of the elements, following [Combinatorial number system] (https://en.wikipedia.org/wiki/Combinatorial<em>number</em>system). <code>a</code> is modified in place.</p><p><strong>Arguments</strong></p><ul><li><code>a::Vector{&lt;:Integer}</code>: Array of length k.</li></ul><p><strong>Returns</strong></p><ul><li><code>a::Vector{&lt;:Integer}</code>: View of <code>a</code>.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; n, k = 4, 2;

julia&gt; a = collect(1:2);

julia&gt; while a[end] &lt;= n
           @show a
           next_k_array!(a)
       end
a = [1, 2]
a = [1, 3]
a = [2, 3]
a = [1, 4]
a = [2, 4]
a = [3, 4]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantEcon/QuantEcon.jl/blob/b686df7a6cf4c8a71a85fdeaf5add9cf27259e31/src/util.jl#L338-L374">source</a></section></details></article><article><details class="docstring" open="true"><summary id="QuantEcon.nnash-NTuple{13, Any}"><a class="docstring-binding" href="#QuantEcon.nnash-NTuple{13, Any}"><code>QuantEcon.nnash</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">nnash(A, B1, B2, R1, R2, Q1, Q2, S1, S2, W1, W2, M1, M2;
      beta=1.0, tol=1e-8, max_iter=1000)</code></pre><p>Compute the limit of a Nash linear quadratic dynamic game.</p><p>Player <code>i</code> minimizes</p><p class="math-container">\[    \sum_{t=1}^{\infty}\beta^{t-1}(x_t&#39; R_i x_t + 2 x_t&#39; W_i
    u_{it} +u_{it}&#39; Q_i u_{it} + u_{jt}&#39; S_i u_{jt} + 2 u_{jt}&#39;
    M_i u_{it})\]</p><p>subject to the law of motion</p><p class="math-container">\[    x_{t+1} = A x_t + B_1 u_{1t} + B_2 u_{2t}\]</p><p>and a perceived control law <span>$u_j(t) = - f_j x_t$</span> for the other player.</p><p>The solution computed in this routine is the <span>$f_i$</span> and <span>$p_i$</span> of the associated double optimal linear regulator problem.</p><p><strong>Arguments</strong></p><ul><li><code>A</code>: Corresponds to the above equation, should be of size <code>(n, n)</code>.</li><li><code>B1</code>: As above, size <code>(n, k_1)</code>.</li><li><code>B2</code>: As above, size <code>(n, k_2)</code>.</li><li><code>R1</code>: As above, size <code>(n, n)</code>.</li><li><code>R2</code>: As above, size <code>(n, n)</code>.</li><li><code>Q1</code>: As above, size <code>(k_1, k_1)</code>.</li><li><code>Q2</code>: As above, size <code>(k_2, k_2)</code>.</li><li><code>S1</code>: As above, size <code>(k_1, k_1)</code>.</li><li><code>S2</code>: As above, size <code>(k_2, k_2)</code>.</li><li><code>W1</code>: As above, size <code>(n, k_1)</code>.</li><li><code>W2</code>: As above, size <code>(n, k_2)</code>.</li><li><code>M1</code>: As above, size <code>(k_2, k_1)</code>.</li><li><code>M2</code>: As above, size <code>(k_1, k_2)</code>.</li><li><code>;beta::Float64(1.0)</code>: Discount rate.</li><li><code>;tol::Float64(1e-8)</code>: Tolerance level for convergence.</li><li><code>;max_iter::Int(1000)</code>: Maximum number of iterations allowed.</li></ul><p><strong>Returns</strong></p><ul><li><code>F1::Matrix{Float64}</code>: <code>(k_1, n)</code> matrix representing feedback law for agent 1.</li><li><code>F2::Matrix{Float64}</code>: <code>(k_2, n)</code> matrix representing feedback law for agent 2.</li><li><code>P1::Matrix{Float64}</code>: <code>(n, n)</code> matrix representing the steady-state solution to the associated discrete matrix Riccati equation for agent 1.</li><li><code>P2::Matrix{Float64}</code>: <code>(n, n)</code> matrix representing the steady-state solution to the associated discrete matrix Riccati equation for agent 2.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantEcon/QuantEcon.jl/blob/b686df7a6cf4c8a71a85fdeaf5add9cf27259e31/src/lqnash.jl#L12">source</a></section></details></article><article><details class="docstring" open="true"><summary id="QuantEcon.num_compositions-Tuple{Any, Any}"><a class="docstring-binding" href="#QuantEcon.num_compositions-Tuple{Any, Any}"><code>QuantEcon.num_compositions</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">num_compositions(m, n)</code></pre><p>The total number of m-part compositions of n, which is equal to (n + m - 1) choose (m - 1).</p><p><strong>Arguments</strong></p><ul><li><code>m::Int</code>: Number of parts of composition.</li><li><code>n::Int</code>: Integer to decompose.</li></ul><p><strong>Returns</strong></p><ul><li><code>::Int</code>: Total number of m-part compositions of n.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantEcon/QuantEcon.jl/blob/b686df7a6cf4c8a71a85fdeaf5add9cf27259e31/src/util.jl#L151-L165">source</a></section></details></article><article><details class="docstring" open="true"><summary id="QuantEcon.prior_to_filtered!-Tuple{Kalman, Any}"><a class="docstring-binding" href="#QuantEcon.prior_to_filtered!-Tuple{Kalman, Any}"><code>QuantEcon.prior_to_filtered!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">prior_to_filtered!(k, y)</code></pre><p>Updates the moments (<code>cur_x_hat</code>, <code>cur_sigma</code>) of the time <span>$t$</span> prior to the time <span>$t$</span> filtering distribution, using current measurement <span>$y_t$</span>. The updates are according to</p><p class="math-container">\[    \hat{x}^F = \hat{x} + \Sigma G&#39; (G \Sigma G&#39; + R)^{-1}
                    (y - G \hat{x}) \\

    \Sigma^F = \Sigma - \Sigma G&#39; (G \Sigma G&#39; + R)^{-1} G
               \Sigma\]</p><p><strong>Arguments</strong></p><ul><li><code>k::Kalman</code>: An instance of the Kalman filter.</li><li><code>y</code>: The current measurement.</li></ul><p><strong>Returns</strong></p><ul><li><code>nothing</code>: This function modifies the Kalman filter in place.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantEcon/QuantEcon.jl/blob/b686df7a6cf4c8a71a85fdeaf5add9cf27259e31/src/kalman.jl#L76">source</a></section></details></article><article><details class="docstring" open="true"><summary id="QuantEcon.qnwbeta-Tuple{Int64, Real, Real}"><a class="docstring-binding" href="#QuantEcon.qnwbeta-Tuple{Int64, Real, Real}"><code>QuantEcon.qnwbeta</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">qnwbeta(n, a, b)</code></pre><p>Computes nodes and weights for beta distribution.</p><p><strong>Arguments</strong></p><ul><li><code>n::Union{Int, Vector{Int}}</code>: Number of desired nodes along each dimension.</li><li><code>a::Union{Real, Vector{Real}}</code>: First parameter of the beta distribution, along each dimension.</li><li><code>b::Union{Real, Vector{Real}}</code>: Second parameter of the beta distribution, along each dimension.</li></ul><p><strong>Returns</strong></p><ul><li><code>nodes::Array{Float64}</code>: An array of quadrature nodes.</li><li><code>weights::Array{Float64}</code>: An array of corresponding quadrature weights.</li></ul><p><strong>Notes</strong></p><p>If any of the parameters to this function are scalars while others are vectors of length <code>n</code>, the the scalar parameter is repeated <code>n</code> times.</p><p><strong>References</strong></p><p>Miranda, Mario J, and Paul L Fackler. Applied Computational Economics and Finance, MIT Press, 2002.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantEcon/QuantEcon.jl/blob/b686df7a6cf4c8a71a85fdeaf5add9cf27259e31/src/quad.jl#L294-L312">source</a></section></details></article><article><details class="docstring" open="true"><summary id="QuantEcon.qnwcheb-Tuple{Int64, Real, Real}"><a class="docstring-binding" href="#QuantEcon.qnwcheb-Tuple{Int64, Real, Real}"><code>QuantEcon.qnwcheb</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">qnwcheb(n, a, b)</code></pre><p>Computes multivariate Gauss-Chebyshev quadrature nodes and weights.</p><p><strong>Arguments</strong></p><ul><li><code>n::Union{Int, Vector{Int}}</code>: Number of desired nodes along each dimension.</li><li><code>a::Union{Real, Vector{Real}}</code>: Lower endpoint along each dimension.</li><li><code>b::Union{Real, Vector{Real}}</code>: Upper endpoint along each dimension.</li></ul><p><strong>Returns</strong></p><ul><li><code>nodes::Array{Float64}</code>: An array of quadrature nodes.</li><li><code>weights::Array{Float64}</code>: An array of corresponding quadrature weights.</li></ul><p><strong>Notes</strong></p><p>If any of the parameters to this function are scalars while others are vectors of length <code>n</code>, the the scalar parameter is repeated <code>n</code> times.</p><p><strong>References</strong></p><p>Miranda, Mario J, and Paul L Fackler. Applied Computational Economics and Finance, MIT Press, 2002.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantEcon/QuantEcon.jl/blob/b686df7a6cf4c8a71a85fdeaf5add9cf27259e31/src/quad.jl#L107-L123">source</a></section></details></article><article><details class="docstring" open="true"><summary id="QuantEcon.qnwdist-Union{Tuple{T}, Tuple{Distributions.Distribution{Distributions.Univariate, Distributions.Continuous}, Int64}, Tuple{Distributions.Distribution{Distributions.Univariate, Distributions.Continuous}, Int64, Real}, Tuple{Distributions.Distribution{Distributions.Univariate, Distributions.Continuous}, Int64, Real, Real}, Tuple{Distributions.Distribution{Distributions.Univariate, Distributions.Continuous}, Int64, Real, Real, Union{Type{T}, T}}} where T"><a class="docstring-binding" href="#QuantEcon.qnwdist-Union{Tuple{T}, Tuple{Distributions.Distribution{Distributions.Univariate, Distributions.Continuous}, Int64}, Tuple{Distributions.Distribution{Distributions.Univariate, Distributions.Continuous}, Int64, Real}, Tuple{Distributions.Distribution{Distributions.Univariate, Distributions.Continuous}, Int64, Real, Real}, Tuple{Distributions.Distribution{Distributions.Univariate, Distributions.Continuous}, Int64, Real, Real, Union{Type{T}, T}}} where T"><code>QuantEcon.qnwdist</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">qnwdist(d, N; q0=0.001, qN=0.999, method=Quantile)</code></pre><p>Construct <code>N</code> quadrature weights and nodes for distribution <code>d</code> from the quantile <code>q0</code> to the quantile <code>qN</code>.</p><p><strong>Arguments</strong></p><ul><li><code>d::Distributions.ContinuousUnivariateDistribution</code>: The distribution for which to construct quadrature nodes and weights.</li><li><code>N::Int</code>: Number of desired quadrature nodes.</li><li><code>q0::Real(0.001)</code>: Lower quantile bound.</li><li><code>qN::Real(0.999)</code>: Upper quantile bound.</li><li><code>method::Union{T,Type{T}}(Quantile)</code>: Method for node placement. Can be one of:<ul><li><code>Even</code>: nodes will be evenly spaced between the quantiles.</li><li><code>Quantile</code>: nodes will be placed at evenly spaced quantile values.</li></ul></li></ul><p><strong>Returns</strong></p><ul><li><code>nodes::Array{Float64}</code>: An array of quadrature nodes.</li><li><code>weights::Array{Float64}</code>: An array of corresponding quadrature weights.</li></ul><p><strong>Notes</strong></p><p>To construct the weights, consider splitting the nodes into cells centered at each node. Specifically, let notation <code>z_i</code> mean the <code>i</code>th node and let <code>z_{i-1/2}</code> be 1/2 between nodes <code>z_{i-1}</code> and <code>z_i</code>. Then, weights are determined as follows:</p><ul><li><code>weights[1] = cdf(d, z_{1+1/2})</code></li><li><code>weights[N] = 1 - cdf(d, z_{N-1/2})</code></li><li><code>weights[i] = cdf(d, z_{i+1/2}) - cdf(d, z_{i-1/2})</code> for all i in 2:N-1</li></ul><p>In effect, this strategy assigns node <code>i</code> all the probability associated with a random variable occuring within the node <code>i</code>s cell.</p><p>The weights always sum to 1, so they can be used as a proper probability distribution. This means that <code>E[f(x) | x ~ d] ≈ dot(f.(nodes), weights)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantEcon/QuantEcon.jl/blob/b686df7a6cf4c8a71a85fdeaf5add9cf27259e31/src/quad.jl#L931-L966">source</a></section></details></article><article><details class="docstring" open="true"><summary id="QuantEcon.qnwequi"><a class="docstring-binding" href="#QuantEcon.qnwequi"><code>QuantEcon.qnwequi</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">qnwequi(n, a, b, kind)</code></pre><p>Generates equidistributed sequences with property that averages value of integrable function evaluated over the sequence converges to the integral as n goes to infinity.</p><p><strong>Arguments</strong></p><ul><li><code>n::Union{Int, Vector{Int}}</code>: Number of desired nodes along each dimension.</li><li><code>a::Union{Real, Vector{Real}}</code>: Lower endpoint along each dimension.</li><li><code>b::Union{Real, Vector{Real}}</code>: Upper endpoint along each dimension.</li><li><code>kind::AbstractString(&quot;N&quot;)</code>: One of the following:<ul><li>N - Neiderreiter (default)</li><li>W - Weyl</li><li>H - Haber</li><li>R - pseudo Random</li></ul></li></ul><p><strong>Returns</strong></p><ul><li><code>nodes::Array{Float64}</code>: An array of quadrature nodes.</li><li><code>weights::Array{Float64}</code>: An array of corresponding quadrature weights.</li></ul><p><strong>Notes</strong></p><p>If any of the parameters to this function are scalars while others are vectors of length <code>n</code>, the the scalar parameter is repeated <code>n</code> times.</p><p><strong>References</strong></p><p>Miranda, Mario J, and Paul L Fackler. Applied Computational Economics and Finance, MIT Press, 2002.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantEcon/QuantEcon.jl/blob/b686df7a6cf4c8a71a85fdeaf5add9cf27259e31/src/quad.jl#L668-L691">source</a></section></details></article><article><details class="docstring" open="true"><summary id="QuantEcon.qnwgamma"><a class="docstring-binding" href="#QuantEcon.qnwgamma"><code>QuantEcon.qnwgamma</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">qnwgamma(n, a, b)</code></pre><p>Computes nodes and weights for gamma distribution.</p><p><strong>Arguments</strong></p><ul><li><code>n::Union{Int, Vector{Int}}</code>: Number of desired nodes along each dimension.</li><li><code>a::Union{Real, Vector{Real}}</code>: Shape parameter of the gamma distribution, along each dimension. Must be positive. Default is 1.</li><li><code>b::Union{Real, Vector{Real}}</code>: Scale parameter of the gamma distribution, along each dimension. Must be positive. Default is 1.</li></ul><p><strong>Returns</strong></p><ul><li><code>nodes::Array{Float64}</code>: An array of quadrature nodes.</li><li><code>weights::Array{Float64}</code>: An array of corresponding quadrature weights.</li></ul><p><strong>Notes</strong></p><p>If any of the parameters to this function are scalars while others are vectors of length <code>n</code>, the the scalar parameter is repeated <code>n</code> times.</p><p><strong>References</strong></p><p>Miranda, Mario J, and Paul L Fackler. Applied Computational Economics and Finance, MIT Press, 2002.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantEcon/QuantEcon.jl/blob/b686df7a6cf4c8a71a85fdeaf5add9cf27259e31/src/quad.jl#L405-L423">source</a></section></details></article><article><details class="docstring" open="true"><summary id="QuantEcon.qnwlege-Tuple{Int64, Real, Real}"><a class="docstring-binding" href="#QuantEcon.qnwlege-Tuple{Int64, Real, Real}"><code>QuantEcon.qnwlege</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">qnwlege(n, a, b)</code></pre><p>Computes multivariate Gauss-Legendre quadrature nodes and weights.</p><p><strong>Arguments</strong></p><ul><li><code>n::Union{Int, Vector{Int}}</code>: Number of desired nodes along each dimension.</li><li><code>a::Union{Real, Vector{Real}}</code>: Lower endpoint along each dimension.</li><li><code>b::Union{Real, Vector{Real}}</code>: Upper endpoint along each dimension.</li></ul><p><strong>Returns</strong></p><ul><li><code>nodes::Array{Float64}</code>: An array of quadrature nodes.</li><li><code>weights::Array{Float64}</code>: An array of corresponding quadrature weights.</li></ul><p><strong>Notes</strong></p><p>If any of the parameters to this function are scalars while others are vectors of length <code>n</code>, the the scalar parameter is repeated <code>n</code> times.</p><p><strong>References</strong></p><p>Miranda, Mario J, and Paul L Fackler. Applied Computational Economics and Finance, MIT Press, 2002.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantEcon/QuantEcon.jl/blob/b686df7a6cf4c8a71a85fdeaf5add9cf27259e31/src/quad.jl#L38-L54">source</a></section></details></article><article><details class="docstring" open="true"><summary id="QuantEcon.qnwlogn-Tuple{Any, Any, Any}"><a class="docstring-binding" href="#QuantEcon.qnwlogn-Tuple{Any, Any, Any}"><code>QuantEcon.qnwlogn</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">qnwlogn(n, mu, sig2)</code></pre><p>Computes quadrature nodes and weights for multivariate lognormal distribution.</p><p><strong>Arguments</strong></p><ul><li><code>n::Union{Int, Vector{Int}}</code>: Number of desired nodes along each dimension.</li><li><code>mu::Union{Real, Vector{Real}}</code>: Mean along each dimension.</li><li><code>sig2::Union{Real, Vector{Real}, Matrix{Real}}(eye(length(n)))</code>: Covariance structure.</li></ul><p><strong>Returns</strong></p><ul><li><code>nodes::Array{Float64}</code>: An array of quadrature nodes.</li><li><code>weights::Array{Float64}</code>: An array of corresponding quadrature weights.</li></ul><p><strong>Notes</strong></p><p>See also the documentation for <code>qnwnorm</code>.</p><p><strong>References</strong></p><p>Miranda, Mario J, and Paul L Fackler. Applied Computational Economics and Finance, MIT Press, 2002.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantEcon/QuantEcon.jl/blob/b686df7a6cf4c8a71a85fdeaf5add9cf27259e31/src/quad.jl#L638-L657">source</a></section></details></article><article><details class="docstring" open="true"><summary id="QuantEcon.qnwmonomial1-Tuple{AbstractMatrix}"><a class="docstring-binding" href="#QuantEcon.qnwmonomial1-Tuple{AbstractMatrix}"><code>QuantEcon.qnwmonomial1</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">qnwmonomial1(vcv)</code></pre><p>Computes monomial integration nodes and weights for multivariate normal distribution using a first-order monomial rule.</p><p><strong>Arguments</strong></p><ul><li><code>vcv::AbstractMatrix</code>: Variance-covariance matrix.</li></ul><p><strong>Returns</strong></p><ul><li><code>nodes::Array{Float64}</code>: An array of quadrature nodes.</li><li><code>weights::Array{Float64}</code>: An array of corresponding quadrature weights.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantEcon/QuantEcon.jl/blob/b686df7a6cf4c8a71a85fdeaf5add9cf27259e31/src/quad.jl#L835-L846">source</a></section></details></article><article><details class="docstring" open="true"><summary id="QuantEcon.qnwmonomial2-Tuple{AbstractMatrix}"><a class="docstring-binding" href="#QuantEcon.qnwmonomial2-Tuple{AbstractMatrix}"><code>QuantEcon.qnwmonomial2</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">qnwmonomial2(vcv)</code></pre><p>Computes monomial integration nodes and weights for multivariate normal distribution using a second-order monomial rule.</p><p><strong>Arguments</strong></p><ul><li><code>vcv::AbstractMatrix</code>: Variance-covariance matrix.</li></ul><p><strong>Returns</strong></p><ul><li><code>nodes::Array{Float64}</code>: An array of quadrature nodes.</li><li><code>weights::Array{Float64}</code>: An array of corresponding quadrature weights.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantEcon/QuantEcon.jl/blob/b686df7a6cf4c8a71a85fdeaf5add9cf27259e31/src/quad.jl#L869-L880">source</a></section></details></article><article><details class="docstring" open="true"><summary id="QuantEcon.qnwnorm-Tuple{Int64}"><a class="docstring-binding" href="#QuantEcon.qnwnorm-Tuple{Int64}"><code>QuantEcon.qnwnorm</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">qnwnorm(n, mu, sig2)</code></pre><p>Computes nodes and weights for multivariate normal distribution.</p><p><strong>Arguments</strong></p><ul><li><code>n::Union{Int, Vector{Int}}</code>: Number of desired nodes along each dimension.</li><li><code>mu::Union{Real, Vector{Real}}</code>: Mean along each dimension.</li><li><code>sig2::Union{Real, Vector{Real}, Matrix{Real}}(eye(length(n)))</code>: Covariance structure.</li></ul><p><strong>Returns</strong></p><ul><li><code>nodes::Array{Float64}</code>: An array of quadrature nodes.</li><li><code>weights::Array{Float64}</code>: An array of corresponding quadrature weights.</li></ul><p><strong>Notes</strong></p><p>This function has many methods. I try to describe them here.</p><p><code>n</code> or <code>mu</code> can be a vector or a scalar. If just one is a scalar the other is repeated to match the length of the other. If both are scalars, then the number of repeats is inferred from <code>sig2</code>.</p><p><code>sig2</code> can be a matrix, vector or scalar. If it is a matrix, it is treated as the covariance matrix. If it is a vector, it is considered the diagonal of a diagonal covariance matrix. If it is a scalar it is repeated along the diagonal as many times as necessary, where the number of repeats is determined by the length of either <code>n</code> and/or <code>mu</code> (which ever is a vector).</p><p>If all 3 are scalars, then 1d nodes are computed. <code>mu</code> and <code>sig2</code> are treated as the mean and variance of a 1d normal distribution.</p><p><strong>References</strong></p><p>Miranda, Mario J, and Paul L Fackler. Applied Computational Economics and Finance, MIT Press, 2002.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantEcon/QuantEcon.jl/blob/b686df7a6cf4c8a71a85fdeaf5add9cf27259e31/src/quad.jl#L131-L163">source</a></section></details></article><article><details class="docstring" open="true"><summary id="QuantEcon.qnwsimp-Tuple{Int64, Real, Real}"><a class="docstring-binding" href="#QuantEcon.qnwsimp-Tuple{Int64, Real, Real}"><code>QuantEcon.qnwsimp</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">qnwsimp(n, a, b)</code></pre><p>Computes multivariate Simpson quadrature nodes and weights.</p><p><strong>Arguments</strong></p><ul><li><code>n::Union{Int, Vector{Int}}</code>: Number of desired nodes along each dimension.</li><li><code>a::Union{Real, Vector{Real}}</code>: Lower endpoint along each dimension.</li><li><code>b::Union{Real, Vector{Real}}</code>: Upper endpoint along each dimension.</li></ul><p><strong>Returns</strong></p><ul><li><code>nodes::Array{Float64}</code>: An array of quadrature nodes.</li><li><code>weights::Array{Float64}</code>: An array of corresponding quadrature weights.</li></ul><p><strong>Notes</strong></p><p>If any of the parameters to this function are scalars while others are vectors of length <code>n</code>, the the scalar parameter is repeated <code>n</code> times.</p><p><strong>References</strong></p><p>Miranda, Mario J, and Paul L Fackler. Applied Computational Economics and Finance, MIT Press, 2002.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantEcon/QuantEcon.jl/blob/b686df7a6cf4c8a71a85fdeaf5add9cf27259e31/src/quad.jl#L228-L244">source</a></section></details></article><article><details class="docstring" open="true"><summary id="QuantEcon.qnwtrap-Tuple{Int64, Real, Real}"><a class="docstring-binding" href="#QuantEcon.qnwtrap-Tuple{Int64, Real, Real}"><code>QuantEcon.qnwtrap</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">qnwtrap(n, a, b)</code></pre><p>Computes multivariate trapezoid quadrature nodes and weights.</p><p><strong>Arguments</strong></p><ul><li><code>n::Union{Int, Vector{Int}}</code>: Number of desired nodes along each dimension.</li><li><code>a::Union{Real, Vector{Real}}</code>: Lower endpoint along each dimension.</li><li><code>b::Union{Real, Vector{Real}}</code>: Upper endpoint along each dimension.</li></ul><p><strong>Returns</strong></p><ul><li><code>nodes::Array{Float64}</code>: An array of quadrature nodes.</li><li><code>weights::Array{Float64}</code>: An array of corresponding quadrature weights.</li></ul><p><strong>Notes</strong></p><p>If any of the parameters to this function are scalars while others are vectors of length <code>n</code>, the the scalar parameter is repeated <code>n</code> times.</p><p><strong>References</strong></p><p>Miranda, Mario J, and Paul L Fackler. Applied Computational Economics and Finance, MIT Press, 2002.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantEcon/QuantEcon.jl/blob/b686df7a6cf4c8a71a85fdeaf5add9cf27259e31/src/quad.jl#L265-L281">source</a></section></details></article><article><details class="docstring" open="true"><summary id="QuantEcon.qnwunif-Tuple{Any, Any, Any}"><a class="docstring-binding" href="#QuantEcon.qnwunif-Tuple{Any, Any, Any}"><code>QuantEcon.qnwunif</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">qnwunif(n, a, b)</code></pre><p>Computes quadrature nodes and weights for multivariate uniform distribution.</p><p><strong>Arguments</strong></p><ul><li><code>n::Union{Int, Vector{Int}}</code>: Number of desired nodes along each dimension.</li><li><code>a::Union{Real, Vector{Real}}</code>: Lower endpoint along each dimension.</li><li><code>b::Union{Real, Vector{Real}}</code>: Upper endpoint along each dimension.</li></ul><p><strong>Returns</strong></p><ul><li><code>nodes::Array{Float64}</code>: An array of quadrature nodes.</li><li><code>weights::Array{Float64}</code>: An array of corresponding quadrature weights.</li></ul><p><strong>Notes</strong></p><p>If any of the parameters to this function are scalars while others are vectors of length <code>n</code>, the the scalar parameter is repeated <code>n</code> times.</p><p><strong>References</strong></p><p>Miranda, Mario J, and Paul L Fackler. Applied Computational Economics and Finance, MIT Press, 2002.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantEcon/QuantEcon.jl/blob/b686df7a6cf4c8a71a85fdeaf5add9cf27259e31/src/quad.jl#L615-L631">source</a></section></details></article><article><details class="docstring" open="true"><summary id="QuantEcon.quadrect"><a class="docstring-binding" href="#QuantEcon.quadrect"><code>QuantEcon.quadrect</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">quadrect(f, n, a, b, kind, args...; kwargs...)</code></pre><p>Integrate the d-dimensional function <code>f</code> on a rectangle with lower and upper bound for dimension i defined by <code>a[i]</code> and <code>b[i]</code>, respectively; using <code>n[i]</code> points.</p><p><strong>Arguments</strong></p><ul><li><code>f::Function</code>: The function to integrate over. This should be a function that accepts as its first argument a matrix representing points along each dimension (each dimension is a column). Other arguments that need to be passed to the function are caught by <code>args...</code> and <code>kwargs...</code>.</li><li><code>n::Union{Int, Vector{Int}}</code>: Number of desired nodes along each dimension.</li><li><code>a::Union{Real, Vector{Real}}</code>: Lower endpoint along each dimension.</li><li><code>b::Union{Real, Vector{Real}}</code>: Upper endpoint along each dimension.</li><li><code>kind::AbstractString(&quot;lege&quot;)</code>: Specifies which type of integration to perform. Valid values are:<ul><li><code>&quot;lege&quot;</code>: Gauss-Legendre</li><li><code>&quot;cheb&quot;</code>: Gauss-Chebyshev</li><li><code>&quot;trap&quot;</code>: trapezoid rule</li><li><code>&quot;simp&quot;</code>: Simpson rule</li><li><code>&quot;N&quot;</code>: Neiderreiter equidistributed sequence</li><li><code>&quot;W&quot;</code>: Weyl equidistributed sequence</li><li><code>&quot;H&quot;</code>: Haber equidistributed sequence</li><li><code>&quot;R&quot;</code>: Monte Carlo</li></ul></li><li><code>args...(Void)</code>: Additional positional arguments to pass to <code>f</code>.</li><li><code>;kwargs...(Void)</code>: Additional keyword arguments to pass to <code>f</code>.</li></ul><p><strong>Returns</strong></p><ul><li><code>out::Float64</code>: The scalar that approximates integral of <code>f</code> on the hypercube formed by <code>[a, b]</code>.</li></ul><p><strong>References</strong></p><p>Miranda, Mario J, and Paul L Fackler. Applied Computational Economics and Finance, MIT Press, 2002.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantEcon/QuantEcon.jl/blob/b686df7a6cf4c8a71a85fdeaf5add9cf27259e31/src/quad.jl#L783-L817">source</a></section></details></article><article><details class="docstring" open="true"><summary id="QuantEcon.random_discrete_dp"><a class="docstring-binding" href="#QuantEcon.random_discrete_dp"><code>QuantEcon.random_discrete_dp</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">random_discrete_dp([rng], num_states, num_actions[, beta];
                   k=num_states, scale=1)</code></pre><p>Generate a DiscreteDP randomly. The reward values are drawn from the normal distribution with mean 0 and standard deviation <code>scale</code>.</p><p><strong>Arguments</strong></p><ul><li><code>rng::AbstractRNG=GLOBAL_RNG</code>: Random number generator.</li><li><code>num_states::Integer</code>: Number of states.</li><li><code>num_actions::Integer</code>: Number of actions.</li><li><code>beta::Real=rand(rng)</code>: Discount factor. Randomly chosen from <code>[0, 1)</code> if not specified.</li><li><code>;k::Integer(num_states)</code>: Number of possible next states for each state-action pair. Equal to <code>num_states</code> if not specified.</li><li><code>scale::Real(1)</code>: Standard deviation of the normal distribution for the reward values.</li></ul><p><strong>Returns</strong></p><ul><li><code>ddp::DiscreteDP</code>: An instance of DiscreteDP.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantEcon/QuantEcon.jl/blob/b686df7a6cf4c8a71a85fdeaf5add9cf27259e31/src/markov/random_mc.jl#L146-L168">source</a></section></details></article><article><details class="docstring" open="true"><summary id="QuantEcon.random_markov_chain"><a class="docstring-binding" href="#QuantEcon.random_markov_chain"><code>QuantEcon.random_markov_chain</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">random_markov_chain([rng], n[, k])</code></pre><p>Return a randomly sampled MarkovChain instance with <code>n</code> states, where each state has <code>k</code> states with positive transition probability.</p><p><strong>Arguments</strong></p><ul><li><code>rng::AbstractRNG=GLOBAL_RNG</code>: Random number generator.</li><li><code>n::Integer</code>: Number of states.</li><li><code>k::Integer=n</code>: Number of nonzero entries in each column of the matrix. Set to <code>n</code> if none specified.</li></ul><p><strong>Returns</strong></p><ul><li><code>mc::MarkovChain</code>: MarkovChain instance.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; using QuantEcon, Random

julia&gt; rng = MersenneTwister(1234);

julia&gt; mc = random_markov_chain(rng, 3);

julia&gt; mc.p
3×3 LinearAlgebra.Transpose{Float64,Array{Float64,2}}:
 0.590845  0.175952   0.233203
 0.460085  0.106152   0.433763
 0.794026  0.0601209  0.145853

julia&gt; mc = random_markov_chain(rng, 3, 2);

julia&gt; mc.p
3×3 LinearAlgebra.Transpose{Float64,Array{Float64,2}}:
 0.0       0.200586  0.799414
 0.701386  0.0       0.298614
 0.753163  0.246837  0.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantEcon/QuantEcon.jl/blob/b686df7a6cf4c8a71a85fdeaf5add9cf27259e31/src/markov/random_mc.jl#L11-L51">source</a></section></details></article><article><details class="docstring" open="true"><summary id="QuantEcon.random_stochastic_matrix"><a class="docstring-binding" href="#QuantEcon.random_stochastic_matrix"><code>QuantEcon.random_stochastic_matrix</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">random_stochastic_matrix([rng], n[, k])</code></pre><p>Return a randomly sampled <code>n x n</code> stochastic matrix with <code>k</code> nonzero entries for each row.</p><p><strong>Arguments</strong></p><ul><li><code>rng::AbstractRNG=GLOBAL_RNG</code>: Random number generator.</li><li><code>n::Integer</code>: Number of states.</li><li><code>k::Integer=n</code>: Number of nonzero entries in each column of the matrix. Set to <code>n</code> if none specified.</li></ul><p><strong>Returns</strong></p><ul><li><code>p::Array</code>: Stochastic matrix.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantEcon/QuantEcon.jl/blob/b686df7a6cf4c8a71a85fdeaf5add9cf27259e31/src/markov/random_mc.jl#L64-L80">source</a></section></details></article><article><details class="docstring" open="true"><summary id="QuantEcon.recurrent_classes-Tuple{MarkovChain}"><a class="docstring-binding" href="#QuantEcon.recurrent_classes-Tuple{MarkovChain}"><code>QuantEcon.recurrent_classes</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">recurrent_classes(mc)</code></pre><p>Find the recurrent classes of the Markov chain <code>mc</code>.</p><p><strong>Arguments</strong></p><ul><li><code>mc::MarkovChain</code>: MarkovChain instance.</li></ul><p><strong>Returns</strong></p><ul><li><code>::Vector{Vector{Int}}</code>: Vector of vectors that describe the recurrent classes of <code>mc</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantEcon/QuantEcon.jl/blob/b686df7a6cf4c8a71a85fdeaf5add9cf27259e31/src/markov/mc_tools.jl#L157-L170">source</a></section></details></article><article><details class="docstring" open="true"><summary id="QuantEcon.remove_constants-Tuple{LSS}"><a class="docstring-binding" href="#QuantEcon.remove_constants-Tuple{LSS}"><code>QuantEcon.remove_constants</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">remove_constants(lss)</code></pre><p>Finds the row and column, if any,  that correspond to the constant term in a <code>LSS</code> system and removes them to get the matrix that needs to be checked for stability.</p><p><strong>Arguments</strong></p><ul><li><code>lss::LSS</code>: The linear state space system.</li></ul><p><strong>Returns</strong></p><ul><li><code>A::Matrix</code>: The matrix A with constant row and column removed.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantEcon/QuantEcon.jl/blob/b686df7a6cf4c8a71a85fdeaf5add9cf27259e31/src/lss.jl#L266">source</a></section></details></article><article><details class="docstring" open="true"><summary id="QuantEcon.replicate"><a class="docstring-binding" href="#QuantEcon.replicate"><code>QuantEcon.replicate</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">replicate(lss, t, num_reps)</code></pre><p>Simulate <code>num_reps</code> observations of <span>$x_T$</span> and <span>$y_T$</span> given <span>$x_0 \sim N(\mu_0, \Sigma_0)$</span>.</p><p><strong>Arguments</strong></p><ul><li><code>lss::LSS</code>: An instance of the Gaussian linear state space model.</li><li><code>t::Int = 10</code>: The period that we want to replicate values for.</li><li><code>num_reps::Int = 100</code>: The number of replications we want.</li></ul><p><strong>Returns</strong></p><ul><li><code>x::Matrix</code>: An <code>n x num_reps</code> matrix, where the j-th column is the j<em>th observation of ``x</em>T``.</li><li><code>y::Matrix</code>: A <code>k x num_reps</code> matrix, where the j-th column is the j<em>th observation of ``y</em>T``.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantEcon/QuantEcon.jl/blob/b686df7a6cf4c8a71a85fdeaf5add9cf27259e31/src/lss.jl#L112">source</a></section></details></article><article><details class="docstring" open="true"><summary id="QuantEcon.ridder-Union{Tuple{T}, Tuple{Function, T, T}} where T&lt;:AbstractFloat"><a class="docstring-binding" href="#QuantEcon.ridder-Union{Tuple{T}, Tuple{Function, T, T}} where T&lt;:AbstractFloat"><code>QuantEcon.ridder</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">ridder(f, xa, xb; maxiter=500, xtol=1e-12, rtol=2*eps())</code></pre><p>Find a root of the <code>f</code> on the bracketing interval <code>[xa, xb]</code> via Ridder&#39;s algorithm.</p><p><strong>Arguments</strong></p><ul><li><code>f::Function</code>: The function you want to bracket.</li><li><code>x1::T</code>: Lower border for search interval.</li><li><code>x2::T</code>: Upper border for search interval.</li><li><code>;maxiter::Int(500)</code>: Maximum number of bisection iterations.</li><li><code>;xtol::Float64(1e-12)</code>: The routine converges when a root is known to lie within <code>xtol</code> of the value return. Should be &gt;= 0. The routine modifies this to take into account the relative precision of doubles.</li><li><code>;rtol::Float64(2*eps())</code>: The routine converges when a root is known to lie within <code>rtol</code> times the value returned of the value returned. Should be ≥ 0.</li></ul><p><strong>Returns</strong></p><ul><li><code>x::T</code>: The found root.</li></ul><p><strong>Exceptions</strong></p><ul><li>Throws an <code>ArgumentError</code> if <code>[x1, x2]</code> does not form a bracketing interval.</li><li>Throws a <code>ConvergenceError</code> if the maximum number of iterations is exceeded.</li></ul><p><strong>References</strong></p><p>Matches <code>ridder</code> function from scipy/scipy/optimize/Zeros/ridder.c.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantEcon/QuantEcon.jl/blob/b686df7a6cf4c8a71a85fdeaf5add9cf27259e31/src/zeros.jl#L368-L378">source</a></section></details></article><article><details class="docstring" open="true"><summary id="QuantEcon.robust_rule-Tuple{RBLQ}"><a class="docstring-binding" href="#QuantEcon.robust_rule-Tuple{RBLQ}"><code>QuantEcon.robust_rule</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">robust_rule(rlq)</code></pre><p>Solves the robust control problem.</p><p>The algorithm here tricks the problem into a stacked LQ problem, as described in chapter 2 of Hansen-Sargent&#39;s text &quot;Robustness&quot;. The optimal control with observed state is</p><p class="math-container">\[    u_t = - F x_t\]</p><p>And the value function is <span>$-x&#39;Px$</span>.</p><p><strong>Arguments</strong></p><ul><li><code>rlq::RBLQ</code>: Instance of <code>RBLQ</code> type.</li></ul><p><strong>Returns</strong></p><ul><li><code>F::Matrix{Float64}</code>: The optimal control matrix from above.</li><li><code>P::Matrix{Float64}</code>: The positive semi-definite matrix defining the value function.</li><li><code>K::Matrix{Float64}</code>: The worst-case shock matrix <span>$K$</span>, where <span>$w_{t+1} = K x_t$</span> is the worst case shock.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantEcon/QuantEcon.jl/blob/b686df7a6cf4c8a71a85fdeaf5add9cf27259e31/src/robustlq.jl#L143">source</a></section></details></article><article><details class="docstring" open="true"><summary id="QuantEcon.robust_rule_simple"><a class="docstring-binding" href="#QuantEcon.robust_rule_simple"><code>QuantEcon.robust_rule_simple</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">robust_rule_simple(rlq, P=zeros(Float64, rlq.n, rlq.n); max_iter=80, tol=1e-8)</code></pre><p>Solve the robust LQ problem.</p><p>A simple algorithm for computing the robust policy <span>$F$</span> and the corresponding value function <span>$P$</span>, based around straightforward iteration with the robust Bellman operator. This function is easier to understand but one or two orders of magnitude slower than <code>robust_rule()</code>. For more information see the docstring of that method.</p><p><strong>Arguments</strong></p><ul><li><code>rlq::RBLQ</code>: Instance of <code>RBLQ</code> type.</li><li><code>P::Matrix{Float64}(zeros(Float64, rlq.n, rlq.n))</code>: The initial guess for the value function matrix.</li><li><code>;max_iter::Int(80)</code>: Maximum number of iterations that are allowed.</li><li><code>;tol::Real(1e-8)</code>: The tolerance for convergence.</li></ul><p><strong>Returns</strong></p><ul><li><code>F::Matrix{Float64}</code>: The optimal control matrix from above.</li><li><code>P::Matrix{Float64}</code>: The positive semi-definite matrix defining the value function.</li><li><code>K::Matrix{Float64}</code>: The worst-case shock matrix <span>$K$</span>, where <span>$w_{t+1} = K x_t$</span> is the worst case shock.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantEcon/QuantEcon.jl/blob/b686df7a6cf4c8a71a85fdeaf5add9cf27259e31/src/robustlq.jl#L192">source</a></section></details></article><article><details class="docstring" open="true"><summary id="QuantEcon.rouwenhorst"><a class="docstring-binding" href="#QuantEcon.rouwenhorst"><code>QuantEcon.rouwenhorst</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">rouwenhorst(N, ρ, σ, μ=0.0)</code></pre><p>Rouwenhorst&#39;s method to approximate AR(1) processes.</p><p>The process follows</p><p class="math-container">\[    y_t = \mu + \rho y_{t-1} + \epsilon_t\]</p><p>where <span>$\epsilon_t \sim N (0, \sigma^2)$</span>.</p><p><strong>Arguments</strong></p><ul><li><code>N::Integer</code>: Number of points in markov process.</li><li><code>ρ::Real</code>: Persistence parameter in AR(1) process.</li><li><code>σ::Real</code>: Standard deviation of random component of AR(1) process.</li><li><code>μ::Real(0.0)</code>: Mean of AR(1) process.</li></ul><p><strong>Returns</strong></p><ul><li><code>mc::MarkovChain{Float64}</code>: Markov chain holding the state values and transition matrix.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantEcon/QuantEcon.jl/blob/b686df7a6cf4c8a71a85fdeaf5add9cf27259e31/src/markov/markov_approx.jl#L92">source</a></section></details></article><article><details class="docstring" open="true"><summary id="QuantEcon.set_state!-Tuple{Kalman, Any, Any}"><a class="docstring-binding" href="#QuantEcon.set_state!-Tuple{Kalman, Any, Any}"><code>QuantEcon.set_state!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">set_state!(k, x_hat, Sigma)</code></pre><p>Set the current state estimate of the Kalman filter.</p><p><strong>Arguments</strong></p><ul><li><code>k::Kalman</code>: An instance of the Kalman filter.</li><li><code>x_hat</code>: The state mean estimate.</li><li><code>Sigma</code>: The state covariance estimate.</li></ul><p><strong>Returns</strong></p><ul><li><code>nothing</code>: This function modifies the Kalman filter in place.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantEcon/QuantEcon.jl/blob/b686df7a6cf4c8a71a85fdeaf5add9cf27259e31/src/kalman.jl#L55-L69">source</a></section></details></article><article><details class="docstring" open="true"><summary id="QuantEcon.simplex_grid-Tuple{Any, Any}"><a class="docstring-binding" href="#QuantEcon.simplex_grid-Tuple{Any, Any}"><code>QuantEcon.simplex_grid</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">simplex_grid(m, n)</code></pre><p>Construct an array consisting of the integer points in the (m-1)-dimensional simplex <span>$\{x \mid x_1 + \cdots + x_m = n, x_i \geq 0\}$</span>, or equivalently, the m-part compositions of n, which are listed in lexicographic order. The total number of the points (hence the length of the output array) is L = (n+m-1)!/(n!*(m-1)!) (i.e., (n+m-1) choose (m-1)).</p><p><strong>Arguments</strong></p><ul><li><code>m::Int</code>: Dimension of each point. Must be a positive integer.</li><li><code>n::Int</code>: Number which the coordinates of each point sum to. Must be a nonnegative integer.</li></ul><p><strong>Returns</strong></p><ul><li><code>out::Matrix{Int}</code>: Array of shape (m, L) containing the integer points in the simplex, aligned in lexicographic order.</li></ul><p><strong>Notes</strong></p><p>A grid of the (m-1)-dimensional <em>unit</em> simplex with n subdivisions along each dimension can be obtained by <code>simplex_grid(m, n) / n</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; simplex_grid(3, 4)
3×15 Matrix{Int64}:
 0  0  0  0  0  1  1  1  1  2  2  2  3  3  4
 0  1  2  3  4  0  1  2  3  0  1  2  0  1  0
 4  3  2  1  0  3  2  1  0  2  1  0  1  0  0</code></pre><p><strong>References</strong></p><p>A. Nijenhuis and H. S. Wilf, Combinatorial Algorithms, Chapter 5, Academic Press, 1978.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantEcon/QuantEcon.jl/blob/b686df7a6cf4c8a71a85fdeaf5add9cf27259e31/src/util.jl#L245-L285">source</a></section></details></article><article><details class="docstring" open="true"><summary id="QuantEcon.simplex_index-Tuple{Any, Any, Any}"><a class="docstring-binding" href="#QuantEcon.simplex_index-Tuple{Any, Any, Any}"><code>QuantEcon.simplex_index</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">simplex_index(x, m, n)</code></pre><p>Return the index of the point x in the lexicographic order of the integer points of the (m-1)-dimensional simplex <span>$\{x \mid x_0 + \cdots + x_{m-1} = n\}$</span>.</p><p><strong>Arguments</strong></p><ul><li><code>x::Vector{Int}</code>: Integer point in the simplex, i.e., an array of m nonnegative integers that sum to n.</li><li><code>m::Int</code>: Dimension of each point. Must be a positive integer.</li><li><code>n::Int</code>: Number which the coordinates of each point sum to. Must be a nonnegative integer.</li></ul><p><strong>Returns</strong></p><ul><li><code>idx::Int</code>: Index of x.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantEcon/QuantEcon.jl/blob/b686df7a6cf4c8a71a85fdeaf5add9cf27259e31/src/util.jl#L300-L318">source</a></section></details></article><article><details class="docstring" open="true"><summary id="QuantEcon.simulate!-Tuple{Union{AbstractMatrix, AbstractVector}, MarkovChain}"><a class="docstring-binding" href="#QuantEcon.simulate!-Tuple{Union{AbstractMatrix, AbstractVector}, MarkovChain}"><code>QuantEcon.simulate!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">simulate!(X, mc; init=rand(1:n_states(mc)))</code></pre><p>Fill <code>X</code> with sample paths of the Markov chain <code>mc</code> as columns. The resulting matrix has the state values of <code>mc</code> as elements.</p><p><strong>Arguments</strong></p><ul><li><code>X::Matrix</code>: Preallocated matrix to be filled with sample paths</li></ul><p>of the Markov chain <code>mc</code>. The element types in <code>X</code> should be the same as the type of the state values of <code>mc</code>.</p><ul><li><code>mc::MarkovChain</code>: MarkovChain instance.</li><li><code>;init=rand(1:n_states(mc))</code>: Can be one of the following:<ul><li>blank: random initial condition for each chain</li><li>scalar: same initial condition for each chain</li><li>vector: cycle through the elements, applying each as an initial condition until all columns have an initial condition (allows for more columns than initial conditions)</li></ul></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantEcon/QuantEcon.jl/blob/b686df7a6cf4c8a71a85fdeaf5add9cf27259e31/src/markov/mc_tools.jl#L388-L406">source</a></section></details></article><article><details class="docstring" open="true"><summary id="QuantEcon.simulate-Tuple{MarkovChain, Int64}"><a class="docstring-binding" href="#QuantEcon.simulate-Tuple{MarkovChain, Int64}"><code>QuantEcon.simulate</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">simulate(mc, ts_length; init=rand(1:n_states(mc)))</code></pre><p>Simulate one sample path of the Markov chain <code>mc</code>. The resulting vector has the state values of <code>mc</code> as elements.</p><p><strong>Arguments</strong></p><ul><li><code>mc::MarkovChain</code>: MarkovChain instance.</li><li><code>ts_length::Int</code>: Length of simulation.</li><li><code>;init::Int=rand(1:n_states(mc))</code>: Initial state.</li></ul><p><strong>Returns</strong></p><ul><li><code>X::Vector</code>: Vector containing the sample path, with length ts_length.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantEcon/QuantEcon.jl/blob/b686df7a6cf4c8a71a85fdeaf5add9cf27259e31/src/markov/mc_tools.jl#L364-L380">source</a></section></details></article><article><details class="docstring" open="true"><summary id="QuantEcon.simulate_indices!-Union{Tuple{T}, Tuple{AbstractVecOrMat{T}, MarkovChain}} where T&lt;:Integer"><a class="docstring-binding" href="#QuantEcon.simulate_indices!-Union{Tuple{T}, Tuple{AbstractVecOrMat{T}, MarkovChain}} where T&lt;:Integer"><code>QuantEcon.simulate_indices!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">simulate_indices!(X, mc; init=rand(1:n_states(mc)))</code></pre><p>Fill <code>X</code> with sample paths of the Markov chain <code>mc</code> as columns. The resulting matrix has the indices of the state values of <code>mc</code> as elements.</p><p><strong>Arguments</strong></p><ul><li><code>X::Matrix{Int}</code>: Preallocated matrix to be filled with indices</li></ul><p>of the sample paths of the Markov chain <code>mc</code>.</p><ul><li><code>mc::MarkovChain</code>: MarkovChain instance.</li><li><code>;init=rand(1:n_states(mc))</code>: Can be one of the following:<ul><li>blank: random initial condition for each chain</li><li>scalar: same initial condition for each chain</li><li>vector: cycle through the elements, applying each as an initial condition until all columns have an initial condition (allows for more columns than initial conditions)</li></ul></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantEcon/QuantEcon.jl/blob/b686df7a6cf4c8a71a85fdeaf5add9cf27259e31/src/markov/mc_tools.jl#L446-L463">source</a></section></details></article><article><details class="docstring" open="true"><summary id="QuantEcon.simulate_indices-Tuple{MarkovChain, Int64}"><a class="docstring-binding" href="#QuantEcon.simulate_indices-Tuple{MarkovChain, Int64}"><code>QuantEcon.simulate_indices</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">simulate_indices(mc, ts_length; init=rand(1:n_states(mc)))</code></pre><p>Simulate one sample path of the Markov chain <code>mc</code>. The resulting vector has the indices of the state values of <code>mc</code> as elements.</p><p><strong>Arguments</strong></p><ul><li><code>mc::MarkovChain</code>: MarkovChain instance.</li><li><code>ts_length::Int</code>: Length of simulation.</li><li><code>;init::Int=rand(1:n_states(mc))</code>: Initial state.</li></ul><p><strong>Returns</strong></p><ul><li><code>X::Vector{Int}</code>: Vector containing the sample path, with length ts_length.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantEcon/QuantEcon.jl/blob/b686df7a6cf4c8a71a85fdeaf5add9cf27259e31/src/markov/mc_tools.jl#L422-L438">source</a></section></details></article><article><details class="docstring" open="true"><summary id="QuantEcon.simulation-Tuple{ARMA}"><a class="docstring-binding" href="#QuantEcon.simulation-Tuple{ARMA}"><code>QuantEcon.simulation</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">simulation(arma; ts_length=90, impulse_length=30)</code></pre><p>Compute a simulated sample path assuming Gaussian shocks.</p><p><strong>Arguments</strong></p><ul><li><code>arma::ARMA</code>: Instance of <code>ARMA</code> type.</li><li><code>;ts_length::Integer(90)</code>: Length of simulation.</li><li><code>;impulse_length::Integer(30)</code>: Horizon for calculating impulse response (see also docstring for <code>impulse_response</code>)</li></ul><p><strong>Returns</strong></p><ul><li><code>X::Vector{Float64}</code>: Simulation of the ARMA model <code>arma</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantEcon/QuantEcon.jl/blob/b686df7a6cf4c8a71a85fdeaf5add9cf27259e31/src/arma.jl#L194-L209">source</a></section></details></article><article><details class="docstring" open="true"><summary id="QuantEcon.smooth"><a class="docstring-binding" href="#QuantEcon.smooth"><code>QuantEcon.smooth</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">smooth(x, window_len, window=&quot;hanning&quot;)</code></pre><p>Smooth the data in x using convolution with a window of requested size and type.</p><p><strong>Arguments</strong></p><ul><li><code>x::Array</code>: An array containing the data to smooth.</li><li><code>window_len::Int</code>: An odd integer giving the length of the window.</li><li><code>window::AbstractString</code>: A string giving the window type (default: &quot;hanning&quot;). Possible values are <code>flat</code>, <code>hanning</code>, <code>hamming</code>, <code>bartlett</code>, or <code>blackman</code>.</li></ul><p><strong>Returns</strong></p><ul><li><code>out::Array</code>: The array of smoothed data.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantEcon/QuantEcon.jl/blob/b686df7a6cf4c8a71a85fdeaf5add9cf27259e31/src/estspec.jl#L16-L31">source</a></section></details></article><article><details class="docstring" open="true"><summary id="QuantEcon.smooth-Tuple{Array}"><a class="docstring-binding" href="#QuantEcon.smooth-Tuple{Array}"><code>QuantEcon.smooth</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">smooth(x; window_len=7, window=&quot;hanning&quot;)</code></pre><p>Version of <code>smooth</code> where <code>window_len</code> and <code>window</code> are keyword arguments.</p><p><strong>Arguments</strong></p><ul><li><code>x::Array</code>: An array containing the data to smooth.</li><li><code>;window_len::Int(7)</code>: An odd integer giving the length of the window.</li><li><code>;window::AbstractString(&quot;hanning&quot;)</code>: A string giving the window type.</li></ul><p><strong>Returns</strong></p><ul><li><code>out::Array</code>: The array of smoothed data.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantEcon/QuantEcon.jl/blob/b686df7a6cf4c8a71a85fdeaf5add9cf27259e31/src/estspec.jl#L71-L85">source</a></section></details></article><article><details class="docstring" open="true"><summary id="QuantEcon.smooth-Tuple{Kalman, AbstractMatrix}"><a class="docstring-binding" href="#QuantEcon.smooth-Tuple{Kalman, AbstractMatrix}"><code>QuantEcon.smooth</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">smooth(kn, y)</code></pre><p>Computes smoothed state estimates using the Kalman smoother.</p><p><strong>Arguments</strong></p><ul><li><code>kn::Kalman</code>: <code>Kalman</code> instance specifying the model. Initial value must be the prior for t=1 period observation, i.e. <span>$x_{1|0}$</span>.</li><li><code>y::AbstractMatrix</code>: <code>n x T</code> matrix of observed data. <code>n</code> is the number of observed variables in one period. Each column is a vector of observations at each period.</li></ul><p><strong>Returns</strong></p><ul><li><code>x_smoothed::AbstractMatrix</code>: <code>k x T</code> matrix of smoothed mean of states. <code>k</code> is the number of states.</li><li><code>logL::Real</code>: Log-likelihood of all observations.</li><li><code>sigma_smoothed::AbstractArray</code>: <code>k x k x T</code> array of smoothed covariance matrix of states.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantEcon/QuantEcon.jl/blob/b686df7a6cf4c8a71a85fdeaf5add9cf27259e31/src/kalman.jl#L243-L262">source</a></section></details></article><article><details class="docstring" open="true"><summary id="QuantEcon.solve-Union{Tuple{DiscreteDP{T, NQ, NR, Tbeta, Tind, TQ} where {NQ, NR, Tbeta&lt;:Real, Tind, TQ&lt;:AbstractArray{T, NQ}}}, Tuple{T}, Tuple{Algo}, Tuple{DiscreteDP{T, NQ, NR, Tbeta, Tind, TQ} where {NQ, NR, Tbeta&lt;:Real, Tind, TQ&lt;:AbstractArray{T, NQ}}, Type{Algo}}} where {Algo&lt;:QuantEcon.DDPAlgorithm, T}"><a class="docstring-binding" href="#QuantEcon.solve-Union{Tuple{DiscreteDP{T, NQ, NR, Tbeta, Tind, TQ} where {NQ, NR, Tbeta&lt;:Real, Tind, TQ&lt;:AbstractArray{T, NQ}}}, Tuple{T}, Tuple{Algo}, Tuple{DiscreteDP{T, NQ, NR, Tbeta, Tind, TQ} where {NQ, NR, Tbeta&lt;:Real, Tind, TQ&lt;:AbstractArray{T, NQ}}, Type{Algo}}} where {Algo&lt;:QuantEcon.DDPAlgorithm, T}"><code>QuantEcon.solve</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">solve(ddp[, method=VFI]; max_iter=250, epsilon=1e-3, k=20)</code></pre><p>Solve the dynamic programming problem.</p><p><strong>Arguments</strong></p><ul><li><code>ddp::DiscreteDP</code>: Object that contains the model parameters.</li><li><code>method::Type{&lt;:DDPAlgorithm}(VFI)</code>: Type name specifying solution method. Acceptable arguments are <code>VFI</code> for value function iteration or <code>PFI</code> for policy function iteration or <code>MPFI</code> for modified policy function iteration.</li><li><code>;max_iter::Int(250)</code>: Maximum number of iterations.</li><li><code>;epsilon::Float64(1e-3)</code>: Value for epsilon-optimality. Only used if <code>method</code> is <code>VFI</code>.</li><li><code>;k::Int(20)</code>: Number of iterations for partial policy evaluation in  modified policy iteration (irrelevant for other methods).</li></ul><p><strong>Returns</strong></p><ul><li><code>ddpr::DPSolveResult{&lt;:DDPAlgorithm}</code>: Optimization result represented as a <code>DPSolveResult</code>. See <code>DPSolveResult</code> for details.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantEcon/QuantEcon.jl/blob/b686df7a6cf4c8a71a85fdeaf5add9cf27259e31/src/markov/ddp.jl#L512-L534">source</a></section></details></article><article><details class="docstring" open="true"><summary id="QuantEcon.solve_discrete_lyapunov"><a class="docstring-binding" href="#QuantEcon.solve_discrete_lyapunov"><code>QuantEcon.solve_discrete_lyapunov</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">solve_discrete_lyapunov(A, B, max_it=50)</code></pre><p>Solves the discrete Lyapunov equation.</p><p>The problem is given by</p><p class="math-container">\[    AXA&#39; - X + B = 0\]</p><p><span>$X$</span> is computed by using a doubling algorithm. In particular, we iterate to convergence on <span>$X_j$</span> with the following recursions for <span>$j = 1, 2, \ldots$</span> starting from <span>$X_0 = B, a_0 = A$</span>:</p><p class="math-container">\[    a_j = a_{j-1} a_{j-1} \\

    X_j = X_{j-1} + a_{j-1} X_{j-1} a_{j-1}&#39;\]</p><p><strong>Arguments</strong></p><ul><li><code>A::Matrix{Float64}</code>: An <code>n x n</code> matrix as described above. We assume in order for convergence that the eigenvalues of <span>$A$</span> have moduli bounded by unity.</li><li><code>B::Matrix{Float64}</code>: An <code>n x n</code> matrix as described above. We assume in order for convergence that the eigenvalues of <span>$B$</span> have moduli bounded by unity.</li><li><code>max_it::Int(50)</code>: Maximum number of iterations.</li></ul><p><strong>Returns</strong></p><ul><li><code>gamma1::Matrix{Float64}</code>: Represents the value <span>$X$</span>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantEcon/QuantEcon.jl/blob/b686df7a6cf4c8a71a85fdeaf5add9cf27259e31/src/matrix_eqn.jl#L3">source</a></section></details></article><article><details class="docstring" open="true"><summary id="QuantEcon.solve_discrete_riccati"><a class="docstring-binding" href="#QuantEcon.solve_discrete_riccati"><code>QuantEcon.solve_discrete_riccati</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">solve_discrete_riccati(A, B, Q, R, N=zeros(size(R, 1), size(Q, 1)); tolerance=1e-10, max_it=50)</code></pre><p>Solves the discrete-time algebraic Riccati equation.</p><p>The problem is defined as</p><p class="math-container">\[    X = A&#39;XA - (N + B&#39;XA)&#39;(B&#39;XB + R)^{-1}(N + B&#39;XA) + Q\]</p><p>via a modified structured doubling algorithm. An explanation of the algorithm can be found in the reference below.</p><p><strong>Arguments</strong></p><ul><li><code>A</code>: <code>k x k</code> array.</li><li><code>B</code>: <code>k x n</code> array.</li><li><code>R</code>: <code>n x n</code>, should be symmetric and positive definite.</li><li><code>Q</code>: <code>k x k</code>, should be symmetric and non-negative definite.</li><li><code>N::Matrix{Float64}(zeros(size(R, 1), size(Q, 1)))</code>: <code>n x k</code> array.</li><li><code>tolerance::Float64(1e-10)</code>: Tolerance level for convergence.</li><li><code>max_it::Int(50)</code>: The maximum number of iterations allowed.</li></ul><p>Note that <code>A, B, R, Q</code> can either be real (i.e. <code>k, n = 1</code>) or matrices.</p><p><strong>Returns</strong></p><ul><li><code>X::Matrix{Float64}</code>: The fixed point of the Riccati equation; a <code>k x k</code> array representing the approximate solution.</li></ul><p><strong>References</strong></p><p>Chiang, Chun-Yueh, Hung-Yuan Fan, and Wen-Wei Lin. &quot;STRUCTURED DOUBLING ALGORITHM FOR DISCRETE-TIME ALGEBRAIC RICCATI EQUATIONS WITH SINGULAR CONTROL WEIGHTING MATRICES.&quot; Taiwanese Journal of Mathematics 14, no. 3A (2010): pp-935.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantEcon/QuantEcon.jl/blob/b686df7a6cf4c8a71a85fdeaf5add9cf27259e31/src/matrix_eqn.jl#L70">source</a></section></details></article><article><details class="docstring" open="true"><summary id="QuantEcon.spectral_density-Tuple{ARMA}"><a class="docstring-binding" href="#QuantEcon.spectral_density-Tuple{ARMA}"><code>QuantEcon.spectral_density</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">spectral_density(arma; res=1200, two_pi=true)</code></pre><p>Compute the spectral density function.</p><p>The spectral density is the discrete time Fourier transform of the autocovariance function. In particular,</p><p class="math-container">\[    f(w) = \sum_k \gamma(k) \exp(-ikw)\]</p><p>where <span>$\gamma$</span> is the autocovariance function and the sum is over the set of all integers.</p><p><strong>Arguments</strong></p><ul><li><code>arma::ARMA</code>: Instance of <code>ARMA</code> type.</li><li><code>;two_pi::Bool(true)</code>: Compute the spectral density function over <span>$[0, \pi]$</span> if false and <span>$[0, 2 \pi]$</span> otherwise.</li><li><code>;res(1200)</code>: If <code>res</code> is a scalar then the spectral density is computed at <code>res</code> frequencies evenly spaced around the unit circle, but if <code>res</code> is an array then the function computes the response at the frequencies given by the array.</li></ul><p><strong>Returns</strong></p><ul><li><code>w::Vector{Float64}</code>: The normalized frequencies at which h was computed, in radians/sample.</li><li><code>spect::Vector{Float64}</code>: The frequency response.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantEcon/QuantEcon.jl/blob/b686df7a6cf4c8a71a85fdeaf5add9cf27259e31/src/arma.jl#L97">source</a></section></details></article><article><details class="docstring" open="true"><summary id="QuantEcon.stationary_distributions"><a class="docstring-binding" href="#QuantEcon.stationary_distributions"><code>QuantEcon.stationary_distributions</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">stationary_distributions(mc)</code></pre><p>Compute stationary distributions of the Markov chain <code>mc</code>, one for each recurrent class.</p><p><strong>Arguments</strong></p><ul><li><code>mc::MarkovChain{T}</code>: MarkovChain instance.</li></ul><p><strong>Returns</strong></p><ul><li><code>stationary_dists::Vector{Vector{T1}}</code>: Vector of vectors that represent stationary distributions, where the element type <code>T1</code> is <code>Rational</code> if <code>T</code> is <code>Int</code> (and equal to <code>T</code> otherwise).</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantEcon/QuantEcon.jl/blob/b686df7a6cf4c8a71a85fdeaf5add9cf27259e31/src/markov/mc_tools.jl#L269">source</a></section></details></article><article><details class="docstring" open="true"><summary id="QuantEcon.stationary_distributions-Tuple{LSS}"><a class="docstring-binding" href="#QuantEcon.stationary_distributions-Tuple{LSS}"><code>QuantEcon.stationary_distributions</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">stationary_distributions(lss; max_iter, tol)</code></pre><p>Compute the moments of the stationary distributions of <span>$x_t$</span> and <span>$y_t$</span> if possible.  Computation is by iteration, starting from the initial conditions <code>lss.mu_0</code> and <code>lss.Sigma_0</code>.</p><p><strong>Arguments</strong></p><ul><li><code>lss::LSS</code>: An instance of the Gaussian linear state space model.</li><li><code>;max_iter::Int = 200</code>: The maximum number of iterations allowed.</li><li><code>;tol::Float64 = 1e-5</code>: The tolerance level one wishes to achieve.</li></ul><p><strong>Returns</strong></p><ul><li><code>mu_x::Vector</code>: Represents the stationary mean of <span>$x_t$</span>.</li><li><code>mu_y::Vector</code>: Represents the stationary mean of <span>$y_t$</span>.</li><li><code>Sigma_x::Matrix</code>: Represents the var-cov matrix.</li><li><code>Sigma_y::Matrix</code>: Represents the var-cov matrix.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantEcon/QuantEcon.jl/blob/b686df7a6cf4c8a71a85fdeaf5add9cf27259e31/src/lss.jl#L186">source</a></section></details></article><article><details class="docstring" open="true"><summary id="QuantEcon.stationary_values!-Tuple{LQ}"><a class="docstring-binding" href="#QuantEcon.stationary_values!-Tuple{LQ}"><code>QuantEcon.stationary_values!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">stationary_values!(lq)</code></pre><p>Computes value and policy functions in infinite horizon model.</p><p><strong>Arguments</strong></p><ul><li><code>lq::LQ</code>: Instance of <code>LQ</code> type.</li></ul><p><strong>Returns</strong></p><ul><li><code>P::ScalarOrArray</code>: n x n matrix in value function representation <span>$V(x) = x&#39;Px + d$</span>.</li><li><code>d::Real</code>: Constant in value function representation.</li><li><code>F::ScalarOrArray</code>: Policy rule that specifies optimal control in each period.</li></ul><p><strong>Notes</strong></p><p>This function updates the <code>P</code>, <code>d</code>, and <code>F</code> fields on the <code>lq</code> instance in addition to returning them.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantEcon/QuantEcon.jl/blob/b686df7a6cf4c8a71a85fdeaf5add9cf27259e31/src/lqcontrol.jl#L187">source</a></section></details></article><article><details class="docstring" open="true"><summary id="QuantEcon.stationary_values-Tuple{Kalman}"><a class="docstring-binding" href="#QuantEcon.stationary_values-Tuple{Kalman}"><code>QuantEcon.stationary_values</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">stationary_values(k)</code></pre><p>Compute the stationary covariance matrix and Kalman gain for the filter.</p><p><strong>Arguments</strong></p><ul><li><code>k::Kalman</code>: An instance of the Kalman filter.</li></ul><p><strong>Returns</strong></p><ul><li><code>Sigma_inf</code>: The stationary state covariance matrix.</li><li><code>K_inf</code>: The stationary Kalman gain matrix.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantEcon/QuantEcon.jl/blob/b686df7a6cf4c8a71a85fdeaf5add9cf27259e31/src/kalman.jl#L168-L181">source</a></section></details></article><article><details class="docstring" open="true"><summary id="QuantEcon.stationary_values-Tuple{LQ}"><a class="docstring-binding" href="#QuantEcon.stationary_values-Tuple{LQ}"><code>QuantEcon.stationary_values</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">stationary_values(lq)</code></pre><p>Non-mutating routine for solving for <code>P</code>, <code>d</code>, and <code>F</code> in infinite horizon model.</p><p><strong>Arguments</strong></p><ul><li><code>lq::LQ</code>: Instance of <code>LQ</code> type.</li></ul><p><strong>Returns</strong></p><ul><li><code>P::ScalarOrArray</code>: n x n matrix in value function representation <span>$V(x) = x&#39;Px + d$</span>.</li><li><code>F::ScalarOrArray</code>: Policy rule that specifies optimal control in each period.</li><li><code>d::Real</code>: Constant in value function representation.</li></ul><p>See docstring for <code>stationary_values!</code> for more explanation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantEcon/QuantEcon.jl/blob/b686df7a6cf4c8a71a85fdeaf5add9cf27259e31/src/lqcontrol.jl#L228-L244">source</a></section></details></article><article><details class="docstring" open="true"><summary id="QuantEcon.tauchen-Union{Tuple{T3}, Tuple{T2}, Tuple{T1}, Tuple{Integer, T1, T2}, Tuple{Integer, T1, T2, Any}, Tuple{Integer, T1, T2, Any, T3}} where {T1&lt;:Real, T2&lt;:Real, T3&lt;:Real}"><a class="docstring-binding" href="#QuantEcon.tauchen-Union{Tuple{T3}, Tuple{T2}, Tuple{T1}, Tuple{Integer, T1, T2}, Tuple{Integer, T1, T2, Any}, Tuple{Integer, T1, T2, Any, T3}} where {T1&lt;:Real, T2&lt;:Real, T3&lt;:Real}"><code>QuantEcon.tauchen</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">tauchen(N, ρ, σ, μ=0.0, n_std=3)</code></pre><p>Tauchen&#39;s (1996) method for approximating AR(1) process with finite markov chain.</p><p>The process follows</p><p class="math-container">\[    y_t = \mu + \rho y_{t-1} + \epsilon_t\]</p><p>where <span>$\epsilon_t \sim N (0, \sigma^2)$</span>.</p><p><strong>Arguments</strong></p><ul><li><code>N::Integer</code>: Number of points in markov process.</li><li><code>ρ::Real</code>: Persistence parameter in AR(1) process.</li><li><code>σ::Real</code>: Standard deviation of random component of AR(1) process.</li><li><code>μ::Real(0.0)</code>: Mean of AR(1) process.</li><li><code>n_std::Real(3)</code>: The number of standard deviations to each side the process should span.</li></ul><p><strong>Returns</strong></p><ul><li><code>mc::MarkovChain</code>: Markov chain holding the state values and transition matrix.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantEcon/QuantEcon.jl/blob/b686df7a6cf4c8a71a85fdeaf5add9cf27259e31/src/markov/markov_approx.jl#L21">source</a></section></details></article><article><details class="docstring" open="true"><summary id="QuantEcon.update!-Tuple{Kalman, Any}"><a class="docstring-binding" href="#QuantEcon.update!-Tuple{Kalman, Any}"><code>QuantEcon.update!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">update!(k, y)</code></pre><p>Updates <code>cur_x_hat</code> and <code>cur_sigma</code> given array <code>y</code> of length <code>k</code>.  The full update, from one period to the next.</p><p><strong>Arguments</strong></p><ul><li><code>k::Kalman</code>: An instance of the Kalman filter.</li><li><code>y</code>: An array representing the current measurement.</li></ul><p><strong>Returns</strong></p><ul><li><code>nothing</code>: This function modifies the Kalman filter in place.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantEcon/QuantEcon.jl/blob/b686df7a6cf4c8a71a85fdeaf5add9cf27259e31/src/kalman.jl#L145-L160">source</a></section></details></article><article><details class="docstring" open="true"><summary id="QuantEcon.update_values!-Tuple{LQ}"><a class="docstring-binding" href="#QuantEcon.update_values!-Tuple{LQ}"><code>QuantEcon.update_values!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">update_values!(lq)</code></pre><p>Update <code>P</code> and <code>d</code> from the value function representation in finite horizon case.</p><p><strong>Arguments</strong></p><ul><li><code>lq::LQ</code>: Instance of <code>LQ</code> type.</li></ul><p><strong>Returns</strong></p><ul><li><code>P::ScalarOrArray</code>: <code>n x n</code> matrix in value function representation <span>$V(x) = x&#39;Px + d$</span>.</li><li><code>d::Real</code>: Constant in value function representation.</li></ul><p><strong>Notes</strong></p><p>This function updates the <code>P</code> and <code>d</code> fields on the <code>lq</code> instance in addition to returning them.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantEcon/QuantEcon.jl/blob/b686df7a6cf4c8a71a85fdeaf5add9cf27259e31/src/lqcontrol.jl#L144">source</a></section></details></article><article><details class="docstring" open="true"><summary id="QuantEcon.var_quadratic_sum-Tuple{Union{Array{T}, T} where T, Union{Array{T}, T} where T, Union{Array{T}, T} where T, Real, Union{Array{T}, T} where T}"><a class="docstring-binding" href="#QuantEcon.var_quadratic_sum-Tuple{Union{Array{T}, T} where T, Union{Array{T}, T} where T, Union{Array{T}, T} where T, Real, Union{Array{T}, T} where T}"><code>QuantEcon.var_quadratic_sum</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">var_quadratic_sum(A, C, H, beta, x_0)</code></pre><p>Computes the expected discounted quadratic sum.</p><p class="math-container">\[    q(x_0) = \mathbb{E} \sum_{t=0}^{\infty} \beta^t x_t&#39; H x_t\]</p><p>Here <span>${x_t}$</span> is the VAR process <span>$x_{t+1} = A x_t + C w_t$</span> with <span>${w_t}$</span> standard normal and <span>$x_0$</span> the initial condition.</p><p><strong>Arguments</strong></p><ul><li><code>A::Union{Float64, Matrix{Float64}}</code>: The <code>n x n</code> matrix described above (scalar if <code>n = 1</code>).</li><li><code>C::Union{Float64, Matrix{Float64}}</code>: The <code>n x n</code> matrix described above (scalar if <code>n = 1</code>).</li><li><code>H::Union{Float64, Matrix{Float64}}</code>: The <code>n x n</code> matrix described above (scalar if <code>n = 1</code>).</li><li><code>beta::Float64</code>: Discount factor in <code>(0, 1)</code>.</li><li><code>x_0::Union{Float64, Vector{Float64}}</code>: The initial condition. A conformable array (of length <code>n</code>) or a scalar if <code>n = 1</code>.</li></ul><p><strong>Returns</strong></p><ul><li><code>q0::Float64</code>: Represents the value <span>$q(x_0)$</span>.</li></ul><p><strong>Notes</strong></p><p>The formula for computing <span>$q(x_0)$</span> is <span>$q(x_0) = x_0&#39; Q x_0 + v$</span> where</p><ul><li><span>$Q$</span> is the solution to <span>$Q = H + \beta A&#39; Q A$</span> and</li><li><span>$v = \frac{trace(C&#39; Q C) \beta}{1 - \beta}$</span>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantEcon/QuantEcon.jl/blob/b686df7a6cf4c8a71a85fdeaf5add9cf27259e31/src/quadsums.jl#L9">source</a></section></details></article><article><details class="docstring" open="true"><summary id="QuantEcon.@def_sim-Tuple{Any, Any, Any}"><a class="docstring-binding" href="#QuantEcon.@def_sim-Tuple{Any, Any, Any}"><code>QuantEcon.@def_sim</code></a> — <span class="docstring-category">Macro</span></summary><section><div><pre><code class="language-julia hljs">@def_sim sim_name default_type_params begin
    obs_typedef
end</code></pre><p>Given a type definition for a single observation in a simulation (<code>obs_typedef</code>), evaluate that type definition as is, but also creates a second type named <code>sim_name</code> as well as various methods on the new type.</p><p>The fields of <code>sim_name</code> will have the same name as the fields of <code>obs_typedef</code>, but will be arrays of whatever the type of the corresponding <code>obs_typedef</code> field was. The intention is for <code>sim_name</code> to be a struct of arrays (see https://en.wikipedia.org/wiki/AOS<em>and</em>SOA). If you want an array of structs, just simply collect an array of instances of the type defined in <code>obs_typedef</code>. The struct of arrays storage format has better cache efficiency and data locality if you want to operate on all values of a particular field at once, rather than all the fields of a particular value.</p><p>In addition to the new type <code>sim_name</code>, the following methods will be defined:</p><ul><li><code>sim_name(sz::NTuple{N,Int})</code>. This is a constructor for <code>sim_name</code> that allocates arrays of size <code>sz</code> for each field. If <code>obs_typedef</code> included any type parameters, then the default values (specified in <code>default_type_params</code>) will be used.</li><li><code>Base.endof(::sim_name)</code>: Equal to the length of any of its fields.</li><li><code>Base.length(::sim_name)</code>: Equal to the length of any of its fields.</li><li>The iterator protocol for <code>sim_name</code>. The type of each element of the iterator is the type defined in <code>obs_typedef</code>. This amounts to defining the following methods:<ul><li><code>Base.start(::sim_name)::Int</code></li><li><code>Base.next(::sim_name, ::Int)::Tuple{Observation,Int}</code></li><li><code>Base.done(::sim_name, ::Int)::Bool</code></li></ul></li><li><code>Base.getindex(sim::sim_name, ix::Int)</code>. This implements <em>linear indexing</em> for <code>sim_name</code> and will return an instance of the type defined in <code>obs_typedef</code>.</li></ul><p><strong>Examples</strong></p><p>NOTE: the <code>using MacroTools</code> and call to <code>MacroTools.prettify</code> is not necessary and is only used here to clean up the output so it is easier to read.</p><pre><code class="language-julia hljs">julia&gt; using MacroTools

julia&gt; macroexpand(:(@def_sim Simulation (T =&gt; Float64,) struct Observation{T&lt;:Number}
           c::T
           k::T
           i_z::Int
       end
       )) |&gt; MacroTools.prettify
quote
    struct Simulation{prairiedog, T &lt;: Number}
        c::Array{T, prairiedog}
        k::Array{T, prairiedog}
        i_z::Array{Int, prairiedog}
    end
    function Simulation{prairiedog}(sz::NTuple{prairiedog, Int})
        c = Array{Float64, prairiedog}(sz)
        k = Array{Float64, prairiedog}(sz)
        i_z = Array{Int, prairiedog}(sz)
        Simulation(c, k, i_z)
    end
    struct Observation{T &lt;: Number}
        c::T
        k::T
        i_z::Int
    end
    Base.endof(sim::Simulation) = length(sim.c)
    Base.length(sim::Simulation) = endof(sim)
    Base.start(sim::Simulation) = 1
    Base.next(sim::Simulation, ix::Int) = (sim[ix], ix + 1)
    Base.done(sim::Simulation, ix::Int) = ix &gt;= length(sim)
    function Base.getindex(sim::Simulation, ix::Int)
        $(Expr(:boundscheck, true))
        if ix &gt; length(sim)
            throw(BoundsError(&quot;$(length(sim))-element Simulation at index $(ix)&quot;))
        end
        $(Expr(:boundscheck, :pop))
        $(Expr(:inbounds, true))
        out = Observation(sim.c[ix], sim.k[ix], sim.i_z[ix])
        $(Expr(:inbounds, :pop))
        return out
    end
end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantEcon/QuantEcon.jl/blob/b686df7a6cf4c8a71a85fdeaf5add9cf27259e31/src/modeltools/types.jl#L1-L88">source</a></section></details></article><h2 id="Internal"><a class="docs-heading-anchor" href="#Internal">Internal</a><a id="Internal-1"></a><a class="docs-heading-anchor-permalink" href="#Internal" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="QuantEcon.DPSolveResult"><a class="docstring-binding" href="#QuantEcon.DPSolveResult"><code>QuantEcon.DPSolveResult</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">DPSolveResult</code></pre><p>Object for retaining results and associated metadata after solving the model.</p><p><strong>Fields</strong></p><ul><li><code>v::Vector{Tval}</code>: Value function vector.</li><li><code>Tv::Array{Tval}</code>: Temporary value function array.</li><li><code>num_iter::Int</code>: Number of iterations.</li><li><code>sigma::Array{Int,1}</code>: Policy function vector.</li><li><code>mc::MarkovChain</code>: Controlled Markov chain.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantEcon/QuantEcon.jl/blob/b686df7a6cf4c8a71a85fdeaf5add9cf27259e31/src/markov/ddp.jl#L256-L269">source</a></section></details></article><article><details class="docstring" open="true"><summary id="QuantEcon.LCPResult"><a class="docstring-binding" href="#QuantEcon.LCPResult"><code>QuantEcon.LCPResult</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">LCPResult</code></pre><p>Struct containing the result from <code>lcp_lemke</code>.</p><p><strong>Fields</strong></p><ul><li><code>z::Vector</code>: Solution vector.</li><li><code>success::Bool</code>: True if the algorithm succeeded in finding a solution.</li><li><code>status::Int</code>: An integer representing the exit status of the result:<ul><li>0: Solution found successfully</li><li>1: Iteration limit reached</li><li>2: Secondary ray termination</li></ul></li><li><code>num_iter::Int</code>: The number of iterations performed.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantEcon/QuantEcon.jl/blob/b686df7a6cf4c8a71a85fdeaf5add9cf27259e31/src/lcp_lemke.jl#L27-L41">source</a></section></details></article><article><details class="docstring" open="true"><summary id="QuantEcon.PivOptions"><a class="docstring-binding" href="#QuantEcon.PivOptions"><code>QuantEcon.PivOptions</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">PivOptions</code></pre><p>Struct to hold tolerance values for pivoting.</p><p><strong>Fields</strong></p><ul><li><code>tol_piv::Float64</code>: Pivot tolerance (default=1.0e-7).</li><li><code>tol_ratio_diff::Float64</code>: Tolerance used in the lexicographic pivoting (default=1.0e-13).</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantEcon/QuantEcon.jl/blob/b686df7a6cf4c8a71a85fdeaf5add9cf27259e31/src/lcp_lemke.jl#L10-L20">source</a></section></details></article><article><details class="docstring" open="true"><summary id="QuantEcon.VAREstimationMethod"><a class="docstring-binding" href="#QuantEcon.VAREstimationMethod"><code>QuantEcon.VAREstimationMethod</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">VAREstimationMethod</code></pre><p>Types specifying the method for <code>discrete_var</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantEcon/QuantEcon.jl/blob/b686df7a6cf4c8a71a85fdeaf5add9cf27259e31/src/markov/markov_approx.jl#L231">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.:*-Union{Tuple{T}, Tuple{AbstractArray{T, 3}, AbstractVector}} where T"><a class="docstring-binding" href="#Base.:*-Union{Tuple{T}, Tuple{AbstractArray{T, 3}, AbstractVector}} where T"><code>Base.:*</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">*(A, v)</code></pre><p>Define matrix multiplication between 3-dimensional matrix and a vector.</p><p>Matrix multiplication over the last dimension of <span>$A$</span>.</p><p><strong>Arguments</strong></p><ul><li><code>A::AbstractArray{T,3}</code>: 3-dimensional array.</li><li><code>v::AbstractVector</code>: Vector.</li></ul><p><strong>Returns</strong></p><ul><li><code>result::AbstractArray</code>: Result of matrix multiplication.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantEcon/QuantEcon.jl/blob/b686df7a6cf4c8a71a85fdeaf5add9cf27259e31/src/markov/ddp.jl#L952">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.rand-Tuple{DiscreteRV, Int64}"><a class="docstring-binding" href="#Base.rand-Tuple{DiscreteRV, Int64}"><code>Base.rand</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">rand(d, k)</code></pre><p>Make multiple draws from the discrete distribution represented by a <code>DiscreteRV</code> instance.</p><p><strong>Arguments</strong></p><ul><li><code>d::DiscreteRV</code>: The <code>DiscreteRV</code> type representing the distribution.</li><li><code>k::Int</code>: Number of draws to make.</li></ul><p><strong>Returns</strong></p><ul><li><code>out::Vector{Int}</code>: <code>k</code> draws from <code>d</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantEcon/QuantEcon.jl/blob/b686df7a6cf4c8a71a85fdeaf5add9cf27259e31/src/discrete_rv.jl#L63-L77">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.rand-Tuple{DiscreteRV}"><a class="docstring-binding" href="#Base.rand-Tuple{DiscreteRV}"><code>Base.rand</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">rand(d)</code></pre><p>Make a single draw from the discrete distribution.</p><p><strong>Arguments</strong></p><ul><li><code>d::DiscreteRV</code>: The <code>DiscreteRV</code> type representing the distribution.</li></ul><p><strong>Returns</strong></p><ul><li><code>out::Int</code>: One draw from the discrete distribution.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantEcon/QuantEcon.jl/blob/b686df7a6cf4c8a71a85fdeaf5add9cf27259e31/src/discrete_rv.jl#L48-L60">source</a></section></details></article><article><details class="docstring" open="true"><summary id="QuantEcon._compute_sequence-Union{Tuple{T}, Tuple{LQ, T, Any}} where T"><a class="docstring-binding" href="#QuantEcon._compute_sequence-Union{Tuple{T}, Tuple{LQ, T, Any}} where T"><code>QuantEcon._compute_sequence</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Private method implementing <code>compute_sequence</code> when state is a scalar.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantEcon/QuantEcon.jl/blob/b686df7a6cf4c8a71a85fdeaf5add9cf27259e31/src/lqcontrol.jl#L260-L262">source</a></section></details></article><article><details class="docstring" open="true"><summary id="QuantEcon._compute_sequence-Union{Tuple{T}, Tuple{LQ, Vector{T}, Any}} where T"><a class="docstring-binding" href="#QuantEcon._compute_sequence-Union{Tuple{T}, Tuple{LQ, Vector{T}, Any}} where T"><code>QuantEcon._compute_sequence</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Private method implementing <code>compute_sequence</code> when state is a vector.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantEcon/QuantEcon.jl/blob/b686df7a6cf4c8a71a85fdeaf5add9cf27259e31/src/lqcontrol.jl#L283-L285">source</a></section></details></article><article><details class="docstring" open="true"><summary id="QuantEcon._generate_a_indptr!-Tuple{Int64, AbstractVector, AbstractVector}"><a class="docstring-binding" href="#QuantEcon._generate_a_indptr!-Tuple{Int64, AbstractVector, AbstractVector}"><code>QuantEcon._generate_a_indptr!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_generate_a_indptr!(num_states, s_indices, out)</code></pre><p>Generate <code>a_indptr</code>; stored in <code>out</code>. <code>s_indices</code> is assumed to be in sorted order.</p><p><strong>Arguments</strong></p><ul><li><code>num_states::Integer</code>: Number of states.</li><li><code>s_indices::AbstractVector{T}</code>: State indices vector (must be sorted).</li><li><code>out::AbstractVector{T}</code>: Output vector with length = <code>num_states</code> + 1.</li></ul><p><strong>Returns</strong></p><ul><li><code>out::AbstractVector{T}</code>: Action index pointers vector.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantEcon/QuantEcon.jl/blob/b686df7a6cf4c8a71a85fdeaf5add9cf27259e31/src/markov/ddp.jl#L906-L922">source</a></section></details></article><article><details class="docstring" open="true"><summary id="QuantEcon._get_solution!-Union{Tuple{T}, Tuple{Vector{T}, Matrix{T}, Vector{&lt;:Integer}}} where T"><a class="docstring-binding" href="#QuantEcon._get_solution!-Union{Tuple{T}, Tuple{Vector{T}, Matrix{T}, Vector{&lt;:Integer}}} where T"><code>QuantEcon._get_solution!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_get_solution!(z, tableau, basis)</code></pre><p>Fetch the solution from <code>tableau</code> and <code>basis</code>.</p><p><strong>Arguments</strong></p><ul><li><code>z::Vector{T}</code>: Empty vector of size <code>(n,)</code> to store the solution. Modified in place.</li><li><code>tableau::Matrix{T}</code>: Matrix of size <code>(n, 2*n+2)</code> containing the terminal tableau.</li><li><code>basis::Vector{&lt;:Integer}</code>: Vector of size <code>(n,)</code> containing the terminal basis.</li></ul><p><strong>Returns</strong></p><ul><li><code>z</code>: Modified vector storing the solution.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantEcon/QuantEcon.jl/blob/b686df7a6cf4c8a71a85fdeaf5add9cf27259e31/src/lcp_lemke.jl#L304-L321">source</a></section></details></article><article><details class="docstring" open="true"><summary id="QuantEcon._has_sorted_sa_indices-Tuple{AbstractVector, AbstractVector}"><a class="docstring-binding" href="#QuantEcon._has_sorted_sa_indices-Tuple{AbstractVector, AbstractVector}"><code>QuantEcon._has_sorted_sa_indices</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_has_sorted_sa_indices(s_indices, a_indices)</code></pre><p>Check whether <code>s_indices</code> and <code>a_indices</code> are sorted in lexicographic order.</p><p><strong>Arguments</strong></p><ul><li><code>s_indices::AbstractVector</code>: State indices vector.</li><li><code>a_indices::AbstractVector</code>: Action indices vector.</li></ul><p><strong>Returns</strong></p><ul><li><code>result::Bool</code>: Whether <code>s_indices</code> and <code>a_indices</code> are sorted.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantEcon/QuantEcon.jl/blob/b686df7a6cf4c8a71a85fdeaf5add9cf27259e31/src/markov/ddp.jl#L874-L888">source</a></section></details></article><article><details class="docstring" open="true"><summary id="QuantEcon._initialize_tableau!-Union{Tuple{T}, Tuple{Matrix{T}, Vector{&lt;:Integer}, AbstractMatrix, AbstractVector, AbstractVector}} where T"><a class="docstring-binding" href="#QuantEcon._initialize_tableau!-Union{Tuple{T}, Tuple{Matrix{T}, Vector{&lt;:Integer}, AbstractMatrix, AbstractVector, AbstractVector}} where T"><code>QuantEcon._initialize_tableau!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_initialize_tableau!(tableau, basis, M, q, d)</code></pre><p>Initialize the <code>tableau</code> and <code>basis</code> arrays in place.</p><p>With covering vector <span>$d$</span> and artificial variable <span>$z0$</span>, the LCP is written as</p><p><span>$q = w - M z - d z0$</span></p><p>where the variables are ordered as <span>$(w, z, z0)$</span>. Thus, <code>tableau[:, 1:n]</code> stores <span>$I$</span>, <code>tableau[:, n+1:2n]</code> stores <span>$-M$</span>, <code>tableau[:, 2n+1]</code> stores <span>$-d$</span>, and <code>tableau[:, end]</code> stores <span>$q$</span>, while <code>basis</code> stores 1, ..., n (variables <span>$w$</span>).</p><p><strong>Arguments</strong></p><ul><li><code>tableau::Matrix{T}</code>: Empty matrix of size <code>(n, 2n+2)</code> to store the tableau. Modified in place.</li><li><code>basis::Vector{&lt;:Integer}</code>: Empty vector of size <code>(n,)</code> to store the basic variables. Modified in place.</li><li><code>M::AbstractMatrix</code>: Matrix of size <code>(n, n)</code>.</li><li><code>q::AbstractVector</code>: Vector of size <code>(n,)</code>.</li><li><code>d::AbstractVector</code>: Vector of size <code>(n,)</code>.</li></ul><p><strong>Returns</strong></p><ul><li><code>tableau, basis</code>: Initialized tableau and basis.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantEcon/QuantEcon.jl/blob/b686df7a6cf4c8a71a85fdeaf5add9cf27259e31/src/lcp_lemke.jl#L237-L265">source</a></section></details></article><article><details class="docstring" open="true"><summary id="QuantEcon._lex_min_ratio_test!-Tuple{AbstractMatrix, Integer, Integer, AbstractVector{&lt;:Integer}}"><a class="docstring-binding" href="#QuantEcon._lex_min_ratio_test!-Tuple{AbstractMatrix, Integer, Integer, AbstractVector{&lt;:Integer}}"><code>QuantEcon._lex_min_ratio_test!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_lex_min_ratio_test!(tableau, pivot, slack_start, argmins;
                     tol_piv=1.0e-10, tol_ratio_diff=1.0e-15)</code></pre><p>Perform the lexico-minimum ratio test.</p><p><strong>Arguments</strong></p><ul><li><code>tableau::AbstractMatrix</code>: Array containing the tableau.</li><li><code>pivot::Integer</code>: Pivot column index.</li><li><code>slack_start::Integer</code>: First column index for slack variables (assumed to form an identity over columns <code>slack_start : slack_start + nrows - 1</code>).</li><li><code>argmins::AbstractVector{&lt;:Integer}</code>: Empty array used to store the row indices. Its length must be no smaller than the number of the rows of <code>tableau</code>.</li><li><code>tol_piv::Real(1.0e-10)</code>: Pivot tolerance below which a number is considered to be nonpositive.</li><li><code>tol_ratio_diff::Real(1.0e-15)</code>: Tolerance to determine a tie between ratio values.</li></ul><p><strong>Returns</strong></p><ul><li><code>found::Bool</code>: <code>false</code> if there is no positive entry in the pivot column.</li><li><code>row_min::Int</code>: Index of the row with the lexico-minimum ratio.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantEcon/QuantEcon.jl/blob/b686df7a6cf4c8a71a85fdeaf5add9cf27259e31/src/pivoting.jl#L123-L147">source</a></section></details></article><article><details class="docstring" open="true"><summary id="QuantEcon._min_ratio_test_no_tie_breaking!-Union{Tuple{T}, Tuple{AbstractMatrix{T}, Integer, Integer, AbstractVector{&lt;:Integer}, Integer, Real, Real}} where T"><a class="docstring-binding" href="#QuantEcon._min_ratio_test_no_tie_breaking!-Union{Tuple{T}, Tuple{AbstractMatrix{T}, Integer, Integer, AbstractVector{&lt;:Integer}, Integer, Real, Real}} where T"><code>QuantEcon._min_ratio_test_no_tie_breaking!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_min_ratio_test_no_tie_breaking!(tableau, pivot, test_col,
                                 argmins, num_candidates,
                                 tol_piv, tol_ratio_diff)</code></pre><p>Perform the minimum ratio test, without tie breaking, for the candidate rows in <code>argmins[1:num_candidates]</code>. Return the number <code>num_argmins</code> of the rows minimizing the ratio and store their indices in <code>argmins[1:num_argmins]</code>.</p><p><strong>Arguments</strong></p><ul><li><code>tableau::AbstractMatrix</code>: Array containing the tableau.</li><li><code>pivot::Integer</code>: Pivot column index used as denominator.</li><li><code>test_col::Integer</code>: Index of the column used in the test.</li><li><code>argmins::AbstractVector{&lt;:Integer}</code>: Array containing the indices of the candidate rows. Modified in place to store the indices of minimizing rows.</li><li><code>num_candidates::Integer</code>: Number of candidate rows in <code>argmins</code>.</li><li><code>tol_piv::Real</code>: Pivot tolerance below which a number is considered to be nonpositive.</li><li><code>tol_ratio_diff::Real</code>: Tolerance to determine a tie between ratio values.</li></ul><p><strong>Returns</strong></p><ul><li><code>num_argmins::Int</code>: Number of minimizing rows; their indices occupy <code>argmins[1:num_argmins]</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantEcon/QuantEcon.jl/blob/b686df7a6cf4c8a71a85fdeaf5add9cf27259e31/src/pivoting.jl#L65-L90">source</a></section></details></article><article><details class="docstring" open="true"><summary id="QuantEcon._pivoting!-Union{Tuple{T}, Tuple{AbstractMatrix{T}, Integer, Integer, Vector{T}}} where T&lt;:AbstractFloat"><a class="docstring-binding" href="#QuantEcon._pivoting!-Union{Tuple{T}, Tuple{AbstractMatrix{T}, Integer, Integer, Vector{T}}} where T&lt;:AbstractFloat"><code>QuantEcon._pivoting!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_pivoting!(tableau, pivot_col, pivot_row, col_buf)</code></pre><p>Perform a pivoting step. Modify <code>tableau</code> in place.</p><p><strong>Arguments</strong></p><ul><li><code>tableau::AbstractMatrix</code>: Array containing the tableau.</li><li><code>pivot_col::Integer</code>: Pivot column index.</li><li><code>pivot_row::Integer</code>: Pivot row index.</li><li><code>col_buf::Vector</code>: Workspace vector to hold a copy of the pivot column, of type <code>eltype(tableau)</code> and length <code>size(tableau, 1)</code>. Pass, for example, <code>col_buf = similar(tableau, size(tableau, 1))</code>.</li></ul><p><strong>Returns</strong></p><ul><li><code>tableau::AbstractMatrix</code>: View to <code>tableau</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantEcon/QuantEcon.jl/blob/b686df7a6cf4c8a71a85fdeaf5add9cf27259e31/src/pivoting.jl#L12-L29">source</a></section></details></article><article><details class="docstring" open="true"><summary id="QuantEcon._random_stochastic_matrix-Tuple{Random.AbstractRNG, Integer, Integer}"><a class="docstring-binding" href="#QuantEcon._random_stochastic_matrix-Tuple{Random.AbstractRNG, Integer, Integer}"><code>QuantEcon._random_stochastic_matrix</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_random_stochastic_matrix([rng], n, m; k=n)</code></pre><p>Generate a &quot;non-square column stochastic matrix&quot; of shape <code>(n, m)</code>, which contains as columns <code>m</code> probability vectors of length <code>n</code> with <code>k</code> nonzero entries.</p><p><strong>Arguments</strong></p><ul><li><code>rng::AbstractRNG=GLOBAL_RNG</code>: Random number generator.</li><li><code>n::Integer</code>: Number of states.</li><li><code>m::Integer</code>: Number of probability vectors.</li><li><code>;k::Integer(n)</code>: Number of nonzero entries in each column of the matrix. Set to <code>n</code> if none specified.</li></ul><p><strong>Returns</strong></p><ul><li><code>p::Array</code>: Array of shape <code>(n, m)</code> containing <code>m</code> probability vectors of length <code>n</code> as columns.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantEcon/QuantEcon.jl/blob/b686df7a6cf4c8a71a85fdeaf5add9cf27259e31/src/markov/random_mc.jl#L98-L116">source</a></section></details></article><article><details class="docstring" open="true"><summary id="QuantEcon._solve!-Tuple{DiscreteDP, QuantEcon.DPSolveResult{MPFI}, Integer, Real, Integer}"><a class="docstring-binding" href="#QuantEcon._solve!-Tuple{DiscreteDP, QuantEcon.DPSolveResult{MPFI}, Integer, Real, Integer}"><code>QuantEcon._solve!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_solve!(ddp, ddpr, max_iter, epsilon, k)</code></pre><p>Modified Policy Function Iteration.</p><p><strong>Arguments</strong></p><ul><li><code>ddp::DiscreteDP</code>: Object that contains the model parameters.</li><li><code>ddpr::DPSolveResult{MPFI}</code>: Object that contains result variables.</li><li><code>max_iter::Integer</code>: Maximum number of iterations.</li><li><code>epsilon::Real</code>: Value for epsilon-optimality.</li><li><code>k::Integer</code>: Number of iterations for partial policy evaluation.</li></ul><p><strong>Returns</strong></p><ul><li><code>ddpr::DPSolveResult{MPFI}</code>: Updated result object.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantEcon/QuantEcon.jl/blob/b686df7a6cf4c8a71a85fdeaf5add9cf27259e31/src/markov/ddp.jl#L1078-L1095">source</a></section></details></article><article><details class="docstring" open="true"><summary id="QuantEcon._solve!-Tuple{DiscreteDP, QuantEcon.DPSolveResult{PFI}, Integer, Real, Integer}"><a class="docstring-binding" href="#QuantEcon._solve!-Tuple{DiscreteDP, QuantEcon.DPSolveResult{PFI}, Integer, Real, Integer}"><code>QuantEcon._solve!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_solve!(ddp, ddpr, max_iter, epsilon, k)</code></pre><p>Policy Function Iteration.</p><p>NOTE: The epsilon is ignored in this method. It is only here so dispatch can       go from <code>solve(::DiscreteDP, ::Type{Algo})</code> to any of the algorithms.       See <code>solve</code> for further details.</p><p><strong>Arguments</strong></p><ul><li><code>ddp::DiscreteDP</code>: Object that contains the model parameters.</li><li><code>ddpr::DPSolveResult{PFI}</code>: Object that contains result variables.</li><li><code>max_iter::Integer</code>: Maximum number of iterations.</li><li><code>epsilon::Real</code>: Value for epsilon-optimality (not used for PFI).</li><li><code>k::Integer</code>: Number of iterations (not used for PFI).</li></ul><p><strong>Returns</strong></p><ul><li><code>ddpr::DPSolveResult{PFI}</code>: Updated result object.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantEcon/QuantEcon.jl/blob/b686df7a6cf4c8a71a85fdeaf5add9cf27259e31/src/markov/ddp.jl#L1028-L1049">source</a></section></details></article><article><details class="docstring" open="true"><summary id="QuantEcon._solve!-Tuple{DiscreteDP, QuantEcon.DPSolveResult{VFI}, Integer, Real, Integer}"><a class="docstring-binding" href="#QuantEcon._solve!-Tuple{DiscreteDP, QuantEcon.DPSolveResult{VFI}, Integer, Real, Integer}"><code>QuantEcon._solve!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_solve!(ddp, ddpr, max_iter, epsilon, k)</code></pre><p>Implements Value Iteration.</p><p>NOTE: See <code>solve</code> for further details.</p><p><strong>Arguments</strong></p><ul><li><code>ddp::DiscreteDP</code>: Object that contains the model parameters.</li><li><code>ddpr::DPSolveResult{VFI}</code>: Object that contains result variables.</li><li><code>max_iter::Integer</code>: Maximum number of iterations.</li><li><code>epsilon::Real</code>: Value for epsilon-optimality.</li><li><code>k::Integer</code>: Number of iterations (not used for VFI).</li></ul><p><strong>Returns</strong></p><ul><li><code>ddpr::DPSolveResult{VFI}</code>: Updated result object.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantEcon/QuantEcon.jl/blob/b686df7a6cf4c8a71a85fdeaf5add9cf27259e31/src/markov/ddp.jl#L979-L998">source</a></section></details></article><article><details class="docstring" open="true"><summary id="QuantEcon.allcomb3-Tuple{AbstractMatrix}"><a class="docstring-binding" href="#QuantEcon.allcomb3-Tuple{AbstractMatrix}"><code>QuantEcon.allcomb3</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">allcomb3(A)</code></pre><p>Return combinations of each column of matrix <code>A</code>. It is simplifying <code>allcomb2</code> by using <code>gridmake</code> from QuantEcon.</p><p><strong>Arguments</strong></p><ul><li><code>A::AbstractMatrix</code>: <code>N x M</code> Matrix.</li></ul><p><strong>Returns</strong></p><ul><li><code>N^M x M</code> Matrix, combination of each row of <code>A</code>.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; allcomb3([1 4 7;
                 2 5 8;
                 3 6 9]) # numerical input
27×3 Array{Int64,2}:
 1  4  7
 1  4  8
 1  4  9
 1  5  7
 1  5  8
 1  5  9
 1  6  7
 1  6  8
 1  6  9
 2  4  7
 ⋮
 2  6  9
 3  4  7
 3  4  8
 3  4  9
 3  5  7
 3  5  8
 3  5  9
 3  6  7
 3  6  8
 3  6  9</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantEcon/QuantEcon.jl/blob/b686df7a6cf4c8a71a85fdeaf5add9cf27259e31/src/markov/markov_approx.jl#L653-L697">source</a></section></details></article><article><details class="docstring" open="true"><summary id="QuantEcon.construct_1D_grid-Tuple{AbstractMatrix, Integer, Integer, Real, Quantile}"><a class="docstring-binding" href="#QuantEcon.construct_1D_grid-Tuple{AbstractMatrix, Integer, Integer, Real, Quantile}"><code>QuantEcon.construct_1D_grid</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">construct_1D_grid(Sigma, Nm, M, n_sigmas, method)</code></pre><p>Construct one-dimensional quantile grid of states.</p><p><strong>Argument</strong></p><ul><li><code>Sigma::AbstractMatrix</code>: Variance-covariance matrix of the standardized process.</li><li><code>Nm::Integer</code>: Number of grid points.</li><li><code>M::Integer</code>: Number of variables (<code>M=1</code> corresponds to AR(1)).</li><li><code>n_sigmas::Real</code>: Number of standard error determining end points of grid.</li><li><code>method::Quantile</code>: Method for grid making.</li></ul><p><strong>Return</strong></p><ul><li><code>y1D</code>: <code>M x Nm</code> matrix of variable grid.</li><li><code>y1Dbounds</code>: Bounds of each grid bin.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantEcon/QuantEcon.jl/blob/b686df7a6cf4c8a71a85fdeaf5add9cf27259e31/src/markov/markov_approx.jl#L595-L613">source</a></section></details></article><article><details class="docstring" open="true"><summary id="QuantEcon.construct_1D_grid-Tuple{Union{Array{T}, T} where T, Integer, Integer, Real, Quadrature}"><a class="docstring-binding" href="#QuantEcon.construct_1D_grid-Tuple{Union{Array{T}, T} where T, Integer, Integer, Real, Quadrature}"><code>QuantEcon.construct_1D_grid</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">construct_1D_grid(Sigma, Nm, M, n_sigmas, method)</code></pre><p>Construct one-dimensional quadrature grid of states.</p><p><strong>Argument</strong></p><ul><li><code>::ScalarOrArray</code>: Not used.</li><li><code>Nm::Integer</code>: Number of grid points.</li><li><code>M::Integer</code>: Number of variables (<code>M=1</code> corresponds to AR(1)).</li><li><code>n_sigmas::Real</code>: Not used.</li><li><code>method::Quadrature</code>: Method for grid making.</li></ul><p><strong>Return</strong></p><ul><li><code>y1D</code>: <code>M x Nm</code> matrix of variable grid.</li><li><code>weights</code>: Weights on each grid.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantEcon/QuantEcon.jl/blob/b686df7a6cf4c8a71a85fdeaf5add9cf27259e31/src/markov/markov_approx.jl#L627-L645">source</a></section></details></article><article><details class="docstring" open="true"><summary id="QuantEcon.construct_1D_grid-Tuple{Union{Real, AbstractMatrix}, Integer, Integer, Real, Even}"><a class="docstring-binding" href="#QuantEcon.construct_1D_grid-Tuple{Union{Real, AbstractMatrix}, Integer, Integer, Real, Even}"><code>QuantEcon.construct_1D_grid</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">construct_1D_grid(Sigma, Nm, M, n_sigmas, method)</code></pre><p>Construct one-dimensional evenly spaced grid of states.</p><p><strong>Argument</strong></p><ul><li><code>Sigma::ScalarOrArray</code>: Variance-covariance matrix of the standardized process.</li><li><code>Nm::Integer</code>: Number of grid points.</li><li><code>M::Integer</code>: Number of variables (<code>M=1</code> corresponds to AR(1)).</li><li><code>n_sigmas::Real</code>: Number of standard error determining end points of grid.</li><li><code>method::Even</code>: Method for grid making.</li></ul><p><strong>Return</strong></p><ul><li><code>y1D</code>: <code>M x Nm</code> matrix of variable grid.</li><li><code>nothing</code>: <code>nothing</code> of type <code>Nothing</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantEcon/QuantEcon.jl/blob/b686df7a6cf4c8a71a85fdeaf5add9cf27259e31/src/markov/markov_approx.jl#L568-L586">source</a></section></details></article><article><details class="docstring" open="true"><summary id="QuantEcon.construct_prior_guess-Tuple{AbstractVector, Integer, AbstractMatrix, AbstractMatrix, Quantile}"><a class="docstring-binding" href="#QuantEcon.construct_prior_guess-Tuple{AbstractVector, Integer, AbstractMatrix, AbstractMatrix, Quantile}"><code>QuantEcon.construct_prior_guess</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">construct_prior_guess(cond_mean, Nm, y1D, y1Dbounds, method)</code></pre><p>Construct prior guess for quantile grid method.</p><p><strong>Arguments</strong></p><ul><li><code>cond_mean::AbstractVector</code>: Conditional mean of each variable.</li><li><code>Nm::Integer</code>: Number of grid points.</li><li><code>::AbstractMatrix</code>: Grid of variable.</li><li><code>y1Dbounds::AbstractMatrix</code>: Bounds of each grid bin.</li><li><code>method::Quantile</code>: Method for grid making.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantEcon/QuantEcon.jl/blob/b686df7a6cf4c8a71a85fdeaf5add9cf27259e31/src/markov/markov_approx.jl#L532-L545">source</a></section></details></article><article><details class="docstring" open="true"><summary id="QuantEcon.construct_prior_guess-Tuple{AbstractVector, Integer, AbstractMatrix, AbstractVector, Quadrature}"><a class="docstring-binding" href="#QuantEcon.construct_prior_guess-Tuple{AbstractVector, Integer, AbstractMatrix, AbstractVector, Quadrature}"><code>QuantEcon.construct_prior_guess</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">construct_prior_guess(cond_mean, Nm, y1D, weights, method)</code></pre><p>Construct prior guess for quadrature grid method.</p><p><strong>Arguments</strong></p><ul><li><code>cond_mean::AbstractVector</code>: Conditional mean of each variable.</li><li><code>Nm::Integer</code>: Number of grid points.</li><li><code>y1D::AbstractMatrix</code>: Grid of variable.</li><li><code>weights::AbstractVector</code>: Weights of grid <code>y1D</code>.</li><li><code>method::Quadrature</code>: Method for grid making.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantEcon/QuantEcon.jl/blob/b686df7a6cf4c8a71a85fdeaf5add9cf27259e31/src/markov/markov_approx.jl#L551-L564">source</a></section></details></article><article><details class="docstring" open="true"><summary id="QuantEcon.construct_prior_guess-Tuple{AbstractVector, Integer, AbstractMatrix, Nothing, Even}"><a class="docstring-binding" href="#QuantEcon.construct_prior_guess-Tuple{AbstractVector, Integer, AbstractMatrix, Nothing, Even}"><code>QuantEcon.construct_prior_guess</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">construct_prior_guess(cond_mean, Nm, y1D, nothing, method)</code></pre><p>Construct prior guess for evenly spaced grid method.</p><p><strong>Arguments</strong></p><ul><li><code>cond_mean::AbstractVector</code>: Conditional mean of each variable.</li><li><code>Nm::Integer</code>: Number of grid points.</li><li><code>y1D::AbstractMatrix</code>: Grid of variable.</li><li><code>::AbstractMatrix</code>: Bounds of each grid bin.</li><li><code>method::Even</code>: Method for grid making.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantEcon/QuantEcon.jl/blob/b686df7a6cf4c8a71a85fdeaf5add9cf27259e31/src/markov/markov_approx.jl#L514-L527">source</a></section></details></article><article><details class="docstring" open="true"><summary id="QuantEcon.discrete_approximation"><a class="docstring-binding" href="#QuantEcon.discrete_approximation"><code>QuantEcon.discrete_approximation</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">discrete_approximation(D, T, Tbar, q=ones(length(D))/length(D), lambda0=zeros(Tbar))</code></pre><p>Compute a discrete state approximation to a distribution with known moments, using the maximum entropy procedure proposed in Tanaka and Toda (2013).</p><p><strong>Arguments</strong></p><ul><li><code>D::AbstractVector</code>: Vector of grid points of length <code>N</code>. N is the number of points at which an approximation is to be constructed.</li><li><code>T::Function</code>: A function that accepts a single <code>AbstractVector</code> of length <code>N</code> and returns an <code>L x N</code> matrix of moments evaluated at each grid point, where L is the number of moments to be matched.</li><li><code>Tbar::AbstractVector</code>: Length <code>L</code> vector of moments of the underlying distribution which should be matched.</li></ul><p><strong>Optional</strong></p><ul><li><code>q::AbstractVector</code>: Length <code>N</code> vector of prior weights for each point in D. The default is for each point to have an equal weight.</li><li><code>lambda0::AbstractVector</code>: Length <code>L</code> vector of initial guesses for the dual problem variables. The default is a vector of zeros.</li></ul><p><strong>Returns</strong></p><ul><li><code>p</code>: (1 x N) vector of probabilities assigned to each grid point in <code>D</code>.</li><li><code>lambda_bar</code>: Length <code>L</code> vector of dual problem variables which solve the maximum entropy problem.</li><li><code>moment_error</code>: Vector of errors in moments (defined by moments of discretization minus actual moments) of length <code>L</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantEcon/QuantEcon.jl/blob/b686df7a6cf4c8a71a85fdeaf5add9cf27259e31/src/markov/markov_approx.jl#L701-L732">source</a></section></details></article><article><details class="docstring" open="true"><summary id="QuantEcon.entropy_grad!-Tuple{AbstractVector, AbstractVector, AbstractMatrix, AbstractVector, AbstractVector}"><a class="docstring-binding" href="#QuantEcon.entropy_grad!-Tuple{AbstractVector, AbstractVector, AbstractMatrix, AbstractVector, AbstractVector}"><code>QuantEcon.entropy_grad!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">entropy_grad!(grad, lambda, Tx, Tbar, q)</code></pre><p>Compute gradient of objective function.</p><p><strong>Returns</strong></p><ul><li><code>grad</code>: Length <code>L</code> gradient vector of the objective function evaluated at <code>lambda</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantEcon/QuantEcon.jl/blob/b686df7a6cf4c8a71a85fdeaf5add9cf27259e31/src/markov/markov_approx.jl#L837-L846">source</a></section></details></article><article><details class="docstring" open="true"><summary id="QuantEcon.entropy_hess!-Tuple{AbstractMatrix, AbstractVector, AbstractMatrix, AbstractVector, AbstractVector}"><a class="docstring-binding" href="#QuantEcon.entropy_hess!-Tuple{AbstractMatrix, AbstractVector, AbstractMatrix, AbstractVector, AbstractVector}"><code>QuantEcon.entropy_hess!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">entropy_hess!(hess, lambda, Tx, Tbar, q)</code></pre><p>Compute hessian of objective function.</p><p><strong>Returns</strong></p><ul><li><code>hess</code>: <code>L x L</code> hessian matrix of the objective function evaluated at <code>lambda</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantEcon/QuantEcon.jl/blob/b686df7a6cf4c8a71a85fdeaf5add9cf27259e31/src/markov/markov_approx.jl#L855-L864">source</a></section></details></article><article><details class="docstring" open="true"><summary id="QuantEcon.entropy_obj-Tuple{AbstractVector, AbstractMatrix, AbstractVector, AbstractVector}"><a class="docstring-binding" href="#QuantEcon.entropy_obj-Tuple{AbstractVector, AbstractMatrix, AbstractVector, AbstractVector}"><code>QuantEcon.entropy_obj</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">entropy_obj(lambda, Tx, Tbar, q)</code></pre><p>Compute the maximum entropy objective function used in <code>discrete_approximation</code>.</p><pre><code class="language-julia hljs">obj = entropy_obj(lambda, Tx, Tbar, q)</code></pre><p><strong>Arguments</strong></p><ul><li><code>lambda::AbstractVector</code>: Length <code>L</code> vector of values of the dual problem variables.</li><li><code>Tx::AbstractMatrix</code>: <code>L x N</code> matrix of moments evaluated at the grid points specified in discrete_approximation.</li><li><code>Tbar::AbstractVector</code>: Length <code>L</code> vector of moments of the underlying distribution which should be matched.</li><li><code>q::AbstractVector</code>: Length <code>N</code> vector of prior weights for each point in the grid.</li></ul><p><strong>Returns</strong></p><ul><li><code>obj</code>: Scalar value of objective function evaluated at <code>lambda</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantEcon/QuantEcon.jl/blob/b686df7a6cf4c8a71a85fdeaf5add9cf27259e31/src/markov/markov_approx.jl#L803-L827">source</a></section></details></article><article><details class="docstring" open="true"><summary id="QuantEcon.fix"><a class="docstring-binding" href="#QuantEcon.fix"><code>QuantEcon.fix</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">fix(x)</code></pre><p>Round <code>x</code> towards zero. For arrays there is a mutating version <code>fix!</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantEcon/QuantEcon.jl/blob/b686df7a6cf4c8a71a85fdeaf5add9cf27259e31/src/util.jl#L16-L20">source</a></section></details></article><article><details class="docstring" open="true"><summary id="QuantEcon.getZ-Tuple{Float64, Float64, Float64}"><a class="docstring-binding" href="#QuantEcon.getZ-Tuple{Float64, Float64, Float64}"><code>QuantEcon.getZ</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">getZ(R, gamma, BB)</code></pre><p>Simple method to return an element <span>$Z$</span> in the Riccati equation solver whose type is <code>Float64</code> (to be accepted by the <code>cond()</code> function).</p><p><strong>Arguments</strong></p><ul><li><code>R::Float64</code>: Input scalar.</li><li><code>gamma::Float64</code>: Parameter in the Riccati equation solver.</li><li><code>BB::Float64</code>: Result of <span>$B&#39; B$</span>.</li></ul><p><strong>Returns</strong></p><ul><li><code>::Float64</code>: Element <span>$Z$</span> in the Riccati equation solver.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantEcon/QuantEcon.jl/blob/b686df7a6cf4c8a71a85fdeaf5add9cf27259e31/src/matrix_eqn.jl#L184">source</a></section></details></article><article><details class="docstring" open="true"><summary id="QuantEcon.getZ-Tuple{Float64, Float64, Union{Matrix, Vector}}"><a class="docstring-binding" href="#QuantEcon.getZ-Tuple{Float64, Float64, Union{Matrix, Vector}}"><code>QuantEcon.getZ</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">getZ(R, gamma, BB)</code></pre><p>Simple method to return an element <span>$Z$</span> in the Riccati equation solver whose type is <code>Float64</code> (to be accepted by the <code>cond()</code> function).</p><p><strong>Arguments</strong></p><ul><li><code>R::Float64</code>: Input scalar.</li><li><code>gamma::Float64</code>: Parameter in the Riccati equation solver.</li><li><code>BB::Union{Vector, Matrix}</code>: Result of <span>$B&#39; B$</span>.</li></ul><p><strong>Returns</strong></p><ul><li><code>::Float64</code>: Element <span>$Z$</span> in the Riccati equation solver.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantEcon/QuantEcon.jl/blob/b686df7a6cf4c8a71a85fdeaf5add9cf27259e31/src/matrix_eqn.jl#L202">source</a></section></details></article><article><details class="docstring" open="true"><summary id="QuantEcon.getZ-Tuple{Matrix, Float64, Matrix}"><a class="docstring-binding" href="#QuantEcon.getZ-Tuple{Matrix, Float64, Matrix}"><code>QuantEcon.getZ</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">getZ(R, gamma, BB)</code></pre><p>Simple method to return an element <span>$Z$</span> in the Riccati equation solver whose type is Matrix (to be accepted by the <code>cond()</code> function).</p><p><strong>Arguments</strong></p><ul><li><code>R::Matrix</code>: Input matrix.</li><li><code>gamma::Float64</code>: Parameter in the Riccati equation solver.</li><li><code>BB::Matrix</code>: Result of <span>$B&#39; B$</span>.</li></ul><p><strong>Returns</strong></p><ul><li><code>::Matrix</code>: Element <span>$Z$</span> in the Riccati equation solver.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantEcon/QuantEcon.jl/blob/b686df7a6cf4c8a71a85fdeaf5add9cf27259e31/src/matrix_eqn.jl#L220">source</a></section></details></article><article><details class="docstring" open="true"><summary id="QuantEcon.go_backward-Tuple{Kalman, Vector, Matrix, Matrix, Vector, Matrix}"><a class="docstring-binding" href="#QuantEcon.go_backward-Tuple{Kalman, Vector, Matrix, Matrix, Vector, Matrix}"><code>QuantEcon.go_backward</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">go_backward(k, x_fi, sigma_fi, sigma_fo, x_s1, sigma_s1)</code></pre><p>Helper function for backward recursion in Kalman smoothing.</p><p><strong>Arguments</strong></p><ul><li><code>k::Kalman</code>: <code>Kalman</code> instance specifying the model.</li><li><code>x_fi::Vector</code>: Filtered mean of state for period <span>$t$</span>.</li><li><code>sigma_fi::Matrix</code>: Filtered covariance matrix of state for period <span>$t$</span>.</li><li><code>sigma_fo::Matrix</code>: Forecast of covariance matrix of state for period <span>$t+1$</span> conditional on period <span>$t$</span> observations.</li><li><code>x_s1::Vector</code>: Smoothed mean of state for period <span>$t+1$</span>.</li><li><code>sigma_s1::Matrix</code>: Smoothed covariance of state for period <span>$t+1$</span>.</li></ul><p><strong>Returns</strong></p><ul><li><code>x_s::Vector</code>: Smoothed mean of state for period <span>$t$</span>.</li><li><code>sigma_s::Matrix</code>: Smoothed covariance of state for period <span>$t$</span>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantEcon/QuantEcon.jl/blob/b686df7a6cf4c8a71a85fdeaf5add9cf27259e31/src/kalman.jl#L293-L312">source</a></section></details></article><article><details class="docstring" open="true"><summary id="QuantEcon.gth_solve!-Union{Tuple{Matrix{T}}, Tuple{T}} where T&lt;:Real"><a class="docstring-binding" href="#QuantEcon.gth_solve!-Union{Tuple{Matrix{T}}, Tuple{T}} where T&lt;:Real"><code>QuantEcon.gth_solve!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">gth_solve!(A)</code></pre><p>Same as <code>gth_solve</code>, but overwrite the input <code>A</code>, instead of creating a copy.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantEcon/QuantEcon.jl/blob/b686df7a6cf4c8a71a85fdeaf5add9cf27259e31/src/markov/mc_tools.jl#L120-L124">source</a></section></details></article><article><details class="docstring" open="true"><summary id="QuantEcon.log_likelihood-Tuple{Kalman, AbstractVector}"><a class="docstring-binding" href="#QuantEcon.log_likelihood-Tuple{Kalman, AbstractVector}"><code>QuantEcon.log_likelihood</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">log_likelihood(k, y)</code></pre><p>Computes log-likelihood of period <span>$t$</span>.</p><p><strong>Arguments</strong></p><ul><li><code>k::Kalman</code>: <code>Kalman</code> instance specifying the model. Current values must be the forecast for period <span>$t$</span> observation conditional on <span>$t-1$</span> observation.</li><li><code>y::AbstractVector</code>: Response observations at period <span>$t$</span>.</li></ul><p><strong>Returns</strong></p><ul><li><code>logL::Real</code>: Log-likelihood of observations at period <span>$t$</span>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantEcon/QuantEcon.jl/blob/b686df7a6cf4c8a71a85fdeaf5add9cf27259e31/src/kalman.jl#L193-L207">source</a></section></details></article><article><details class="docstring" open="true"><summary id="QuantEcon.min_var_trace-Tuple{AbstractMatrix}"><a class="docstring-binding" href="#QuantEcon.min_var_trace-Tuple{AbstractMatrix}"><code>QuantEcon.min_var_trace</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">min_var_trace(A)</code></pre><p>Find a unitary matrix <code>U</code> such that the diagonal components of <code>U&#39;AU</code> is as close to a multiple of identity matrix as possible.</p><p><strong>Arguments</strong></p><ul><li><code>A::AbstractMatrix</code>: Square matrix.</li></ul><p><strong>Returns</strong></p><ul><li><code>U</code>: Unitary matrix.</li><li><code>fval</code>: Minimum value.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantEcon/QuantEcon.jl/blob/b686df7a6cf4c8a71a85fdeaf5add9cf27259e31/src/markov/markov_approx.jl#L873">source</a></section></details></article><article><details class="docstring" open="true"><summary id="QuantEcon.polynomial_moment-Tuple{AbstractVector, Real, Real, Integer}"><a class="docstring-binding" href="#QuantEcon.polynomial_moment-Tuple{AbstractVector, Real, Real, Integer}"><code>QuantEcon.polynomial_moment</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">polynomial_moment(X, mu, scaling_factor, n_moments)</code></pre><p>Compute the moment defining function used in discrete_approximation.</p><p><strong>Arguments</strong></p><ul><li><code>X::AbstractVector</code>: Length <code>N</code> vector of grid points.</li><li><code>mu::Real</code>: Location parameter (conditional mean).</li><li><code>scaling_factor::Real</code>: Scaling factor for numerical stability. (typically largest grid point).</li><li><code>n_moments::Integer</code>: Number of polynomial moments.</li></ul><p><strong>Return</strong></p><ul><li><code>T</code>: Moment defining function used in <code>discrete_approximation</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantEcon/QuantEcon.jl/blob/b686df7a6cf4c8a71a85fdeaf5add9cf27259e31/src/markov/markov_approx.jl#L777-L794">source</a></section></details></article><article><details class="docstring" open="true"><summary id="QuantEcon.random_probvec-Tuple{Random.AbstractRNG, Integer, Integer}"><a class="docstring-binding" href="#QuantEcon.random_probvec-Tuple{Random.AbstractRNG, Integer, Integer}"><code>QuantEcon.random_probvec</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">random_probvec([rng], k[, m])</code></pre><p>Return <code>m</code> randomly sampled probability vectors of size <code>k</code>.</p><p><strong>Arguments</strong></p><ul><li><code>rng::AbstractRNG=GLOBAL_RNG</code>: Random number generator.</li><li><code>k::Integer</code>: Size of each probability vector.</li><li><code>m::Integer</code>: Number of probability vectors.</li></ul><p><strong>Returns</strong></p><ul><li><code>a::Array</code>: Matrix of shape <code>(k, m)</code>, or Vector of shape <code>(k,)</code> if <code>m</code> is not specified, containing probability vector(s) as column(s).</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantEcon/QuantEcon.jl/blob/b686df7a6cf4c8a71a85fdeaf5add9cf27259e31/src/markov/random_mc.jl#L194-L209">source</a></section></details></article><article><details class="docstring" open="true"><summary id="QuantEcon.s_wise_max!-NTuple{4, AbstractVector}"><a class="docstring-binding" href="#QuantEcon.s_wise_max!-NTuple{4, AbstractVector}"><code>QuantEcon.s_wise_max!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">s_wise_max!(a_indices, a_indptr, vals, out)</code></pre><p>Populate <code>out</code> with  <code>max_a vals(s, a)</code>,  where <code>vals</code> is represented as a <code>Vector</code> of size <code>(num_sa_pairs,)</code>.</p><p><strong>Arguments</strong></p><ul><li><code>a_indices::AbstractVector</code>: Action indices vector.</li><li><code>a_indptr::AbstractVector</code>: Action index pointers vector.</li><li><code>vals::AbstractVector</code>: Vector of values of size <code>(num_sa_pairs,)</code>.</li><li><code>out::AbstractVector</code>: Output vector to be populated with maximum values.</li></ul><p><strong>Returns</strong></p><ul><li><code>out::AbstractVector</code>: Vector of maximum values across actions for each state.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantEcon/QuantEcon.jl/blob/b686df7a6cf4c8a71a85fdeaf5add9cf27259e31/src/markov/ddp.jl#L793-L810">source</a></section></details></article><article><details class="docstring" open="true"><summary id="QuantEcon.s_wise_max!-NTuple{5, AbstractVector}"><a class="docstring-binding" href="#QuantEcon.s_wise_max!-NTuple{5, AbstractVector}"><code>QuantEcon.s_wise_max!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">s_wise_max!(a_indices, a_indptr, vals, out, out_argmax)</code></pre><p>Populate <code>out</code> with  <code>max_a vals(s, a)</code>,  where <code>vals</code> is represented as a <code>Vector</code> of size <code>(num_sa_pairs,)</code>.</p><p>Also fills <code>out_argmax</code> with the cartesian index associated with the <code>argmax</code> in each row.</p><p><strong>Arguments</strong></p><ul><li><code>a_indices::AbstractVector</code>: Action indices vector.</li><li><code>a_indptr::AbstractVector</code>: Action index pointers vector.</li><li><code>vals::AbstractVector</code>: Vector of values of size <code>(num_sa_pairs,)</code>.</li><li><code>out::AbstractVector</code>: Output vector to be populated with maximum values.</li><li><code>out_argmax::AbstractVector</code>: Output vector to be populated with argmax indices.</li></ul><p><strong>Returns</strong></p><ul><li><code>out::AbstractVector</code>: Vector of maximum values across actions for each state.</li><li><code>out_argmax::AbstractVector</code>: Vector of argmax indices for each state.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantEcon/QuantEcon.jl/blob/b686df7a6cf4c8a71a85fdeaf5add9cf27259e31/src/markov/ddp.jl#L830-L852">source</a></section></details></article><article><details class="docstring" open="true"><summary id="QuantEcon.s_wise_max!-Tuple{AbstractMatrix, AbstractVector, AbstractVector}"><a class="docstring-binding" href="#QuantEcon.s_wise_max!-Tuple{AbstractMatrix, AbstractVector, AbstractVector}"><code>QuantEcon.s_wise_max!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">s_wise_max!(vals, out, out_argmax)</code></pre><p>Populate <code>out</code> with  <code>max_a vals(s, a)</code>,  where <code>vals</code> is represented as a <code>AbstractMatrix</code> of size <code>(num_states, num_actions)</code>.</p><p>Also fills <code>out_argmax</code> with the column number associated with the <code>argmax</code> in each row.</p><p><strong>Arguments</strong></p><ul><li><code>vals::AbstractMatrix</code>: Matrix of values of size <code>(num_states, num_actions)</code>.</li><li><code>out::AbstractVector</code>: Output vector to be populated with maximum values.</li><li><code>out_argmax::AbstractVector</code>: Output vector to be populated with argmax indices.</li></ul><p><strong>Returns</strong></p><ul><li><code>out::AbstractVector</code>: Vector of maximum values across actions for each state.</li><li><code>out_argmax::AbstractVector</code>: Vector of argmax column indices for each state.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantEcon/QuantEcon.jl/blob/b686df7a6cf4c8a71a85fdeaf5add9cf27259e31/src/markov/ddp.jl#L734-L754">source</a></section></details></article><article><details class="docstring" open="true"><summary id="QuantEcon.s_wise_max!-Tuple{AbstractMatrix, AbstractVector}"><a class="docstring-binding" href="#QuantEcon.s_wise_max!-Tuple{AbstractMatrix, AbstractVector}"><code>QuantEcon.s_wise_max!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">s_wise_max!(vals, out)</code></pre><p>Populate <code>out</code> with  <code>max_a vals(s, a)</code>,  where <code>vals</code> is represented as a <code>AbstractMatrix</code> of size <code>(num_states, num_actions)</code>.</p><p><strong>Arguments</strong></p><ul><li><code>vals::AbstractMatrix</code>: Matrix of values of size <code>(num_states, num_actions)</code>.</li><li><code>out::AbstractVector</code>: Output vector to be populated with maximum values.</li></ul><p><strong>Returns</strong></p><ul><li><code>out::AbstractVector</code>: Vector of maximum values across actions for each state.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantEcon/QuantEcon.jl/blob/b686df7a6cf4c8a71a85fdeaf5add9cf27259e31/src/markov/ddp.jl#L716-L731">source</a></section></details></article><article><details class="docstring" open="true"><summary id="QuantEcon.s_wise_max-Tuple{AbstractMatrix}"><a class="docstring-binding" href="#QuantEcon.s_wise_max-Tuple{AbstractMatrix}"><code>QuantEcon.s_wise_max</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">s_wise_max(vals)</code></pre><p>Return the <code>Vector</code> <code>max_a vals(s, a)</code>,  where <code>vals</code> is represented as a <code>AbstractMatrix</code> of size <code>(num_states, num_actions)</code>.</p><p><strong>Arguments</strong></p><ul><li><code>vals::AbstractMatrix</code>: Matrix of values of size <code>(num_states, num_actions)</code>.</li></ul><p><strong>Returns</strong></p><ul><li><code>out::Vector</code>: Vector of maximum values across actions for each state.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantEcon/QuantEcon.jl/blob/b686df7a6cf4c8a71a85fdeaf5add9cf27259e31/src/markov/ddp.jl#L699-L713">source</a></section></details></article><article><details class="docstring" open="true"><summary id="QuantEcon.standardize_var-Tuple{AbstractVector, AbstractMatrix, AbstractMatrix, Integer}"><a class="docstring-binding" href="#QuantEcon.standardize_var-Tuple{AbstractVector, AbstractMatrix, AbstractMatrix, Integer}"><code>QuantEcon.standardize_var</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">standardize_var(b, B, Psi, M)</code></pre><p>Return standardized VAR(1) representation.</p><p><strong>Arguments</strong></p><ul><li><code>b::AbstractVector</code>: <code>M x 1</code> constant term vector.</li><li><code>B::AbstractMatrix</code>: <code>M x M</code> matrix of impact coefficients.</li><li><code>Psi::AbstractMatrix</code>: <code>M x M</code> variance-covariance matrix of innovations.</li><li><code>M::Integer</code>: Number of variables of the VAR(1) model.</li></ul><p><strong>Returns</strong></p><ul><li><code>A::Matrix</code>: Impact coefficients of standardized VAR(1) process.</li><li><code>C::AbstractMatrix</code>: Variance-covariance matrix of standardized model innovations.</li><li><code>mu::AbstractVector</code>: Mean of the standardized VAR(1) process.</li><li><code>Sigma::AbstractMatrix</code>: Variance-covariance matrix of the standardized VAR(1) process.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantEcon/QuantEcon.jl/blob/b686df7a6cf4c8a71a85fdeaf5add9cf27259e31/src/markov/markov_approx.jl#L480-L499">source</a></section></details></article><article><details class="docstring" open="true"><summary id="QuantEcon.standardize_var-Tuple{Real, Real, Real, Integer}"><a class="docstring-binding" href="#QuantEcon.standardize_var-Tuple{Real, Real, Real, Integer}"><code>QuantEcon.standardize_var</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">standardize_var(b, B, Psi, M)</code></pre><p>Return standardized AR(1) representation.</p><p><strong>Arguments</strong></p><ul><li><code>b::Real</code>: Constant term.</li><li><code>B::Real</code>: Impact coefficient.</li><li><code>Psi::Real</code>: Variance of innovation.</li><li><code>M::Integer == 1</code>: Must be one since the function is for AR(1).</li></ul><p><strong>Returns</strong></p><ul><li><code>A::Real</code>: Impact coefficient of standardized AR(1) process.</li><li><code>C::Real</code>: Standard deviation of the innovation.</li><li><code>mu::Real</code>: Mean of the standardized AR(1) process.</li><li><code>Sigma::Real</code>: Variance of the standardized AR(1) process.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantEcon/QuantEcon.jl/blob/b686df7a6cf4c8a71a85fdeaf5add9cf27259e31/src/markov/markov_approx.jl#L452-L471">source</a></section></details></article><article><details class="docstring" open="true"><summary id="QuantEcon.todense-Tuple{Type, Array}"><a class="docstring-binding" href="#QuantEcon.todense-Tuple{Type, Array}"><code>QuantEcon.todense</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>If <code>A</code> is already dense, return <code>A</code> as is.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantEcon/QuantEcon.jl/blob/b686df7a6cf4c8a71a85fdeaf5add9cf27259e31/src/markov/mc_tools.jl#L302">source</a></section></details></article><article><details class="docstring" open="true"><summary id="QuantEcon.todense-Tuple{Type, SparseArrays.SparseMatrixCSC}"><a class="docstring-binding" href="#QuantEcon.todense-Tuple{Type, SparseArrays.SparseMatrixCSC}"><code>QuantEcon.todense</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Custom version of <code>full</code>, which allows conversion to type <code>T</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantEcon/QuantEcon.jl/blob/b686df7a6cf4c8a71a85fdeaf5add9cf27259e31/src/markov/mc_tools.jl#L289">source</a></section></details></article><article><details class="docstring" open="true"><summary id="QuantEcon.warn_persistency-Tuple{AbstractMatrix, Quadrature}"><a class="docstring-binding" href="#QuantEcon.warn_persistency-Tuple{AbstractMatrix, Quadrature}"><code>QuantEcon.warn_persistency</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">warn_persistency(B, method)</code></pre><p>Check persistency when <code>method</code> is <code>Quadrature</code> and give warning if needed.</p><p><strong>Arguments</strong></p><ul><li><code>B::Union{Real, AbstractMatrix}</code>: Impact coefficient.</li><li><code>method::VAREstimationMethod</code>: Method for grid making.</li></ul><p><strong>Returns</strong></p><ul><li><code>nothing</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantEcon/QuantEcon.jl/blob/b686df7a6cf4c8a71a85fdeaf5add9cf27259e31/src/markov/markov_approx.jl#L427-L441">source</a></section></details></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../index.html">« Home</a><a class="docs-footer-nextpage" href="../man/contributing.html">Contributing »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Saturday 6 December 2025 03:42">Saturday 6 December 2025</span>. Using Julia version 1.12.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
