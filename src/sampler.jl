#=
    `MVNSampler` is used to draw from multivariate normal distribution
=#

import Base: ==

immutable MVNSampler{TM<:Real,TS<:Real,TQ<:LinAlg.BlasReal}
    mu::Vector{TM}
    Sigma::Matrix{TS}
    Q::Matrix{TQ}
end

function MVNSampler{TM<:Real,TS<:Real}(mu::Vector{TM}, Sigma::Matrix{TS})
    ATOL1, RTOL1 = 1e-8, 1e-8
    ATOL2, RTOL2 = 1e-8, 1e-14

    n = length(mu)

    if size(Sigma) != (n,n) # Check Sigma is n x n
        throw(ArgumentError("Sigma must be 2 dimensional and square matrix of same length to mu"))
    end

    issymmetric(Sigma) || throw(ArgumentError("Sigma must be symmetric"))

    A = copy(Sigma)
    C = cholfact!(Symmetric(A, :L), Val{true})
    r = C.rank
    p = invperm(C.piv)

    if C.rank == n  # Positive definite
        Q = tril!(A)[p,p]
        return MVNSampler(mu, Sigma, Q)
    end

    non_PSD_msg = "Sigma must be positive semidefinite"

    for i in C.rank+1:n
        C[:L][i, i] >= -ATOL1 - RTOL1 * C[:L][1, 1] ||
            throw(ArgumentError(non_PSD_msg))
    end

    tril!(view(A, :, 1:r))
    A[:, r+1:end] = 0
    Q = A[p,p]
    isapprox(Q*Q', Sigma; rtol=RTOL2, atol=ATOL2) ||
        throw(ArgumentError(non_PSD_msg))

    return MVNSampler(mu, Sigma, Q)
end

# methods with the optional rng argument first
Base.rand(rng::AbstractRNG, d::MVNSampler) = d.mu + d.Q * randn(rng, length(d.mu))
Base.rand(rng::AbstractRNG, d::MVNSampler, n::Integer) = d.mu.+d.Q*randn(rng,(length(d.mu),n))

# methods to draw from `MVNSampler`
Base.rand(d::MVNSampler) = rand(Base.GLOBAL_RNG, d)
Base.rand(d::MVNSampler, n::Integer) = rand(Base.GLOBAL_RNG, d, n)

==(f1::MVNSampler, f2::MVNSampler) =
    (f1.mu == f2.mu) && (f1.Sigma == f2.Sigma) && (f1.Q == f2.Q)
