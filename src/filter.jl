@doc doc"""
    hp_filter(y, λ)

Apply Hodrick-Prescott filter to `AbstractVector`.

# Arguments

- `y::AbstractVector`: Data to be detrended.
- `λ::Real`: Penalty on variation in trend.

# Returns

- `y_cyclical::Vector`: Cyclical component.
- `y_trend::Vector`: Trend component.
"""
function hp_filter(y::AbstractVector{T}, λ::Real) where T <: Real
    y = Vector(y)
    N = length(y)
    H = spdiagm(-2 => fill(λ, N-2),
                -1 => vcat(-2λ, fill(-4λ, N - 3), -2λ),
                 0 => vcat(1 + λ, 1 + 5λ, fill(1 + 6λ, N-4),
                           1 + 5λ, 1 + λ),
                 1 => vcat(-2λ, fill(-4λ, N - 3), -2λ),
                 2 => fill(λ, N-2))
    y_trend = float(H) \ y
    y_cyclical = y - y_trend
    return y_cyclical, y_trend
end

@doc doc"""
    hamilton_filter(y, h, p)

Apply Hamilton filter to `AbstractVector`.

http://econweb.ucsd.edu/~jhamilto/hp.pdf

# Arguments

- `y::AbstractVector`: Data to be filtered.
- `h::Integer`: Time horizon that we are likely to predict incorrectly.
  Original paper recommends 2 for annual data, 8 for quarterly data, 24 for
  monthly data.
- `p::Integer`: Number of lags in regression. Must be greater than `h`. Note:
  For seasonal data, it's desirable for `p` and `h` to be integer multiples
  of the number of observations in a year. E.g., for quarterly data, `h = 8`
  and `p = 4` are recommended.

# Returns

- `y_cycle::Vector`: Cyclical component.
- `y_trend::Vector`: Trend component.
"""
function hamilton_filter(y::AbstractVector, h::Integer, p::Integer)
    y = Vector(y)
    T = length(y)
    y_cycle = fill(NaN, T)

    # construct X matrix of lags
    X = ones(T-p-h+1)
    for j = 1:p
        X = hcat(X, y[p-j+1:T-h-j+1])
    end

    # do OLS regression
    b = (X'*X)\(X'*y[p+h:T])
    y_cycle[p+h:T] = y[p+h:T] - X*b
    y_trend = vcat(fill(NaN, p+h-1), X*b)
    return y_cycle, y_trend
end

@doc doc"""
    hamilton_filter(y, h)

Apply Hamilton filter to `AbstractVector` under random walk assumption.

http://econweb.ucsd.edu/~jhamilto/hp.pdf

# Arguments

- `y::AbstractVector`: Data to be filtered.
- `h::Integer`: Time horizon that we are likely to predict incorrectly.
  Original paper recommends 2 for annual data, 8 for quarterly data, 24 for
  monthly data. Note: For seasonal data, it's desirable for `h` to be an
  integer multiple of the number of observations in a year. E.g., for
  quarterly data, `h = 8` is recommended.

# Returns

- `y_cycle::Vector`: Cyclical component.
- `y_trend::Vector`: Trend component.
"""
function hamilton_filter(y::AbstractVector, h::Integer)
    y = Vector(y)
    T = length(y)
    y_cycle = fill(NaN, T)
    y_cycle[h+1:T] = y[h+1:T] - y[1:T-h]
    y_trend = y - y_cycle
    return y_cycle, y_trend
end

"""
- `g::Function`: Parameterized `Function` that recieves three arguments 
                 (data at each period, state at each period, parameter) and
                 return the density. For example, if the data `x <: Real` is 
                 generated by `N(mu_s, sigma_s)` where mean `mu` and std `sigma`
                 is state dependent, `g` should be defined as 
                 ```
                 g(x, s, parameter) =
                  exp(-((x-parameter.mu[s])^2)/(2*parameter.sigma[s]^2))/
                  sqrt(2*pi*parameter.sigma[s]^2)
                 ```
- `y::AbstractArray`: Collection of data whose row corresponds to periods
- `parameter`: Collection of parameters in the model. 
               Each parameter must be a vector that stores the values for each state.
               For example, if you want to set `mu` at state 1 is 0 and 
               `mu` at state 2 is 0.5 and `sigma` at state 1 is 3 and `sigma`
               at state 2 is 4, `parameter` should be
               ```
               parameter = (mu = [0, 0.5], sigma = [3, 4])
               ```
               Alternatively, you can define your own type and use it:
               ```
               struct ParaType
                   mu::Vector
                   sigma::Vector
               end
               parameter = ParaType([0, 0.5], [3, 4])
               ```
- `P::AbstractMatrix`: Transition matrix of state. It must be square.
- `M::Integer`: Number of states. It must be same as the number of rows and 
                columns of `P`. If `M` is not passed, number of rows of `P` is 
                set as `M`.
"""
mutable struct RegimeSwitchingModel{TD <: AbstractArray, 
               TP <: AbstractMatrix, TPS <: AbstractMatrix, TPRM}
    g::Function
    y::TD
    parameter::TPRM
    P::TP
    M::Int
    prob_smoothed::TPS
    logL::Float64
    function RegimeSwitchingModel(g, y, parameter, P, M, prob_smoothed, logL)
        if size(P, 1) != size(P, 2)
            error("P must be square")
        end
        if size(P, 1) != M
            error("the number of rows and columns of P must be equal to M")
        end
        return new{typeof(y), typeof(P), typeof(prob_smoothed), typeof(parameter)}(
                    g, y, parameter, P, M, prob_smoothed, logL)
    end
end
RegimeSwitchingModel(g::Function, y::AbstractArray, parameter, P::AbstractMatrix) =
    RegimeSwitchingModel(g, y, parameter, P, size(P, 1), 
                         fill(NaN, size(y, 1), size(P, 1)), NaN)

"""
Apply the filter developed by Hamilton (1989, Econometrica) to a regime switching
model.

##### Arguments
- `rsm::RegimeSwitchingModel`: `RegimeSwitchingModel`
- `prob_update_pre::AbstractVector`: `AbstractVector` of length `M`. Probability
                                     distribution of state at period 0 conditional
                                     on the information up to period 0.

##### Returns
- `p`: `T` length `Vector` of likelihood at each period
- `p_s_update`: `T x M` matrix of probability of period `t` data conditional on 
                the information up to period `t`.
- `p_s_forecast`: `T x M` matrix of probability of period `t` data conditional on
                  the information up to period `t-1`.
"""
function filter!(rsm::RegimeSwitchingModel;
                 prob_update_pre::AbstractVector = 
                  stationary_distributions(MarkovChain(rsm.P))[1])
    T = size(rsm.y, 1)
    p_s_forecast = Matrix{Float64}(undef, T, rsm.M)
    p_s_update = Matrix{Float64}(undef, T, rsm.M)
    p, _, _ = filter!(rsm, p_s_update, p_s_forecast,
                      prob_update_pre = prob_update_pre)
    return p, p_s_update, p_s_forecast
end

"""
Apply the filter developed by Hamilton (1989, Econometrica) to a regime switching
model.

##### Arguments
- `rsm::RegimeSwitchingModel`: `RegimeSwitchingModel` specifying the model
- `p_s_update::AbstractMatrix`: `T x M` matrix of probability of period `t` data
                        conditional on the information up to period `t`.
- `p_s_forecast::AbstractMatrix`: `T x M` matrix of probability of period `t` data
                          conditional on the information up to period `t-1`.
- `prob_update_pre::AbstractVector`: `AbstractVector` of length `M`, probability
                                     distribution of state at period 0
                                     conditional on the information up to period 0.

##### Returns
- `p`: `T` length `Vector` of likelihood at each period
- `p_s_update`: `T x M` matrix of probability of period `t` data conditional on 
                the information up to period `t`.
- `p_s_forecast`: `T x M` matrix of probability of period `t` data conditional on
                  the information up to period `t-1`.
"""
function filter!(rsm::RegimeSwitchingModel, 
                 p_s_update::AbstractMatrix, p_s_forecast::AbstractMatrix;
                 prob_update_pre::AbstractVector = 
                     stationary_distributions(MarkovChain(rsm.P))[1])
    g, y = rsm.g, rsm.y
    T = size(y, 1)
    p = Vector{Float64}(undef, T)
    logL = 0
    for t in 1:T
        forecast!(view(p_s_forecast, t, :), prob_update_pre, rsm.P)
        p[t] = update!(view(p_s_update, t, :), rsm, p_s_forecast[t, :], t)
        logL += log(p[t])
        prob_update_pre .= p_s_update[t, :]
    end
    rsm.logL = logL
    return p, p_s_update, p_s_forecast
end

"""
Given the state distribution of period `t-1` conditional on the information
up to period `t-1`, forecast the distribution of period `t`.

##### Arguments
- `p_s_forecast::AbstractVector`: `M` length `AbstractVector` that stores probability 
                                  distribution of state at period `t` conditional
                                  on the information up to period `t-1`.
- `p_s_update_pre::AbstractVector`: `M` length `AbstractVector` of probability
                                    distribution of state at period `t-1` 
                                    conditional on the information up to period 
                                    `t-1`.
- `P::AbstractMatrix`: `M x M` transition matrix of state.

#### Return
- `nothing`
"""
function forecast!(p_s_forecast::AbstractVector, 
                   p_s_update_pre::AbstractVector, P::AbstractMatrix)
    p_s_forecast .= P' * p_s_update_pre
    return nothing
end

"""
Given the state distribution of period `t` conditional on the information
up to period `t-1`, update the distribution using the infomration at period `t`.

##### Arguments
- `p_s_update::AbstractVector`: `M` length `AbstractVector` that stores probability
                                distribution of state at period `t` conditional 
                                on the information up to period `t`.
- `rsm::RegimeSwitchingModel`: `RegimeSwitchingModel` that specifies the model.
- `p_s_forecast::AbstractVector`: Probability distribution of state at period `t`
                         conditional on the information up to period `t-1`.
- `t::Integer`: Period.

#### Returns
- `p::Float64`: Likelihood of data at period `t`.
"""
function update!(p_s_update::AbstractVector, rsm::RegimeSwitchingModel, 
                 p_s_forecast::AbstractVector, t::Integer)
    y_at_period_t = get_y_at_period_t(rsm.y, t)
    eta = [max(0, rsm.g(y_at_period_t, s, rsm.parameter)) for s in 1:rsm.M]
    tmp = eta .* p_s_forecast
    p = sum(tmp)
    p_s_update .= tmp./p
    return p
end
get_y_at_period_t(y::AbstractMatrix, t::Union{Integer, AbstractVector}) = y[t, :]
get_y_at_period_t(y::AbstractVector, t::Union{Integer, AbstractVector}) = y[t]

"""
Apply the backward smoother developed by Kim to a regime switching model.

##### Arguments
- `rsm::RegimeSwitchingModel`: `RegimeSwitchingModel` specifying the model.
- `prob_update_pre::AbstractVector`: Length `M` `AbstractVector` of probability
                                     distribution of state at period 0 conditional
                                     on the information up to period 0.
- `verbose::Bool`: If `true`, the funciton returns joint distribution.
                   If `false`, `nothing` is returned.

##### Returns 
- `p_s_joint_smoothed`: `T x n_state x n_state` array of joint distribution of
                        state at period `t` and `t+1` data conditional on 
                        the all information.
"""
function smooth!(rsm::RegimeSwitchingModel;
                 prob_update_pre::AbstractVector = 
                     stationary_distributions(MarkovChain(rsm.P))[1],
                 verbose::Bool=false)
    p_s_joint_smoothed = Array{Float64, 3}(undef, size(rsm.y, 1), rsm.M, rsm.M)
    smooth!(rsm, p_s_joint_smoothed, prob_update_pre = prob_update_pre)
    return p_s_joint_smoothed
end

"""
Apply the backward smoother developed by Kim to a regime switching model.

Same as `smooth` except that the result is stored in the perallocated first argument.

##### Arguments
- `rsm::RegimeSwitchingModel`: `RegimeSwitchingModel` specifying the model.
- `p_s_joint_smoothed::AbstractArray`: `T x n_state x n_state` array that stores
                                       joint distribution of state at period `t`
                                       and `t+1` data conditional on the all
                                       information.
- `prob_update_pre::AbstractVector`: Probability distribution of state at period 0
                                    conditional on the information up to period 0.

##### Returns
- `p_s_joint_smoothed`: `T x n_state x n_state` array of joint distribution of
                        state at period `t` and `t+1` data conditional on 
                        the all information.
"""
function smooth!(rsm::RegimeSwitchingModel,
                 p_s_joint_smoothed::AbstractArray;
                 prob_update_pre::AbstractVector = 
                     stationary_distributions(MarkovChain(rsm.P))[1],
                 verbose::Bool=false)
    y = rsm.y
    M = rsm.M
    T = size(y, 1)
    rsm_tmp = RegimeSwitchingModel(rsm.g, y, rsm.parameter, rsm.P)
    ps, p_s_update, p_s_forecast = filter!(rsm_tmp,
                                           prob_update_pre = prob_update_pre)
    p_s_init = Vector{Float64}(undef, M)
    rsm.prob_smoothed[T, :] = p_s_update[T, :]
    for t = T-1:-1:1
        for s in 1:M
            for sp in 1:M
                p_s_joint_smoothed[t, s, sp] =
                    rsm.prob_smoothed[t+1, sp] * p_s_update[t, s] *
                    rsm.P[s, sp]/p_s_forecast[t+1, sp]
            end
            rsm.prob_smoothed[t, s] = sum(p_s_joint_smoothed[t, s, :])
        end
    end
    return p_s_joint_smoothed
end