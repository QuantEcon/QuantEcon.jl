@doc doc"""
apply Hodrick-Prescott filter to `AbstractVector`.

##### Arguments
- `y::AbstractVector` : data to be detrended
- `λ::Real` : penalty on variation in trend

##### Returns
- `y_cyclical::Vector`: cyclical component
- `y_trend::Vector`: trend component
"""
function hp_filter(y::AbstractVector{T}, λ::Real) where T <: Real
    y = Vector(y)
    N = length(y)
    H = spdiagm(-2 => fill(λ, N-2),
                -1 => vcat(-2λ, fill(-4λ, N - 3), -2λ),
                 0 => vcat(1 + λ, 1 + 5λ, fill(1 + 6λ, N-4),
                           1 + 5λ, 1 + λ),
                 1 => vcat(-2λ, fill(-4λ, N - 3), -2λ),
                 2 => fill(λ, N-2))
    y_trend = float(H) \ y
    y_cyclical = y - y_trend
    return y_cyclical, y_trend
end

@doc doc"""
This function applies "Hamilton filter" to `AbstractVector`.

http://econweb.ucsd.edu/~jhamilto/hp.pdf

##### Arguments
- `y::AbstractVector` : data to be filtered
- `h::Integer` : Time horizon that we are likely to predict incorrectly.
                 Original paper recommends 2 for annual data, 8 for quarterly data,
                 24 for monthly data.
- `p::Integer` : Number of lags in regression. Must be greater than `h`.
Note: For seasonal data, it's desirable for `p` and `h` to be integer multiples
      of the number of obsevations in a year.
      e.g. For quarterly data, `h = 8` and `p = 4` are recommended.
##### Returns
- `y_cycle::Vector` : cyclical component
- `y_trend::Vector` : trend component
"""
function hamilton_filter(y::AbstractVector, h::Integer, p::Integer)
    y = Vector(y)
    T = length(y)
    y_cycle = fill(NaN, T)

    # construct X matrix of lags
    X = ones(T-p-h+1)
    for j = 1:p
        X = hcat(X, y[p-j+1:T-h-j+1])
    end

    # do OLS regression
    b = (X'*X)\(X'*y[p+h:T])
    y_cycle[p+h:T] = y[p+h:T] - X*b
    y_trend = vcat(fill(NaN, p+h-1), X*b)
    return y_cycle, y_trend
end

@doc doc"""
This function applies "Hamilton filter" to `<:AbstractVector`
under random walk assumption.

http://econweb.ucsd.edu/~jhamilto/hp.pdf

##### Arguments
- `y::AbstractVector` : data to be filtered
- `h::Integer` : Time horizon that we are likely to predict incorrectly.
                 Original paper recommends 2 for annual data, 8 for quarterly data,
                 24 for monthly data.
Note: For seasonal data, it's desirable for `h` to be an integer multiple
      of the number of obsevations in a year.
      e.g. For quarterly data, `h = 8` is recommended.
##### Returns
- `y_cycle::Vector` : cyclical component
- `y_trend::Vector` : trend component
"""
function hamilton_filter(y::AbstractVector, h::Integer)
    y = Vector(y)
    T = length(y)
    y_cycle = fill(NaN, T)
    y_cycle[h+1:T] = y[h+1:T] - y[1:T-h]
    y_trend = y - y_cycle
    return y_cycle, y_trend
end

"""
- `g::Function`: Parameterized `Function` that recieves three arguments 
                 (data at each period, state at each period, parameter) and return the density.
                 For example, if the data `x <: Real` is generated by `N(mu_s, sigma_s)` where mean `mu` and std `sigma` is
                 state dependent, `g` should be defined as 
                 ```
                 g(x, s, parameter) = exp(-((x-parameter.mu[s])^2)/(2*parameter.sigma[s]^2))/sqrt(2*pi*parameter.sigma[s]^2)
                 ```
- `y::AbstractArray`: Collection of data whose row corresponds to periods
- `parameter`: Collection of parameters in the model. Each parameter must be a vector that stores the values for each state.
               For example, if you want to set `mu` at state 1 is 0 and `mu` at state 2 is 0.5 and 
               `sigma` at state 1 is 3 and `sigma` at state 2 is 4, `parameter` should be
               ```
               parameter = (mu = [0, 0.5], sigma = [3, 4])
               ```
               Alternatively, you can define your own type and use it:
               ```
               struct ParaType
                   mu::Vector
                   sigma::Vector
               end
               parameter = ParaType([0, 0.5], [3, 4])
               ```
- `P::AbstractMatrix`: Transition matrix of state. It must be square.
- `M::Integer`: Number of states. It must be same as the number of rows and columns of `P`. If `M` is not passed, 
                number of rows of `P` is set as `M`.
"""
mutable struct RegimeSwitchingModel{TD <: AbstractArray, TP <: AbstractMatrix}
    g::Function
    y::TD
    parameter
    P::TP
    M::Int
    function RegimeSwitchingModel(g, y, parameter, P, M)
        if size(P, 1) != size(P, 2)
            error("P must be square")
        end
        if size(P, 1) != M
            error("the number of rows and columns of P must be equal to M")
        end
        return new{typeof(y), typeof(P)}(g, y, parameter, P, M)
    end
end
RegimeSwitchingModel(g::Function, y::AbstractArray, parameter, P::AbstractMatrix) =
    RegimeSwitchingModel(g, y, parameter, P, size(P, 1))

"""
Apply the filter developed by Hamilton (1989, Econometrica) to a regime switching model.

##### Arguments
- `rsm::RegimeSwitchingModel`: `RegimeSwitchingModel`
- `p_s_update_pre::AbstractArray`: Probability distribution of state at period 0 conditional on the information up to
                                   period 0.

##### Returns
- `logL`: log likelihood 
- `p`: likelihood at each period
- `p_s_update`: Probability of period `t` data conditional on the information up to period `t`.
- `p_s_forecast`: Probability of period `t` data conditional on the information up to period `t-1`.
"""
function filter(rsm::RegimeSwitchingModel, p_s_update_pre::AbstractArray)
    T = size(rsm.y, 1)
    p_s_forecast = Matrix{Float64}(undef, T, rsm.M)
    p_s_update = Matrix{Float64}(undef, T, rsm.M)
    logL, p = filter!(p_s_update, p_s_forecast, rsm, p_s_update_pre)
    return logL, p, p_s_update, p_s_forecast
end

"""
Apply the filter developed by Hamilton (1989, Econometrica) to a regime switching model.

Same as `filter` except that the results are stored in the perallocated first and second arguments.

##### Arguments
- `p_s_update`: Probability of period `t` data conditional on the information up to period `t`.
- `p_s_forecast`: Probability of period `t` data conditional on the information up to period `t-1`.
- `rsm::RegimeSwitchingModel`: `RegimeSwitchingModel` specifying the model
- `p_s_update_pre::AbstractArray`: Probability distribution of state at period 0 conditional on the information up to
                                   period 0.

##### Returns
- `logL`: Log likelihood 
- `p`: Likelihood at each period.
"""
function filter!(p_s_update::Matrix, p_s_forecast::Matrix,
                 rsm::RegimeSwitchingModel, p_s_update_pre::AbstractArray)
    g, y = rsm.g, rsm.y
    T = size(y, 1)
    p = Vector{Float64}(undef, T)
    logL = 0
    for t in 1:T
        p_s_forecast[t, :] = forecast(p_s_update_pre, rsm.P)
        p_s_update[t, :], p[t] = update(rsm, p_s_forecast[t, :], t)
        logL += log(p[t])
        p_s_update_pre .= p_s_update[t, :]
    end
    return logL, p
end

"""
Given the state distribution of period `t-1` conditional on the information up to period `t-1`, 
forecast the distribution of period `t`.

##### Arguments
- `p_s_update_pre::AbstractArray`: Probability distribution of state at period `t-1` conditional on the 
                                   information up to period `t-1`.
- `P::AbstractMatrix`: Transition matrix of state.

#### Return
- `p_s_forecast`: Probability distribution of state at period `t` conditional on the 
                  information up to period `t-1`.
"""
function forecast(p_s_update_pre::AbstractArray, P::AbstractMatrix)
    p_s_forecast = P' * p_s_update_pre
    return p_s_forecast
end

"""
Given the state distribution of period `t` conditional on the information up to period `t-1`, 
update the distribution using the infomration at period `t`.

##### Arguments
- `rsm::RegimeSwitchingModel`: `RegimeSwitchingModel` that specifies the model.
- `p_s::Array`: Probability distribution of state at period `t` conditional on the 
                information up to period `t-1`.
- `t::Integer`: Period.

#### Returns
- `p_s`: Probability distribution of state at period `t` conditional on the 
         information up to period `t`.
- `p`: Likelihood of data at period `t`.
"""
function update(rsm::RegimeSwitchingModel, p_s::Array, t::Integer)
    y_at_period_t = get_y_at_period_t(rsm.y, t)
    eta = [max(0, rsm.g(y_at_period_t, s, rsm.parameter)) for s in 1:rsm.M]
    tmp = eta .* p_s
    p = sum(tmp)
    p_s = tmp./p
    return p_s, p
end
get_y_at_period_t(y::AbstractMatrix, t::Union{Integer, AbstractVector}) = y[t, :]
get_y_at_period_t(y::AbstractVector, t::Union{Integer, AbstractVector}) = y[t]

"""
Apply the smoother developed by Hamilton (1989, Econometrica) to a regime switching model.

##### Arguments
- `rsm::RegimeSwitchingModel`: `RegimeSwitchingModel` specifying the model.
- `p_s_update_pre::AbstractArray`: Probability distribution of state at period 0 conditional on the information up to
                                   period 0.

##### Returns
- `p_s_smoothed`: Probability of period `t` data conditional on the all information.
"""
function smooth(rsm::RegimeSwitchingModel,
                p_s_update_pre::AbstractArray = stationary_distributions(MarkovChain(P))[1])
    p_s_smoothed = Matrix{Float64}(undef, size(rsm.y, 1), rsm.M)
    smooth!(p_s_smoothed, rsm, p_s_update_pre)
    return p_s_smoothed
end

"""
Apply the smoother developed by Hamilton (1989, Econometrica) to a regime switching model.

Same as `smooth` except that the result is stored in the perallocated first argument.

##### Arguments
- `p_s_smoothed`: Probability of period `t` data conditional on the all information.
- `rsm::RegimeSwitchingModel`: `RegimeSwitchingModel` specifying the model.
- `p_s_update_pre::AbstractArray`: Probability distribution of state at period 0 conditional on the information up to
                                   period 0.

##### Returns
- Nothing
"""
function smooth!(p_s_smoothed::Matrix, rsm::RegimeSwitchingModel,
                 p_s_update_pre::AbstractArray = stationary_distributions(MarkovChain(P))[1])
    y = rsm.y
    M = rsm.M
    T = size(y, 1)
    rsm_tmp = RegimeSwitchingModel(rsm.g, y, rsm.parameter, rsm.P, M)
    _, ps, p_s_update, _ = filter(rsm_tmp, p_s_update_pre)
    p_s_init = Vector{Float64}(undef, M)
    for s_hat = 1:M
        for tau = 1:T-1
            p_s_init .= 0
            p_s_init[s_hat] = 1
            y_used = get_y_at_period_t(y, tau+1:T)
            rsm_tmp.y = y_used
            _, ps_cond, _, _ = filter(rsm_tmp, p_s_init)
            p_s_smoothed[tau, s_hat] = p_s_update[tau, s_hat] * prod(ps_cond./ps[tau+1:end])
        end
        p_s_smoothed[T, s_hat] = p_s_update[T, s_hat]
    end
    return nothing
end